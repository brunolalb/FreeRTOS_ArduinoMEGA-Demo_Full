
FreeRTOS_ArduinoMEGA-Demo_Full.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000118  00800200  00002fb8  0000304c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002fb8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001c08  00800318  00800318  00003164  2**0
                  ALLOC
  3 .stab         00008568  00000000  00000000  00003164  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006d7e  00000000  00000000  0000b6cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000120  00000000  00000000  0001244a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000173  00000000  00000000  0001256a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001bac  00000000  00000000  000126dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ef6  00000000  00000000  00014289  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000e80  00000000  00000000  0001517f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000140  00000000  00000000  00016000  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002cf  00000000  00000000  00016140  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000844  00000000  00000000  0001640f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00016c53  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	90 c0       	rjmp	.+288    	; 0x126 <__bad_interrupt>
       6:	00 00       	nop
       8:	8e c0       	rjmp	.+284    	; 0x126 <__bad_interrupt>
       a:	00 00       	nop
       c:	8c c0       	rjmp	.+280    	; 0x126 <__bad_interrupt>
       e:	00 00       	nop
      10:	8a c0       	rjmp	.+276    	; 0x126 <__bad_interrupt>
      12:	00 00       	nop
      14:	88 c0       	rjmp	.+272    	; 0x126 <__bad_interrupt>
      16:	00 00       	nop
      18:	86 c0       	rjmp	.+268    	; 0x126 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	84 c0       	rjmp	.+264    	; 0x126 <__bad_interrupt>
      1e:	00 00       	nop
      20:	82 c0       	rjmp	.+260    	; 0x126 <__bad_interrupt>
      22:	00 00       	nop
      24:	80 c0       	rjmp	.+256    	; 0x126 <__bad_interrupt>
      26:	00 00       	nop
      28:	7e c0       	rjmp	.+252    	; 0x126 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7c c0       	rjmp	.+248    	; 0x126 <__bad_interrupt>
      2e:	00 00       	nop
      30:	7a c0       	rjmp	.+244    	; 0x126 <__bad_interrupt>
      32:	00 00       	nop
      34:	78 c0       	rjmp	.+240    	; 0x126 <__bad_interrupt>
      36:	00 00       	nop
      38:	76 c0       	rjmp	.+236    	; 0x126 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	74 c0       	rjmp	.+232    	; 0x126 <__bad_interrupt>
      3e:	00 00       	nop
      40:	72 c0       	rjmp	.+228    	; 0x126 <__bad_interrupt>
      42:	00 00       	nop
      44:	15 c2       	rjmp	.+1066   	; 0x470 <__vector_17>
      46:	00 00       	nop
      48:	6e c0       	rjmp	.+220    	; 0x126 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6c c0       	rjmp	.+216    	; 0x126 <__bad_interrupt>
      4e:	00 00       	nop
      50:	6a c0       	rjmp	.+212    	; 0x126 <__bad_interrupt>
      52:	00 00       	nop
      54:	68 c0       	rjmp	.+208    	; 0x126 <__bad_interrupt>
      56:	00 00       	nop
      58:	66 c0       	rjmp	.+204    	; 0x126 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	64 c0       	rjmp	.+200    	; 0x126 <__bad_interrupt>
      5e:	00 00       	nop
      60:	62 c0       	rjmp	.+196    	; 0x126 <__bad_interrupt>
      62:	00 00       	nop
      64:	a7 c0       	rjmp	.+334    	; 0x1b4 <__vector_25>
      66:	00 00       	nop
      68:	5f c0       	rjmp	.+190    	; 0x128 <__vector_26>
      6a:	00 00       	nop
      6c:	5c c0       	rjmp	.+184    	; 0x126 <__bad_interrupt>
      6e:	00 00       	nop
      70:	5a c0       	rjmp	.+180    	; 0x126 <__bad_interrupt>
      72:	00 00       	nop
      74:	58 c0       	rjmp	.+176    	; 0x126 <__bad_interrupt>
      76:	00 00       	nop
      78:	56 c0       	rjmp	.+172    	; 0x126 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	54 c0       	rjmp	.+168    	; 0x126 <__bad_interrupt>
      7e:	00 00       	nop
      80:	52 c0       	rjmp	.+164    	; 0x126 <__bad_interrupt>
      82:	00 00       	nop
      84:	50 c0       	rjmp	.+160    	; 0x126 <__bad_interrupt>
      86:	00 00       	nop
      88:	4e c0       	rjmp	.+156    	; 0x126 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4c c0       	rjmp	.+152    	; 0x126 <__bad_interrupt>
      8e:	00 00       	nop
      90:	4a c0       	rjmp	.+148    	; 0x126 <__bad_interrupt>
      92:	00 00       	nop
      94:	48 c0       	rjmp	.+144    	; 0x126 <__bad_interrupt>
      96:	00 00       	nop
      98:	46 c0       	rjmp	.+140    	; 0x126 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	44 c0       	rjmp	.+136    	; 0x126 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	42 c0       	rjmp	.+132    	; 0x126 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	40 c0       	rjmp	.+128    	; 0x126 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3e c0       	rjmp	.+124    	; 0x126 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3c c0       	rjmp	.+120    	; 0x126 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	3a c0       	rjmp	.+116    	; 0x126 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	38 c0       	rjmp	.+112    	; 0x126 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	36 c0       	rjmp	.+108    	; 0x126 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	34 c0       	rjmp	.+104    	; 0x126 <__bad_interrupt>
      be:	00 00       	nop
      c0:	32 c0       	rjmp	.+100    	; 0x126 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	30 c0       	rjmp	.+96     	; 0x126 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2e c0       	rjmp	.+92     	; 0x126 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2c c0       	rjmp	.+88     	; 0x126 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	2a c0       	rjmp	.+84     	; 0x126 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	28 c0       	rjmp	.+80     	; 0x126 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	26 c0       	rjmp	.+76     	; 0x126 <__bad_interrupt>
      da:	00 00       	nop
      dc:	24 c0       	rjmp	.+72     	; 0x126 <__bad_interrupt>
      de:	00 00       	nop
      e0:	22 c0       	rjmp	.+68     	; 0x126 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	13 e0       	ldi	r17, 0x03	; 3
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e8 eb       	ldi	r30, 0xB8	; 184
      fc:	ff e2       	ldi	r31, 0x2F	; 47
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a8 31       	cpi	r26, 0x18	; 24
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	1f e1       	ldi	r17, 0x1F	; 31
     110:	a8 e1       	ldi	r26, 0x18	; 24
     112:	b3 e0       	ldi	r27, 0x03	; 3
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a0 32       	cpi	r26, 0x20	; 32
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <main>
     122:	0c 94 da 17 	jmp	0x2fb4	; 0x2fb4 <_exit>

00000126 <__bad_interrupt>:
     126:	6c cf       	rjmp	.-296    	; 0x0 <__vectors>

00000128 <__vector_26>:
	}
}
/*-----------------------------------------------------------*/

ISR( USART0_UDRE_vect )
{
     128:	1f 92       	push	r1
     12a:	0f 92       	push	r0
     12c:	0f b6       	in	r0, 0x3f	; 63
     12e:	0f 92       	push	r0
     130:	0b b6       	in	r0, 0x3b	; 59
     132:	0f 92       	push	r0
     134:	11 24       	eor	r1, r1
     136:	2f 93       	push	r18
     138:	3f 93       	push	r19
     13a:	4f 93       	push	r20
     13c:	5f 93       	push	r21
     13e:	6f 93       	push	r22
     140:	7f 93       	push	r23
     142:	8f 93       	push	r24
     144:	9f 93       	push	r25
     146:	af 93       	push	r26
     148:	bf 93       	push	r27
     14a:	ef 93       	push	r30
     14c:	ff 93       	push	r31
     14e:	df 93       	push	r29
     150:	cf 93       	push	r28
     152:	0f 92       	push	r0
     154:	0f 92       	push	r0
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     15a:	80 91 1a 03 	lds	r24, 0x031A
     15e:	90 91 1b 03 	lds	r25, 0x031B
     162:	be 01       	movw	r22, r28
     164:	6f 5f       	subi	r22, 0xFF	; 255
     166:	7f 4f       	sbci	r23, 0xFF	; 255
     168:	ae 01       	movw	r20, r28
     16a:	4e 5f       	subi	r20, 0xFE	; 254
     16c:	5f 4f       	sbci	r21, 0xFF	; 255
     16e:	6e d3       	rcall	.+1756   	; 0x84c <xQueueReceiveFromISR>
     170:	81 30       	cpi	r24, 0x01	; 1
     172:	21 f4       	brne	.+8      	; 0x17c <__vector_26+0x54>
     174:	89 81       	ldd	r24, Y+1	; 0x01
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     176:	80 93 c6 00 	sts	0x00C6, r24
     17a:	05 c0       	rjmp	.+10     	; 0x186 <__vector_26+0x5e>
     17c:	80 91 c1 00 	lds	r24, 0x00C1
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterrupt0Off();
     180:	8f 7d       	andi	r24, 0xDF	; 223
     182:	80 93 c1 00 	sts	0x00C1, r24
     186:	0f 90       	pop	r0
	}
}
     188:	0f 90       	pop	r0
     18a:	cf 91       	pop	r28
     18c:	df 91       	pop	r29
     18e:	ff 91       	pop	r31
     190:	ef 91       	pop	r30
     192:	bf 91       	pop	r27
     194:	af 91       	pop	r26
     196:	9f 91       	pop	r25
     198:	8f 91       	pop	r24
     19a:	7f 91       	pop	r23
     19c:	6f 91       	pop	r22
     19e:	5f 91       	pop	r21
     1a0:	4f 91       	pop	r20
     1a2:	3f 91       	pop	r19
     1a4:	2f 91       	pop	r18
     1a6:	0f 90       	pop	r0
     1a8:	0b be       	out	0x3b, r0	; 59
     1aa:	0f 90       	pop	r0
     1ac:	0f be       	out	0x3f, r0	; 63
     1ae:	0f 90       	pop	r0
     1b0:	1f 90       	pop	r1
     1b2:	18 95       	reti

000001b4 <__vector_25>:
 * INTERRUPTS
 *-----------------------------------------------------------
 */

ISR( USART0_RX_vect )
{
     1b4:	1f 92       	push	r1
     1b6:	0f 92       	push	r0
     1b8:	0f b6       	in	r0, 0x3f	; 63
     1ba:	0f 92       	push	r0
     1bc:	0b b6       	in	r0, 0x3b	; 59
     1be:	0f 92       	push	r0
     1c0:	11 24       	eor	r1, r1
     1c2:	2f 93       	push	r18
     1c4:	3f 93       	push	r19
     1c6:	4f 93       	push	r20
     1c8:	5f 93       	push	r21
     1ca:	6f 93       	push	r22
     1cc:	7f 93       	push	r23
     1ce:	8f 93       	push	r24
     1d0:	9f 93       	push	r25
     1d2:	af 93       	push	r26
     1d4:	bf 93       	push	r27
     1d6:	ef 93       	push	r30
     1d8:	ff 93       	push	r31
     1da:	df 93       	push	r29
     1dc:	cf 93       	push	r28
     1de:	0f 92       	push	r0
     1e0:	0f 92       	push	r0
     1e2:	cd b7       	in	r28, 0x3d	; 61
     1e4:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
unsigned char ucChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	/* If some problem occurred (Frame Error, Data Overrun or Parity), just flush the buffer and move on */
	ucChar = UCSR0A;
     1e6:	80 91 c0 00 	lds	r24, 0x00C0
	if (ucChar & (serFRAME_ERROR_BIT | serOVERRUN_ERROR_BIT | serPARITY_ERROR_BIT))
     1ea:	8c 71       	andi	r24, 0x1C	; 28
     1ec:	19 f4       	brne	.+6      	; 0x1f4 <__vector_25+0x40>
     1ee:	07 c0       	rjmp	.+14     	; 0x1fe <__vector_25+0x4a>
	{
		while ( UCSR0A & serRECEIVE_COMPLETE) cChar = UDR0;
     1f0:	80 91 c6 00 	lds	r24, 0x00C6
     1f4:	80 91 c0 00 	lds	r24, 0x00C0
     1f8:	87 fd       	sbrc	r24, 7
     1fa:	fa cf       	rjmp	.-12     	; 0x1f0 <__vector_25+0x3c>
     1fc:	14 c0       	rjmp	.+40     	; 0x226 <__vector_25+0x72>
	else
	{
		/* Get the character and post it on the queue of Rxed characters.
		If the post causes a task to wake force a context switch as the woken task
		may have a higher priority than the task we have interrupted. */
		cChar = UDR0;
     1fe:	80 91 c6 00 	lds	r24, 0x00C6
     202:	89 83       	std	Y+1, r24	; 0x01

		xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     204:	80 91 18 03 	lds	r24, 0x0318
     208:	90 91 19 03 	lds	r25, 0x0319

ISR( USART0_RX_vect )
{
signed char cChar;
unsigned char ucChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     20c:	1a 82       	std	Y+2, r1	; 0x02
		/* Get the character and post it on the queue of Rxed characters.
		If the post causes a task to wake force a context switch as the woken task
		may have a higher priority than the task we have interrupted. */
		cChar = UDR0;

		xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     20e:	be 01       	movw	r22, r28
     210:	6f 5f       	subi	r22, 0xFF	; 255
     212:	7f 4f       	sbci	r23, 0xFF	; 255
     214:	ae 01       	movw	r20, r28
     216:	4e 5f       	subi	r20, 0xFE	; 254
     218:	5f 4f       	sbci	r21, 0xFF	; 255
     21a:	20 e0       	ldi	r18, 0x00	; 0
     21c:	63 d3       	rcall	.+1734   	; 0x8e4 <xQueueGenericSendFromISR>
     21e:	8a 81       	ldd	r24, Y+2	; 0x02

		if( xHigherPriorityTaskWoken != pdFALSE )
     220:	88 23       	and	r24, r24
     222:	09 f0       	breq	.+2      	; 0x226 <__vector_25+0x72>
     224:	27 d1       	rcall	.+590    	; 0x474 <vPortYield>
		{
			taskYIELD();
     226:	0f 90       	pop	r0
     228:	0f 90       	pop	r0
		}
	}
}
     22a:	cf 91       	pop	r28
     22c:	df 91       	pop	r29
     22e:	ff 91       	pop	r31
     230:	ef 91       	pop	r30
     232:	bf 91       	pop	r27
     234:	af 91       	pop	r26
     236:	9f 91       	pop	r25
     238:	8f 91       	pop	r24
     23a:	7f 91       	pop	r23
     23c:	6f 91       	pop	r22
     23e:	5f 91       	pop	r21
     240:	4f 91       	pop	r20
     242:	3f 91       	pop	r19
     244:	2f 91       	pop	r18
     246:	0f 90       	pop	r0
     248:	0b be       	out	0x3b, r0	; 59
     24a:	0f 90       	pop	r0
     24c:	0f be       	out	0x3f, r0	; 63
     24e:	0f 90       	pop	r0
     250:	1f 90       	pop	r1
     252:	18 95       	reti

00000254 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     254:	10 92 1c 03 	sts	0x031C, r1

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstLEDS_OUTPUT;
     258:	8f ef       	ldi	r24, 0xFF	; 255
     25a:	84 b9       	out	0x04, r24	; 4
	PORTB &= ucCurrentOutputValue;
     25c:	95 b1       	in	r25, 0x05	; 5
     25e:	80 91 1c 03 	lds	r24, 0x031C
     262:	89 23       	and	r24, r25
     264:	85 b9       	out	0x05, r24	; 5
}
     266:	08 95       	ret

00000268 <vParTestToggleLED>:
	}
}
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     268:	0f 93       	push	r16
     26a:	1f 93       	push	r17
unsigned char ucBit = 1;

	if(( uxLED <= partstMAX_OUTPUT_LED ) && ( uxLED >= partstMIN_OUTPUT_LED ))
     26c:	88 30       	cpi	r24, 0x08	; 8
     26e:	70 f4       	brcc	.+28     	; 0x28c <vParTestToggleLED+0x24>
	{
		ucBit <<= uxLED;
     270:	01 e0       	ldi	r16, 0x01	; 1
     272:	10 e0       	ldi	r17, 0x00	; 0
     274:	02 c0       	rjmp	.+4      	; 0x27a <vParTestToggleLED+0x12>
     276:	00 0f       	add	r16, r16
     278:	11 1f       	adc	r17, r17
     27a:	8a 95       	dec	r24
     27c:	e2 f7       	brpl	.-8      	; 0x276 <vParTestToggleLED+0xe>

		vTaskSuspendAll();
     27e:	bc d5       	rcall	.+2936   	; 0xdf8 <vTaskSuspendAll>
     280:	03 b9       	out	0x03, r16	; 3
		{

			PINB = ucBit;
     282:	85 b1       	in	r24, 0x05	; 5
			ucCurrentOutputValue = PORTB;
     284:	80 93 1c 03 	sts	0x031C, r24
     288:	0e 94 82 0c 	call	0x1904	; 0x1904 <xTaskResumeAll>
		}
		xTaskResumeAll();			
     28c:	1f 91       	pop	r17
	}
}
     28e:	0f 91       	pop	r16
     290:	08 95       	ret

00000292 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     292:	fc 01       	movw	r30, r24
	unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     294:	91 e1       	ldi	r25, 0x11	; 17
     296:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     298:	22 e2       	ldi	r18, 0x22	; 34
     29a:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     29c:	83 e3       	ldi	r24, 0x33	; 51
     29e:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     2a0:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     2a2:	72 93       	st	-Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
     2a4:	12 92       	st	-Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     2a6:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     2a8:	80 e8       	ldi	r24, 0x80	; 128
     2aa:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* If we have an ATmega2560, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
     2ac:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
     2ae:	12 92       	st	-Z, r1
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     2b0:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     2b2:	82 e0       	ldi	r24, 0x02	; 2
     2b4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     2b6:	83 e0       	ldi	r24, 0x03	; 3
     2b8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     2ba:	84 e0       	ldi	r24, 0x04	; 4
     2bc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     2be:	85 e0       	ldi	r24, 0x05	; 5
     2c0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     2c2:	86 e0       	ldi	r24, 0x06	; 6
     2c4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2c6:	87 e0       	ldi	r24, 0x07	; 7
     2c8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2ca:	88 e0       	ldi	r24, 0x08	; 8
     2cc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2ce:	89 e0       	ldi	r24, 0x09	; 9
     2d0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2d2:	80 e1       	ldi	r24, 0x10	; 16
     2d4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2d6:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     2d8:	82 e1       	ldi	r24, 0x12	; 18
     2da:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     2dc:	83 e1       	ldi	r24, 0x13	; 19
     2de:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     2e0:	84 e1       	ldi	r24, 0x14	; 20
     2e2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     2e4:	85 e1       	ldi	r24, 0x15	; 21
     2e6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     2e8:	86 e1       	ldi	r24, 0x16	; 22
     2ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     2ec:	87 e1       	ldi	r24, 0x17	; 23
     2ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     2f0:	88 e1       	ldi	r24, 0x18	; 24
     2f2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     2f4:	89 e1       	ldi	r24, 0x19	; 25
     2f6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     2f8:	80 e2       	ldi	r24, 0x20	; 32
     2fa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     2fc:	81 e2       	ldi	r24, 0x21	; 33
     2fe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     300:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     302:	83 e2       	ldi	r24, 0x23	; 35
     304:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     306:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     308:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     30a:	86 e2       	ldi	r24, 0x26	; 38
     30c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     30e:	87 e2       	ldi	r24, 0x27	; 39
     310:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     312:	88 e2       	ldi	r24, 0x28	; 40
     314:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     316:	89 e2       	ldi	r24, 0x29	; 41
     318:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     31a:	80 e3       	ldi	r24, 0x30	; 48
     31c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x31;	/* R31 */
     31e:	81 e3       	ldi	r24, 0x31	; 49
     320:	82 93       	st	-Z, r24
     322:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     324:	cf 01       	movw	r24, r30
     326:	08 95       	ret

00000328 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     328:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     32c:	89 ef       	ldi	r24, 0xF9	; 249
     32e:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH_TCCR1A;
	TCCR1A = ucLowByte;
     332:	10 92 80 00 	sts	0x0080, r1
	ucLowByte = portCLEAR_COUNTER_ON_MATCH_TCCR1B | portPRESCALE_64;
	TCCR1B = ucLowByte;
     336:	8b e0       	ldi	r24, 0x0B	; 11
     338:	80 93 81 00 	sts	0x0081, r24


	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     33c:	ef e6       	ldi	r30, 0x6F	; 111
     33e:	f0 e0       	ldi	r31, 0x00	; 0
     340:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     342:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     344:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     346:	a0 91 79 1e 	lds	r26, 0x1E79
     34a:	b0 91 7a 1e 	lds	r27, 0x1E7A
     34e:	cd 91       	ld	r28, X+
     350:	cd bf       	out	0x3d, r28	; 61
     352:	dd 91       	ld	r29, X+
     354:	de bf       	out	0x3e, r29	; 62
     356:	ff 91       	pop	r31
     358:	ef 91       	pop	r30
     35a:	df 91       	pop	r29
     35c:	cf 91       	pop	r28
     35e:	bf 91       	pop	r27
     360:	af 91       	pop	r26
     362:	9f 91       	pop	r25
     364:	8f 91       	pop	r24
     366:	7f 91       	pop	r23
     368:	6f 91       	pop	r22
     36a:	5f 91       	pop	r21
     36c:	4f 91       	pop	r20
     36e:	3f 91       	pop	r19
     370:	2f 91       	pop	r18
     372:	1f 91       	pop	r17
     374:	0f 91       	pop	r16
     376:	ff 90       	pop	r15
     378:	ef 90       	pop	r14
     37a:	df 90       	pop	r13
     37c:	cf 90       	pop	r12
     37e:	bf 90       	pop	r11
     380:	af 90       	pop	r10
     382:	9f 90       	pop	r9
     384:	8f 90       	pop	r8
     386:	7f 90       	pop	r7
     388:	6f 90       	pop	r6
     38a:	5f 90       	pop	r5
     38c:	4f 90       	pop	r4
     38e:	3f 90       	pop	r3
     390:	2f 90       	pop	r2
     392:	1f 90       	pop	r1
     394:	0f 90       	pop	r0
     396:	0c be       	out	0x3c, r0	; 60
     398:	0f 90       	pop	r0
     39a:	0b be       	out	0x3b, r0	; 59
     39c:	0f 90       	pop	r0
     39e:	0f be       	out	0x3f, r0	; 63
     3a0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     3a2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	08 95       	ret

000003a8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3a8:	0f 92       	push	r0
     3aa:	0f b6       	in	r0, 0x3f	; 63
     3ac:	f8 94       	cli
     3ae:	0f 92       	push	r0
     3b0:	0b b6       	in	r0, 0x3b	; 59
     3b2:	0f 92       	push	r0
     3b4:	0c b6       	in	r0, 0x3c	; 60
     3b6:	0f 92       	push	r0
     3b8:	1f 92       	push	r1
     3ba:	11 24       	eor	r1, r1
     3bc:	2f 92       	push	r2
     3be:	3f 92       	push	r3
     3c0:	4f 92       	push	r4
     3c2:	5f 92       	push	r5
     3c4:	6f 92       	push	r6
     3c6:	7f 92       	push	r7
     3c8:	8f 92       	push	r8
     3ca:	9f 92       	push	r9
     3cc:	af 92       	push	r10
     3ce:	bf 92       	push	r11
     3d0:	cf 92       	push	r12
     3d2:	df 92       	push	r13
     3d4:	ef 92       	push	r14
     3d6:	ff 92       	push	r15
     3d8:	0f 93       	push	r16
     3da:	1f 93       	push	r17
     3dc:	2f 93       	push	r18
     3de:	3f 93       	push	r19
     3e0:	4f 93       	push	r20
     3e2:	5f 93       	push	r21
     3e4:	6f 93       	push	r22
     3e6:	7f 93       	push	r23
     3e8:	8f 93       	push	r24
     3ea:	9f 93       	push	r25
     3ec:	af 93       	push	r26
     3ee:	bf 93       	push	r27
     3f0:	cf 93       	push	r28
     3f2:	df 93       	push	r29
     3f4:	ef 93       	push	r30
     3f6:	ff 93       	push	r31
     3f8:	a0 91 79 1e 	lds	r26, 0x1E79
     3fc:	b0 91 7a 1e 	lds	r27, 0x1E7A
     400:	0d b6       	in	r0, 0x3d	; 61
     402:	0d 92       	st	X+, r0
     404:	0e b6       	in	r0, 0x3e	; 62
     406:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     408:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xTaskIncrementTick>
     40c:	88 23       	and	r24, r24
     40e:	09 f0       	breq	.+2      	; 0x412 <vPortYieldFromTick+0x6a>
	{
		vTaskSwitchContext();
     410:	8d d5       	rcall	.+2842   	; 0xf2c <vTaskSwitchContext>
     412:	a0 91 79 1e 	lds	r26, 0x1E79
	}
	portRESTORE_CONTEXT();
     416:	b0 91 7a 1e 	lds	r27, 0x1E7A
     41a:	cd 91       	ld	r28, X+
     41c:	cd bf       	out	0x3d, r28	; 61
     41e:	dd 91       	ld	r29, X+
     420:	de bf       	out	0x3e, r29	; 62
     422:	ff 91       	pop	r31
     424:	ef 91       	pop	r30
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	bf 91       	pop	r27
     42c:	af 91       	pop	r26
     42e:	9f 91       	pop	r25
     430:	8f 91       	pop	r24
     432:	7f 91       	pop	r23
     434:	6f 91       	pop	r22
     436:	5f 91       	pop	r21
     438:	4f 91       	pop	r20
     43a:	3f 91       	pop	r19
     43c:	2f 91       	pop	r18
     43e:	1f 91       	pop	r17
     440:	0f 91       	pop	r16
     442:	ff 90       	pop	r15
     444:	ef 90       	pop	r14
     446:	df 90       	pop	r13
     448:	cf 90       	pop	r12
     44a:	bf 90       	pop	r11
     44c:	af 90       	pop	r10
     44e:	9f 90       	pop	r9
     450:	8f 90       	pop	r8
     452:	7f 90       	pop	r7
     454:	6f 90       	pop	r6
     456:	5f 90       	pop	r5
     458:	4f 90       	pop	r4
     45a:	3f 90       	pop	r3
     45c:	2f 90       	pop	r2
     45e:	1f 90       	pop	r1
     460:	0f 90       	pop	r0
     462:	0c be       	out	0x3c, r0	; 60
     464:	0f 90       	pop	r0
     466:	0b be       	out	0x3b, r0	; 59
     468:	0f 90       	pop	r0
     46a:	0f be       	out	0x3f, r0	; 63
     46c:	0f 90       	pop	r0
     46e:	08 95       	ret

00000470 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
		vPortYieldFromTick();
     470:	9b df       	rcall	.-202    	; 0x3a8 <vPortYieldFromTick>
     472:	18 95       	reti

00000474 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     474:	0f 92       	push	r0
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	0f 92       	push	r0
     47c:	0b b6       	in	r0, 0x3b	; 59
     47e:	0f 92       	push	r0
     480:	0c b6       	in	r0, 0x3c	; 60
     482:	0f 92       	push	r0
     484:	1f 92       	push	r1
     486:	11 24       	eor	r1, r1
     488:	2f 92       	push	r2
     48a:	3f 92       	push	r3
     48c:	4f 92       	push	r4
     48e:	5f 92       	push	r5
     490:	6f 92       	push	r6
     492:	7f 92       	push	r7
     494:	8f 92       	push	r8
     496:	9f 92       	push	r9
     498:	af 92       	push	r10
     49a:	bf 92       	push	r11
     49c:	cf 92       	push	r12
     49e:	df 92       	push	r13
     4a0:	ef 92       	push	r14
     4a2:	ff 92       	push	r15
     4a4:	0f 93       	push	r16
     4a6:	1f 93       	push	r17
     4a8:	2f 93       	push	r18
     4aa:	3f 93       	push	r19
     4ac:	4f 93       	push	r20
     4ae:	5f 93       	push	r21
     4b0:	6f 93       	push	r22
     4b2:	7f 93       	push	r23
     4b4:	8f 93       	push	r24
     4b6:	9f 93       	push	r25
     4b8:	af 93       	push	r26
     4ba:	bf 93       	push	r27
     4bc:	cf 93       	push	r28
     4be:	df 93       	push	r29
     4c0:	ef 93       	push	r30
     4c2:	ff 93       	push	r31
     4c4:	a0 91 79 1e 	lds	r26, 0x1E79
     4c8:	b0 91 7a 1e 	lds	r27, 0x1E7A
     4cc:	0d b6       	in	r0, 0x3d	; 61
     4ce:	0d 92       	st	X+, r0
     4d0:	0e b6       	in	r0, 0x3e	; 62
     4d2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4d4:	2b d5       	rcall	.+2646   	; 0xf2c <vTaskSwitchContext>
     4d6:	a0 91 79 1e 	lds	r26, 0x1E79
	portRESTORE_CONTEXT();
     4da:	b0 91 7a 1e 	lds	r27, 0x1E7A
     4de:	cd 91       	ld	r28, X+
     4e0:	cd bf       	out	0x3d, r28	; 61
     4e2:	dd 91       	ld	r29, X+
     4e4:	de bf       	out	0x3e, r29	; 62
     4e6:	ff 91       	pop	r31
     4e8:	ef 91       	pop	r30
     4ea:	df 91       	pop	r29
     4ec:	cf 91       	pop	r28
     4ee:	bf 91       	pop	r27
     4f0:	af 91       	pop	r26
     4f2:	9f 91       	pop	r25
     4f4:	8f 91       	pop	r24
     4f6:	7f 91       	pop	r23
     4f8:	6f 91       	pop	r22
     4fa:	5f 91       	pop	r21
     4fc:	4f 91       	pop	r20
     4fe:	3f 91       	pop	r19
     500:	2f 91       	pop	r18
     502:	1f 91       	pop	r17
     504:	0f 91       	pop	r16
     506:	ff 90       	pop	r15
     508:	ef 90       	pop	r14
     50a:	df 90       	pop	r13
     50c:	cf 90       	pop	r12
     50e:	bf 90       	pop	r11
     510:	af 90       	pop	r10
     512:	9f 90       	pop	r9
     514:	8f 90       	pop	r8
     516:	7f 90       	pop	r7
     518:	6f 90       	pop	r6
     51a:	5f 90       	pop	r5
     51c:	4f 90       	pop	r4
     51e:	3f 90       	pop	r3
     520:	2f 90       	pop	r2
     522:	1f 90       	pop	r1
     524:	0f 90       	pop	r0
     526:	0c be       	out	0x3c, r0	; 60
     528:	0f 90       	pop	r0
     52a:	0b be       	out	0x3b, r0	; 59
     52c:	0f 90       	pop	r0
     52e:	0f be       	out	0x3f, r0	; 63
     530:	0f 90       	pop	r0
     532:	08 95       	ret

00000534 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
     534:	89 2b       	or	r24, r25
     536:	41 f0       	breq	.+16     	; 0x548 <vPortFree+0x14>
     538:	6b ea       	ldi	r22, 0xAB	; 171
     53a:	70 e0       	ldi	r23, 0x00	; 0
     53c:	80 e0       	ldi	r24, 0x00	; 0
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	40 e0       	ldi	r20, 0x00	; 0
     542:	52 e0       	ldi	r21, 0x02	; 2
     544:	0c 94 5c 17 	jmp	0x2eb8	; 0x2eb8 <vAssertCalled>
     548:	08 95       	ret

0000054a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     54a:	cf 93       	push	r28
     54c:	df 93       	push	r29
     54e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     550:	53 d4       	rcall	.+2214   	; 0xdf8 <vTaskSuspendAll>
     552:	80 91 1f 03 	lds	r24, 0x031F
	{
		if( pucAlignedHeap == NULL )
     556:	90 91 20 03 	lds	r25, 0x0320
     55a:	89 2b       	or	r24, r25
     55c:	31 f4       	brne	.+12     	; 0x56a <pvPortMalloc+0x20>
     55e:	82 e2       	ldi	r24, 0x22	; 34
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     560:	93 e0       	ldi	r25, 0x03	; 3
     562:	90 93 20 03 	sts	0x0320, r25
     566:	80 93 1f 03 	sts	0x031F, r24
     56a:	20 91 1d 03 	lds	r18, 0x031D
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     56e:	30 91 1e 03 	lds	r19, 0x031E
     572:	ce 01       	movw	r24, r28
     574:	82 0f       	add	r24, r18
     576:	93 1f       	adc	r25, r19
     578:	4b e1       	ldi	r20, 0x1B	; 27
     57a:	87 35       	cpi	r24, 0x57	; 87
     57c:	94 07       	cpc	r25, r20
     57e:	70 f4       	brcc	.+28     	; 0x59c <pvPortMalloc+0x52>
     580:	28 17       	cp	r18, r24
     582:	39 07       	cpc	r19, r25
     584:	58 f4       	brcc	.+22     	; 0x59c <pvPortMalloc+0x52>
     586:	c0 91 1f 03 	lds	r28, 0x031F
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     58a:	d0 91 20 03 	lds	r29, 0x0320
     58e:	c2 0f       	add	r28, r18
     590:	d3 1f       	adc	r29, r19
     592:	90 93 1e 03 	sts	0x031E, r25
			xNextFreeByte += xWantedSize;
     596:	80 93 1d 03 	sts	0x031D, r24
     59a:	02 c0       	rjmp	.+4      	; 0x5a0 <pvPortMalloc+0x56>
     59c:	c0 e0       	ldi	r28, 0x00	; 0
     59e:	d0 e0       	ldi	r29, 0x00	; 0
     5a0:	0e 94 82 0c 	call	0x1904	; 0x1904 <xTaskResumeAll>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5a4:	ce 01       	movw	r24, r28
		}
	}
	#endif

	return pvReturn;
}
     5a6:	df 91       	pop	r29
     5a8:	cf 91       	pop	r28
     5aa:	08 95       	ret

000005ac <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5ac:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ae:	9c 01       	movw	r18, r24
     5b0:	2d 5f       	subi	r18, 0xFD	; 253
     5b2:	3f 4f       	sbci	r19, 0xFF	; 255
     5b4:	32 83       	std	Z+2, r19	; 0x02
     5b6:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5b8:	8f ef       	ldi	r24, 0xFF	; 255
     5ba:	9f ef       	ldi	r25, 0xFF	; 255
     5bc:	94 83       	std	Z+4, r25	; 0x04
     5be:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5c0:	36 83       	std	Z+6, r19	; 0x06
     5c2:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5c4:	30 87       	std	Z+8, r19	; 0x08
     5c6:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5c8:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     5ca:	08 95       	ret

000005cc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5cc:	fc 01       	movw	r30, r24
     5ce:	11 86       	std	Z+9, r1	; 0x09
     5d0:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     5d2:	08 95       	ret

000005d4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5d4:	ac 01       	movw	r20, r24
ListItem_t * const pxIndex = pxList->pxIndex;
     5d6:	fc 01       	movw	r30, r24
     5d8:	a1 81       	ldd	r26, Z+1	; 0x01
     5da:	b2 81       	ldd	r27, Z+2	; 0x02
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     5dc:	fb 01       	movw	r30, r22
     5de:	b3 83       	std	Z+3, r27	; 0x03
     5e0:	a2 83       	std	Z+2, r26	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     5e2:	14 96       	adiw	r26, 0x04	; 4
     5e4:	8d 91       	ld	r24, X+
     5e6:	9c 91       	ld	r25, X
     5e8:	15 97       	sbiw	r26, 0x05	; 5
     5ea:	95 83       	std	Z+5, r25	; 0x05
     5ec:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     5ee:	14 96       	adiw	r26, 0x04	; 4
     5f0:	ed 91       	ld	r30, X+
     5f2:	fc 91       	ld	r31, X
     5f4:	15 97       	sbiw	r26, 0x05	; 5
     5f6:	73 83       	std	Z+3, r23	; 0x03
     5f8:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     5fa:	15 96       	adiw	r26, 0x05	; 5
     5fc:	7c 93       	st	X, r23
     5fe:	6e 93       	st	-X, r22
     600:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     602:	fb 01       	movw	r30, r22
     604:	51 87       	std	Z+9, r21	; 0x09
     606:	40 87       	std	Z+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     608:	fa 01       	movw	r30, r20
     60a:	80 81       	ld	r24, Z
     60c:	8f 5f       	subi	r24, 0xFF	; 255
     60e:	80 83       	st	Z, r24
}
     610:	08 95       	ret

00000612 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
     616:	9c 01       	movw	r18, r24
     618:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     61a:	48 81       	ld	r20, Y
     61c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     61e:	8f ef       	ldi	r24, 0xFF	; 255
     620:	4f 3f       	cpi	r20, 0xFF	; 255
     622:	58 07       	cpc	r21, r24
     624:	21 f4       	brne	.+8      	; 0x62e <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     626:	f9 01       	movw	r30, r18
     628:	a7 81       	ldd	r26, Z+7	; 0x07
     62a:	b0 85       	ldd	r27, Z+8	; 0x08
     62c:	0d c0       	rjmp	.+26     	; 0x648 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     62e:	d9 01       	movw	r26, r18
     630:	13 96       	adiw	r26, 0x03	; 3
     632:	12 96       	adiw	r26, 0x02	; 2
     634:	ed 91       	ld	r30, X+
     636:	fc 91       	ld	r31, X
     638:	13 97       	sbiw	r26, 0x03	; 3
     63a:	80 81       	ld	r24, Z
     63c:	91 81       	ldd	r25, Z+1	; 0x01
     63e:	48 17       	cp	r20, r24
     640:	59 07       	cpc	r21, r25
     642:	10 f0       	brcs	.+4      	; 0x648 <vListInsert+0x36>
     644:	df 01       	movw	r26, r30
     646:	f5 cf       	rjmp	.-22     	; 0x632 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     648:	12 96       	adiw	r26, 0x02	; 2
     64a:	ed 91       	ld	r30, X+
     64c:	fc 91       	ld	r31, X
     64e:	13 97       	sbiw	r26, 0x03	; 3
     650:	fb 83       	std	Y+3, r31	; 0x03
     652:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     654:	d5 83       	std	Z+5, r29	; 0x05
     656:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     658:	bd 83       	std	Y+5, r27	; 0x05
     65a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     65c:	13 96       	adiw	r26, 0x03	; 3
     65e:	dc 93       	st	X, r29
     660:	ce 93       	st	-X, r28
     662:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     664:	39 87       	std	Y+9, r19	; 0x09
     666:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     668:	f9 01       	movw	r30, r18
     66a:	80 81       	ld	r24, Z
     66c:	8f 5f       	subi	r24, 0xFF	; 255
     66e:	80 83       	st	Z, r24
}
     670:	df 91       	pop	r29
     672:	cf 91       	pop	r28
     674:	08 95       	ret

00000676 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     67c:	18 96       	adiw	r26, 0x08	; 8
     67e:	cd 91       	ld	r28, X+
     680:	dc 91       	ld	r29, X
     682:	19 97       	sbiw	r26, 0x09	; 9

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     684:	12 96       	adiw	r26, 0x02	; 2
     686:	4d 91       	ld	r20, X+
     688:	5c 91       	ld	r21, X
     68a:	13 97       	sbiw	r26, 0x03	; 3
     68c:	14 96       	adiw	r26, 0x04	; 4
     68e:	8d 91       	ld	r24, X+
     690:	9c 91       	ld	r25, X
     692:	15 97       	sbiw	r26, 0x05	; 5
     694:	fa 01       	movw	r30, r20
     696:	95 83       	std	Z+5, r25	; 0x05
     698:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     69a:	14 96       	adiw	r26, 0x04	; 4
     69c:	2d 91       	ld	r18, X+
     69e:	3c 91       	ld	r19, X
     6a0:	15 97       	sbiw	r26, 0x05	; 5
     6a2:	f9 01       	movw	r30, r18
     6a4:	53 83       	std	Z+3, r21	; 0x03
     6a6:	42 83       	std	Z+2, r20	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6a8:	89 81       	ldd	r24, Y+1	; 0x01
     6aa:	9a 81       	ldd	r25, Y+2	; 0x02
     6ac:	8a 17       	cp	r24, r26
     6ae:	9b 07       	cpc	r25, r27
     6b0:	11 f4       	brne	.+4      	; 0x6b6 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6b2:	3a 83       	std	Y+2, r19	; 0x02
     6b4:	29 83       	std	Y+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6b6:	19 96       	adiw	r26, 0x09	; 9
     6b8:	1c 92       	st	X, r1
     6ba:	1e 92       	st	-X, r1
     6bc:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     6be:	88 81       	ld	r24, Y
     6c0:	81 50       	subi	r24, 0x01	; 1
     6c2:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     6c4:	df 91       	pop	r29
     6c6:	cf 91       	pop	r28
     6c8:	08 95       	ret

000006ca <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     6ca:	ef 92       	push	r14
     6cc:	ff 92       	push	r15
     6ce:	1f 93       	push	r17
     6d0:	cf 93       	push	r28
     6d2:	df 93       	push	r29
     6d4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     6d6:	0f b6       	in	r0, 0x3f	; 63
     6d8:	f8 94       	cli
     6da:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     6dc:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     6de:	91 e1       	ldi	r25, 0x11	; 17
     6e0:	e9 2e       	mov	r14, r25
     6e2:	f1 2c       	mov	r15, r1
     6e4:	ec 0e       	add	r14, r28
     6e6:	fd 1e       	adc	r15, r29
     6e8:	09 c0       	rjmp	.+18     	; 0x6fc <prvUnlockQueue+0x32>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     6ea:	89 89       	ldd	r24, Y+17	; 0x11
     6ec:	88 23       	and	r24, r24
     6ee:	41 f0       	breq	.+16     	; 0x700 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     6f0:	c7 01       	movw	r24, r14
     6f2:	73 d5       	rcall	.+2790   	; 0x11da <xTaskRemoveFromEventList>
     6f4:	88 23       	and	r24, r24
     6f6:	09 f0       	breq	.+2      	; 0x6fa <prvUnlockQueue+0x30>
     6f8:	90 d3       	rcall	.+1824   	; 0xe1a <vTaskMissedYield>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     6fa:	11 50       	subi	r17, 0x01	; 1
     6fc:	11 16       	cp	r1, r17
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     6fe:	ac f3       	brlt	.-22     	; 0x6ea <prvUnlockQueue+0x20>
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     700:	8f ef       	ldi	r24, 0xFF	; 255
     702:	8e 8f       	std	Y+30, r24	; 0x1e
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     704:	0f 90       	pop	r0
     706:	0f be       	out	0x3f, r0	; 63
	}
	taskEXIT_CRITICAL();
     708:	0f b6       	in	r0, 0x3f	; 63
     70a:	f8 94       	cli

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     70c:	0f 92       	push	r0
     70e:	1d 8d       	ldd	r17, Y+29	; 0x1d
     710:	88 e0       	ldi	r24, 0x08	; 8
	{
		int8_t cRxLock = pxQueue->cRxLock;
     712:	e8 2e       	mov	r14, r24

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     714:	f1 2c       	mov	r15, r1
     716:	ec 0e       	add	r14, r28
     718:	fd 1e       	adc	r15, r29
     71a:	09 c0       	rjmp	.+18     	; 0x72e <prvUnlockQueue+0x64>
     71c:	88 85       	ldd	r24, Y+8	; 0x08
     71e:	88 23       	and	r24, r24
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     720:	41 f0       	breq	.+16     	; 0x732 <prvUnlockQueue+0x68>
     722:	c7 01       	movw	r24, r14
     724:	5a d5       	rcall	.+2740   	; 0x11da <xTaskRemoveFromEventList>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     726:	88 23       	and	r24, r24
     728:	09 f0       	breq	.+2      	; 0x72c <prvUnlockQueue+0x62>
     72a:	77 d3       	rcall	.+1774   	; 0xe1a <vTaskMissedYield>
     72c:	11 50       	subi	r17, 0x01	; 1
     72e:	11 16       	cp	r1, r17
				{
					vTaskMissedYield();
     730:	ac f3       	brlt	.-22     	; 0x71c <prvUnlockQueue+0x52>
     732:	8f ef       	ldi	r24, 0xFF	; 255
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     734:	8d 8f       	std	Y+29, r24	; 0x1d
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     736:	0f 90       	pop	r0
     738:	0f be       	out	0x3f, r0	; 63
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     73a:	df 91       	pop	r29
     73c:	cf 91       	pop	r28
	}
	taskEXIT_CRITICAL();
     73e:	1f 91       	pop	r17
     740:	ff 90       	pop	r15
}
     742:	ef 90       	pop	r14
     744:	08 95       	ret

00000746 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
     746:	cf 93       	push	r28
     748:	df 93       	push	r29
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     74a:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     74c:	0f b6       	in	r0, 0x3f	; 63
     74e:	f8 94       	cli
     750:	0f 92       	push	r0
     752:	8d 8d       	ldd	r24, Y+29	; 0x1d
     754:	8f 3f       	cpi	r24, 0xFF	; 255
     756:	09 f4       	brne	.+2      	; 0x75a <vQueueWaitForMessageRestricted+0x14>
     758:	1d 8e       	std	Y+29, r1	; 0x1d
     75a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     75c:	8f 3f       	cpi	r24, 0xFF	; 255
     75e:	09 f4       	brne	.+2      	; 0x762 <vQueueWaitForMessageRestricted+0x1c>
     760:	1e 8e       	std	Y+30, r1	; 0x1e
     762:	0f 90       	pop	r0
     764:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
     766:	8a 8d       	ldd	r24, Y+26	; 0x1a
     768:	88 23       	and	r24, r24
     76a:	19 f4       	brne	.+6      	; 0x772 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
     76c:	ce 01       	movw	r24, r28
     76e:	41 96       	adiw	r24, 0x11	; 17
     770:	a0 d7       	rcall	.+3904   	; 0x16b2 <vTaskPlaceOnEventListRestricted>
     772:	ce 01       	movw	r24, r28
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
     774:	aa df       	rcall	.-172    	; 0x6ca <prvUnlockQueue>
     776:	df 91       	pop	r29
     778:	cf 91       	pop	r28
	}
     77a:	08 95       	ret

0000077c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     77c:	0f 93       	push	r16
     77e:	1f 93       	push	r17
     780:	cf 93       	push	r28
     782:	df 93       	push	r29
     784:	ec 01       	movw	r28, r24
     786:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     788:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     78a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     78c:	44 23       	and	r20, r20
     78e:	c1 f1       	breq	.+112    	; 0x800 <prvCopyDataToQueue+0x84>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     790:	00 23       	and	r16, r16
     792:	b1 f4       	brne	.+44     	; 0x7c0 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     794:	8c 81       	ldd	r24, Y+4	; 0x04
     796:	9d 81       	ldd	r25, Y+5	; 0x05
     798:	50 e0       	ldi	r21, 0x00	; 0
     79a:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     79e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7a0:	2c 81       	ldd	r18, Y+4	; 0x04
     7a2:	3d 81       	ldd	r19, Y+5	; 0x05
     7a4:	28 0f       	add	r18, r24
     7a6:	31 1d       	adc	r19, r1
     7a8:	3d 83       	std	Y+5, r19	; 0x05
     7aa:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     7ac:	8a 81       	ldd	r24, Y+2	; 0x02
     7ae:	9b 81       	ldd	r25, Y+3	; 0x03
     7b0:	28 17       	cp	r18, r24
     7b2:	39 07       	cpc	r19, r25
     7b4:	28 f1       	brcs	.+74     	; 0x800 <prvCopyDataToQueue+0x84>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     7b6:	88 81       	ld	r24, Y
     7b8:	99 81       	ldd	r25, Y+1	; 0x01
     7ba:	9d 83       	std	Y+5, r25	; 0x05
     7bc:	8c 83       	std	Y+4, r24	; 0x04
     7be:	20 c0       	rjmp	.+64     	; 0x800 <prvCopyDataToQueue+0x84>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7c0:	8e 81       	ldd	r24, Y+6	; 0x06
     7c2:	9f 81       	ldd	r25, Y+7	; 0x07
     7c4:	50 e0       	ldi	r21, 0x00	; 0
     7c6:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     7ca:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7cc:	90 e0       	ldi	r25, 0x00	; 0
     7ce:	44 27       	eor	r20, r20
     7d0:	55 27       	eor	r21, r21
     7d2:	48 1b       	sub	r20, r24
     7d4:	59 0b       	sbc	r21, r25
     7d6:	8e 81       	ldd	r24, Y+6	; 0x06
     7d8:	9f 81       	ldd	r25, Y+7	; 0x07
     7da:	84 0f       	add	r24, r20
     7dc:	95 1f       	adc	r25, r21
     7de:	9f 83       	std	Y+7, r25	; 0x07
     7e0:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     7e2:	28 81       	ld	r18, Y
     7e4:	39 81       	ldd	r19, Y+1	; 0x01
     7e6:	82 17       	cp	r24, r18
     7e8:	93 07       	cpc	r25, r19
     7ea:	30 f4       	brcc	.+12     	; 0x7f8 <prvCopyDataToQueue+0x7c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     7ec:	8a 81       	ldd	r24, Y+2	; 0x02
     7ee:	9b 81       	ldd	r25, Y+3	; 0x03
     7f0:	84 0f       	add	r24, r20
     7f2:	95 1f       	adc	r25, r21
     7f4:	9f 83       	std	Y+7, r25	; 0x07
     7f6:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     7f8:	02 30       	cpi	r16, 0x02	; 2
     7fa:	11 f4       	brne	.+4      	; 0x800 <prvCopyDataToQueue+0x84>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     7fc:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     7fe:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     800:	1f 5f       	subi	r17, 0xFF	; 255
     802:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     804:	80 e0       	ldi	r24, 0x00	; 0
     806:	df 91       	pop	r29
     808:	cf 91       	pop	r28
     80a:	1f 91       	pop	r17
     80c:	0f 91       	pop	r16
     80e:	08 95       	ret

00000810 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     810:	fc 01       	movw	r30, r24
     812:	56 2f       	mov	r21, r22
     814:	a7 2f       	mov	r26, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     816:	24 8d       	ldd	r18, Z+28	; 0x1c
     818:	22 23       	and	r18, r18
     81a:	b9 f0       	breq	.+46     	; 0x84a <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     81c:	86 81       	ldd	r24, Z+6	; 0x06
     81e:	97 81       	ldd	r25, Z+7	; 0x07
     820:	82 0f       	add	r24, r18
     822:	91 1d       	adc	r25, r1
     824:	97 83       	std	Z+7, r25	; 0x07
     826:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     828:	22 81       	ldd	r18, Z+2	; 0x02
     82a:	33 81       	ldd	r19, Z+3	; 0x03
     82c:	82 17       	cp	r24, r18
     82e:	93 07       	cpc	r25, r19
     830:	20 f0       	brcs	.+8      	; 0x83a <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     832:	80 81       	ld	r24, Z
     834:	91 81       	ldd	r25, Z+1	; 0x01
     836:	97 83       	std	Z+7, r25	; 0x07
     838:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     83a:	44 8d       	ldd	r20, Z+28	; 0x1c
     83c:	66 81       	ldd	r22, Z+6	; 0x06
     83e:	77 81       	ldd	r23, Z+7	; 0x07
     840:	85 2f       	mov	r24, r21
     842:	9a 2f       	mov	r25, r26
     844:	50 e0       	ldi	r21, 0x00	; 0
     846:	0c 94 d1 17 	jmp	0x2fa2	; 0x2fa2 <memcpy>
     84a:	08 95       	ret

0000084c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
     84c:	cf 92       	push	r12
     84e:	df 92       	push	r13
     850:	ef 92       	push	r14
     852:	ff 92       	push	r15
     854:	0f 93       	push	r16
     856:	1f 93       	push	r17
     858:	cf 93       	push	r28
     85a:	df 93       	push	r29
     85c:	7b 01       	movw	r14, r22
     85e:	6a 01       	movw	r12, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     860:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );
     862:	00 97       	sbiw	r24, 0x00	; 0
     864:	41 f4       	brne	.+16     	; 0x876 <xQueueReceiveFromISR+0x2a>
     866:	60 ea       	ldi	r22, 0xA0	; 160
     868:	75 e0       	ldi	r23, 0x05	; 5
     86a:	80 e0       	ldi	r24, 0x00	; 0
     86c:	90 e0       	ldi	r25, 0x00	; 0
     86e:	4d e2       	ldi	r20, 0x2D	; 45
     870:	52 e0       	ldi	r21, 0x02	; 2
     872:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     876:	e1 14       	cp	r14, r1
     878:	f1 04       	cpc	r15, r1
     87a:	19 f4       	brne	.+6      	; 0x882 <xQueueReceiveFromISR+0x36>
     87c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     87e:	88 23       	and	r24, r24
     880:	41 f5       	brne	.+80     	; 0x8d2 <xQueueReceiveFromISR+0x86>
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     882:	1a 8d       	ldd	r17, Y+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     884:	11 23       	and	r17, r17
     886:	11 f4       	brne	.+4      	; 0x88c <xQueueReceiveFromISR+0x40>
     888:	80 e0       	ldi	r24, 0x00	; 0
     88a:	1a c0       	rjmp	.+52     	; 0x8c0 <xQueueReceiveFromISR+0x74>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
     88c:	0d 8d       	ldd	r16, Y+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     88e:	ce 01       	movw	r24, r28
     890:	b7 01       	movw	r22, r14
     892:	be df       	rcall	.-132    	; 0x810 <prvCopyDataFromQueue>
     894:	11 50       	subi	r17, 0x01	; 1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     896:	1a 8f       	std	Y+26, r17	; 0x1a
     898:	0f 3f       	cpi	r16, 0xFF	; 255

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
     89a:	79 f4       	brne	.+30     	; 0x8ba <xQueueReceiveFromISR+0x6e>
     89c:	88 85       	ldd	r24, Y+8	; 0x08
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     89e:	88 23       	and	r24, r24
     8a0:	71 f0       	breq	.+28     	; 0x8be <xQueueReceiveFromISR+0x72>
     8a2:	ce 01       	movw	r24, r28
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     8a4:	08 96       	adiw	r24, 0x08	; 8
     8a6:	99 d4       	rcall	.+2354   	; 0x11da <xTaskRemoveFromEventList>
     8a8:	88 23       	and	r24, r24
     8aa:	49 f0       	breq	.+18     	; 0x8be <xQueueReceiveFromISR+0x72>
     8ac:	c1 14       	cp	r12, r1
     8ae:	d1 04       	cpc	r13, r1
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
     8b0:	31 f0       	breq	.+12     	; 0x8be <xQueueReceiveFromISR+0x72>
     8b2:	81 e0       	ldi	r24, 0x01	; 1
     8b4:	f6 01       	movw	r30, r12
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
     8b6:	80 83       	st	Z, r24
     8b8:	03 c0       	rjmp	.+6      	; 0x8c0 <xQueueReceiveFromISR+0x74>
     8ba:	0f 5f       	subi	r16, 0xFF	; 255
     8bc:	0d 8f       	std	Y+29, r16	; 0x1d
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
     8be:	81 e0       	ldi	r24, 0x01	; 1
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     8c4:	1f 91       	pop	r17
     8c6:	0f 91       	pop	r16
     8c8:	ff 90       	pop	r15
     8ca:	ef 90       	pop	r14
     8cc:	df 90       	pop	r13
     8ce:	cf 90       	pop	r12
     8d0:	08 95       	ret
     8d2:	61 ea       	ldi	r22, 0xA1	; 161
     8d4:	75 e0       	ldi	r23, 0x05	; 5
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     8d6:	80 e0       	ldi	r24, 0x00	; 0
     8d8:	90 e0       	ldi	r25, 0x00	; 0
     8da:	4d e2       	ldi	r20, 0x2D	; 45
     8dc:	52 e0       	ldi	r21, 0x02	; 2
     8de:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     8e2:	cf cf       	rjmp	.-98     	; 0x882 <xQueueReceiveFromISR+0x36>

000008e4 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     8e4:	cf 92       	push	r12
     8e6:	df 92       	push	r13
     8e8:	ef 92       	push	r14
     8ea:	ff 92       	push	r15
     8ec:	0f 93       	push	r16
     8ee:	1f 93       	push	r17
     8f0:	cf 93       	push	r28
     8f2:	df 93       	push	r29
     8f4:	7b 01       	movw	r14, r22
     8f6:	6a 01       	movw	r12, r20
     8f8:	02 2f       	mov	r16, r18
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     8fa:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );
     8fc:	00 97       	sbiw	r24, 0x00	; 0
     8fe:	41 f4       	brne	.+16     	; 0x910 <xQueueGenericSendFromISR+0x2c>
     900:	6f e9       	ldi	r22, 0x9F	; 159
     902:	73 e0       	ldi	r23, 0x03	; 3
     904:	80 e0       	ldi	r24, 0x00	; 0
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	4d e2       	ldi	r20, 0x2D	; 45
     90a:	52 e0       	ldi	r21, 0x02	; 2
     90c:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     910:	e1 14       	cp	r14, r1
     912:	f1 04       	cpc	r15, r1
     914:	19 f4       	brne	.+6      	; 0x91c <xQueueGenericSendFromISR+0x38>
     916:	8c 8d       	ldd	r24, Y+28	; 0x1c
     918:	88 23       	and	r24, r24
     91a:	79 f5       	brne	.+94     	; 0x97a <xQueueGenericSendFromISR+0x96>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     91c:	02 30       	cpi	r16, 0x02	; 2
     91e:	19 f4       	brne	.+6      	; 0x926 <xQueueGenericSendFromISR+0x42>
     920:	8b 8d       	ldd	r24, Y+27	; 0x1b
     922:	81 30       	cpi	r24, 0x01	; 1
     924:	99 f5       	brne	.+102    	; 0x98c <xQueueGenericSendFromISR+0xa8>
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     926:	9a 8d       	ldd	r25, Y+26	; 0x1a
     928:	8b 8d       	ldd	r24, Y+27	; 0x1b
     92a:	98 17       	cp	r25, r24
     92c:	20 f0       	brcs	.+8      	; 0x936 <xQueueGenericSendFromISR+0x52>
     92e:	02 30       	cpi	r16, 0x02	; 2
     930:	11 f0       	breq	.+4      	; 0x936 <xQueueGenericSendFromISR+0x52>
     932:	80 e0       	ldi	r24, 0x00	; 0
     934:	19 c0       	rjmp	.+50     	; 0x968 <xQueueGenericSendFromISR+0x84>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     936:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     938:	ce 01       	movw	r24, r28
     93a:	b7 01       	movw	r22, r14
     93c:	40 2f       	mov	r20, r16
     93e:	1e df       	rcall	.-452    	; 0x77c <prvCopyDataToQueue>
     940:	1f 3f       	cpi	r17, 0xFF	; 255

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     942:	79 f4       	brne	.+30     	; 0x962 <xQueueGenericSendFromISR+0x7e>
     944:	89 89       	ldd	r24, Y+17	; 0x11
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     946:	88 23       	and	r24, r24
     948:	71 f0       	breq	.+28     	; 0x966 <xQueueGenericSendFromISR+0x82>
     94a:	ce 01       	movw	r24, r28
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     94c:	41 96       	adiw	r24, 0x11	; 17
     94e:	45 d4       	rcall	.+2186   	; 0x11da <xTaskRemoveFromEventList>
     950:	88 23       	and	r24, r24
     952:	49 f0       	breq	.+18     	; 0x966 <xQueueGenericSendFromISR+0x82>
     954:	c1 14       	cp	r12, r1
     956:	d1 04       	cpc	r13, r1
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     958:	31 f0       	breq	.+12     	; 0x966 <xQueueGenericSendFromISR+0x82>
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	f6 01       	movw	r30, r12
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     95e:	80 83       	st	Z, r24
     960:	03 c0       	rjmp	.+6      	; 0x968 <xQueueGenericSendFromISR+0x84>
     962:	1f 5f       	subi	r17, 0xFF	; 255
     964:	1e 8f       	std	Y+30, r17	; 0x1e
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     966:	81 e0       	ldi	r24, 0x01	; 1
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     96c:	1f 91       	pop	r17
     96e:	0f 91       	pop	r16
     970:	ff 90       	pop	r15
     972:	ef 90       	pop	r14
     974:	df 90       	pop	r13
     976:	cf 90       	pop	r12
     978:	08 95       	ret
     97a:	60 ea       	ldi	r22, 0xA0	; 160
     97c:	73 e0       	ldi	r23, 0x03	; 3
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     97e:	80 e0       	ldi	r24, 0x00	; 0
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	4d e2       	ldi	r20, 0x2D	; 45
     984:	52 e0       	ldi	r21, 0x02	; 2
     986:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     98a:	c8 cf       	rjmp	.-112    	; 0x91c <xQueueGenericSendFromISR+0x38>
     98c:	61 ea       	ldi	r22, 0xA1	; 161
     98e:	73 e0       	ldi	r23, 0x03	; 3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     990:	80 e0       	ldi	r24, 0x00	; 0
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	4d e2       	ldi	r20, 0x2D	; 45
     996:	52 e0       	ldi	r21, 0x02	; 2
     998:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     99c:	c4 cf       	rjmp	.-120    	; 0x926 <xQueueGenericSendFromISR+0x42>

0000099e <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     99e:	6f 92       	push	r6
     9a0:	7f 92       	push	r7
     9a2:	8f 92       	push	r8
     9a4:	9f 92       	push	r9
     9a6:	af 92       	push	r10
     9a8:	bf 92       	push	r11
     9aa:	cf 92       	push	r12
     9ac:	df 92       	push	r13
     9ae:	ef 92       	push	r14
     9b0:	ff 92       	push	r15
     9b2:	0f 93       	push	r16
     9b4:	1f 93       	push	r17
     9b6:	df 93       	push	r29
     9b8:	cf 93       	push	r28
     9ba:	00 d0       	rcall	.+0      	; 0x9bc <xQueueGenericReceive+0x1e>
     9bc:	0f 92       	push	r0
     9be:	0f 92       	push	r0
     9c0:	cd b7       	in	r28, 0x3d	; 61
     9c2:	de b7       	in	r29, 0x3e	; 62
     9c4:	4b 01       	movw	r8, r22
     9c6:	5d 83       	std	Y+5, r21	; 0x05
     9c8:	4c 83       	std	Y+4, r20	; 0x04
     9ca:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     9cc:	8c 01       	movw	r16, r24

	configASSERT( pxQueue );
     9ce:	00 97       	sbiw	r24, 0x00	; 0
     9d0:	41 f4       	brne	.+16     	; 0x9e2 <xQueueGenericReceive+0x44>
     9d2:	6c ed       	ldi	r22, 0xDC	; 220
     9d4:	74 e0       	ldi	r23, 0x04	; 4
     9d6:	80 e0       	ldi	r24, 0x00	; 0
     9d8:	90 e0       	ldi	r25, 0x00	; 0
     9da:	4d e2       	ldi	r20, 0x2D	; 45
     9dc:	52 e0       	ldi	r21, 0x02	; 2
     9de:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     9e2:	81 14       	cp	r8, r1
     9e4:	91 04       	cpc	r9, r1
     9e6:	29 f4       	brne	.+10     	; 0x9f2 <xQueueGenericReceive+0x54>
     9e8:	f8 01       	movw	r30, r16
     9ea:	84 8d       	ldd	r24, Z+28	; 0x1c
     9ec:	88 23       	and	r24, r24
     9ee:	09 f0       	breq	.+2      	; 0x9f2 <xQueueGenericReceive+0x54>
     9f0:	9c c0       	rjmp	.+312    	; 0xb2a <xQueueGenericReceive+0x18c>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     9f2:	17 d2       	rcall	.+1070   	; 0xe22 <xTaskGetSchedulerState>
     9f4:	88 23       	and	r24, r24
     9f6:	29 f4       	brne	.+10     	; 0xa02 <xQueueGenericReceive+0x64>
     9f8:	8c 81       	ldd	r24, Y+4	; 0x04
     9fa:	9d 81       	ldd	r25, Y+5	; 0x05
     9fc:	89 2b       	or	r24, r25
     9fe:	09 f0       	breq	.+2      	; 0xa02 <xQueueGenericReceive+0x64>
     a00:	9d c0       	rjmp	.+314    	; 0xb3c <xQueueGenericReceive+0x19e>
     a02:	41 e1       	ldi	r20, 0x11	; 17
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a04:	a4 2e       	mov	r10, r20
     a06:	b1 2c       	mov	r11, r1
     a08:	a0 0e       	add	r10, r16
     a0a:	b1 1e       	adc	r11, r17
     a0c:	20 e0       	ldi	r18, 0x00	; 0
     a0e:	6e 01       	movw	r12, r28
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     a10:	08 94       	sec
     a12:	c1 1c       	adc	r12, r1
     a14:	d1 1c       	adc	r13, r1
     a16:	34 e0       	ldi	r19, 0x04	; 4

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     a18:	63 2e       	mov	r6, r19
     a1a:	71 2c       	mov	r7, r1
     a1c:	6c 0e       	add	r6, r28
     a1e:	7d 1e       	adc	r7, r29
     a20:	01 c0       	rjmp	.+2      	; 0xa24 <xQueueGenericReceive+0x86>
     a22:	21 e0       	ldi	r18, 0x01	; 1
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a24:	0f b6       	in	r0, 0x3f	; 63
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a26:	f8 94       	cli
     a28:	0f 92       	push	r0
     a2a:	f8 01       	movw	r30, r16
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     a2c:	f2 8c       	ldd	r15, Z+26	; 0x1a
     a2e:	ff 20       	and	r15, r15

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     a30:	f9 f0       	breq	.+62     	; 0xa70 <xQueueGenericReceive+0xd2>
     a32:	c6 80       	ldd	r12, Z+6	; 0x06
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a34:	d7 80       	ldd	r13, Z+7	; 0x07
     a36:	c8 01       	movw	r24, r16

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a38:	b4 01       	movw	r22, r8
     a3a:	ea de       	rcall	.-556    	; 0x810 <prvCopyDataFromQueue>
     a3c:	ee 20       	and	r14, r14
     a3e:	49 f4       	brne	.+18     	; 0xa52 <xQueueGenericReceive+0xb4>

				if( xJustPeeking == pdFALSE )
     a40:	fa 94       	dec	r15
     a42:	f8 01       	movw	r30, r16
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     a44:	f2 8e       	std	Z+26, r15	; 0x1a
     a46:	80 85       	ldd	r24, Z+8	; 0x08
     a48:	88 23       	and	r24, r24
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a4a:	71 f0       	breq	.+28     	; 0xa68 <xQueueGenericReceive+0xca>
     a4c:	c8 01       	movw	r24, r16
     a4e:	08 96       	adiw	r24, 0x08	; 8
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     a50:	07 c0       	rjmp	.+14     	; 0xa60 <xQueueGenericReceive+0xc2>
     a52:	f8 01       	movw	r30, r16
     a54:	d7 82       	std	Z+7, r13	; 0x07
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     a56:	c6 82       	std	Z+6, r12	; 0x06
     a58:	81 89       	ldd	r24, Z+17	; 0x11
     a5a:	88 23       	and	r24, r24

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a5c:	29 f0       	breq	.+10     	; 0xa68 <xQueueGenericReceive+0xca>
     a5e:	c5 01       	movw	r24, r10
     a60:	bc d3       	rcall	.+1912   	; 0x11da <xTaskRemoveFromEventList>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a62:	88 23       	and	r24, r24
     a64:	09 f0       	breq	.+2      	; 0xa68 <xQueueGenericReceive+0xca>
     a66:	06 dd       	rcall	.-1524   	; 0x474 <vPortYield>
     a68:	0f 90       	pop	r0
     a6a:	0f be       	out	0x3f, r0	; 63
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     a6c:	81 e0       	ldi	r24, 0x01	; 1
     a6e:	49 c0       	rjmp	.+146    	; 0xb02 <xQueueGenericReceive+0x164>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     a70:	8c 81       	ldd	r24, Y+4	; 0x04
     a72:	9d 81       	ldd	r25, Y+5	; 0x05
     a74:	89 2b       	or	r24, r25
     a76:	21 f4       	brne	.+8      	; 0xa80 <xQueueGenericReceive+0xe2>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     a78:	0f 90       	pop	r0
     a7a:	0f be       	out	0x3f, r0	; 63
     a7c:	80 e0       	ldi	r24, 0x00	; 0
     a7e:	41 c0       	rjmp	.+130    	; 0xb02 <xQueueGenericReceive+0x164>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     a80:	22 23       	and	r18, r18
     a82:	11 f4       	brne	.+4      	; 0xa88 <xQueueGenericReceive+0xea>
     a84:	c6 01       	movw	r24, r12
     a86:	f0 d1       	rcall	.+992    	; 0xe68 <vTaskSetTimeOutState>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     a88:	0f 90       	pop	r0
     a8a:	0f be       	out	0x3f, r0	; 63
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     a8c:	b5 d1       	rcall	.+874    	; 0xdf8 <vTaskSuspendAll>
     a8e:	0f b6       	in	r0, 0x3f	; 63
     a90:	f8 94       	cli
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     a92:	0f 92       	push	r0
     a94:	f8 01       	movw	r30, r16

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     a96:	85 8d       	ldd	r24, Z+29	; 0x1d
     a98:	8f 3f       	cpi	r24, 0xFF	; 255
		prvLockQueue( pxQueue );
     a9a:	09 f4       	brne	.+2      	; 0xa9e <xQueueGenericReceive+0x100>
     a9c:	15 8e       	std	Z+29, r1	; 0x1d
     a9e:	f8 01       	movw	r30, r16
     aa0:	86 8d       	ldd	r24, Z+30	; 0x1e
     aa2:	8f 3f       	cpi	r24, 0xFF	; 255
     aa4:	09 f4       	brne	.+2      	; 0xaa8 <xQueueGenericReceive+0x10a>
     aa6:	16 8e       	std	Z+30, r1	; 0x1e
     aa8:	0f 90       	pop	r0
     aaa:	0f be       	out	0x3f, r0	; 63
     aac:	c6 01       	movw	r24, r12
     aae:	b3 01       	movw	r22, r6
     ab0:	f4 d1       	rcall	.+1000   	; 0xe9a <xTaskCheckForTimeOut>
     ab2:	88 23       	and	r24, r24
     ab4:	c9 f4       	brne	.+50     	; 0xae8 <xQueueGenericReceive+0x14a>
     ab6:	0f b6       	in	r0, 0x3f	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ab8:	f8 94       	cli
     aba:	0f 92       	push	r0
     abc:	f8 01       	movw	r30, r16
     abe:	82 8d       	ldd	r24, Z+26	; 0x1a
     ac0:	0f 90       	pop	r0
     ac2:	0f be       	out	0x3f, r0	; 63

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     ac4:	88 23       	and	r24, r24
     ac6:	61 f4       	brne	.+24     	; 0xae0 <xQueueGenericReceive+0x142>
     ac8:	6c 81       	ldd	r22, Y+4	; 0x04
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     aca:	7d 81       	ldd	r23, Y+5	; 0x05
     acc:	c5 01       	movw	r24, r10
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     ace:	19 d6       	rcall	.+3122   	; 0x1702 <vTaskPlaceOnEventList>
     ad0:	c8 01       	movw	r24, r16
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ad2:	fb dd       	rcall	.-1034   	; 0x6ca <prvUnlockQueue>
     ad4:	17 d7       	rcall	.+3630   	; 0x1904 <xTaskResumeAll>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ad6:	88 23       	and	r24, r24
     ad8:	09 f0       	breq	.+2      	; 0xadc <xQueueGenericReceive+0x13e>
     ada:	a3 cf       	rjmp	.-186    	; 0xa22 <xQueueGenericReceive+0x84>
     adc:	cb dc       	rcall	.-1642   	; 0x474 <vPortYield>
     ade:	a1 cf       	rjmp	.-190    	; 0xa22 <xQueueGenericReceive+0x84>
				prvUnlockQueue( pxQueue );
     ae0:	c8 01       	movw	r24, r16
     ae2:	f3 dd       	rcall	.-1050   	; 0x6ca <prvUnlockQueue>
     ae4:	0f d7       	rcall	.+3614   	; 0x1904 <xTaskResumeAll>
				if( xTaskResumeAll() == pdFALSE )
     ae6:	9d cf       	rjmp	.-198    	; 0xa22 <xQueueGenericReceive+0x84>
     ae8:	c8 01       	movw	r24, r16
     aea:	ef dd       	rcall	.-1058   	; 0x6ca <prvUnlockQueue>
     aec:	0b d7       	rcall	.+3606   	; 0x1904 <xTaskResumeAll>
     aee:	0f b6       	in	r0, 0x3f	; 63
				{
					portYIELD_WITHIN_API();
     af0:	f8 94       	cli
     af2:	0f 92       	push	r0
     af4:	f8 01       	movw	r30, r16
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     af6:	82 8d       	ldd	r24, Z+26	; 0x1a
     af8:	0f 90       	pop	r0
     afa:	0f be       	out	0x3f, r0	; 63
				( void ) xTaskResumeAll();
     afc:	88 23       	and	r24, r24
     afe:	09 f0       	breq	.+2      	; 0xb02 <xQueueGenericReceive+0x164>
     b00:	90 cf       	rjmp	.-224    	; 0xa22 <xQueueGenericReceive+0x84>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b02:	0f 90       	pop	r0
     b04:	0f 90       	pop	r0
     b06:	0f 90       	pop	r0
			( void ) xTaskResumeAll();
     b08:	0f 90       	pop	r0
     b0a:	0f 90       	pop	r0

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b0c:	cf 91       	pop	r28
     b0e:	df 91       	pop	r29
     b10:	1f 91       	pop	r17
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b12:	0f 91       	pop	r16
     b14:	ff 90       	pop	r15
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b16:	ef 90       	pop	r14
     b18:	df 90       	pop	r13
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b1a:	cf 90       	pop	r12
     b1c:	bf 90       	pop	r11
     b1e:	af 90       	pop	r10
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     b20:	9f 90       	pop	r9
     b22:	8f 90       	pop	r8
     b24:	7f 90       	pop	r7
     b26:	6f 90       	pop	r6
     b28:	08 95       	ret
     b2a:	6d ed       	ldi	r22, 0xDD	; 221
     b2c:	74 e0       	ldi	r23, 0x04	; 4
     b2e:	80 e0       	ldi	r24, 0x00	; 0
     b30:	90 e0       	ldi	r25, 0x00	; 0
     b32:	4d e2       	ldi	r20, 0x2D	; 45
     b34:	52 e0       	ldi	r21, 0x02	; 2
     b36:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     b3a:	5b cf       	rjmp	.-330    	; 0x9f2 <xQueueGenericReceive+0x54>
     b3c:	60 ee       	ldi	r22, 0xE0	; 224
     b3e:	74 e0       	ldi	r23, 0x04	; 4
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	4d e2       	ldi	r20, 0x2D	; 45
     b46:	52 e0       	ldi	r21, 0x02	; 2
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     b48:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     b4c:	5a cf       	rjmp	.-332    	; 0xa02 <xQueueGenericReceive+0x64>

00000b4e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     b4e:	6f 92       	push	r6
     b50:	7f 92       	push	r7
     b52:	8f 92       	push	r8
     b54:	9f 92       	push	r9
     b56:	af 92       	push	r10
     b58:	bf 92       	push	r11
     b5a:	cf 92       	push	r12
     b5c:	df 92       	push	r13
     b5e:	ff 92       	push	r15
     b60:	0f 93       	push	r16
     b62:	1f 93       	push	r17
     b64:	df 93       	push	r29
     b66:	cf 93       	push	r28
     b68:	00 d0       	rcall	.+0      	; 0xb6a <xQueueGenericSend+0x1c>
     b6a:	0f 92       	push	r0
     b6c:	0f 92       	push	r0
     b6e:	cd b7       	in	r28, 0x3d	; 61
     b70:	de b7       	in	r29, 0x3e	; 62
     b72:	5b 01       	movw	r10, r22
     b74:	5d 83       	std	Y+5, r21	; 0x05
     b76:	4c 83       	std	Y+4, r20	; 0x04
     b78:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     b7a:	8c 01       	movw	r16, r24

	configASSERT( pxQueue );
     b7c:	00 97       	sbiw	r24, 0x00	; 0
     b7e:	41 f4       	brne	.+16     	; 0xb90 <xQueueGenericSend+0x42>
     b80:	69 ed       	ldi	r22, 0xD9	; 217
     b82:	72 e0       	ldi	r23, 0x02	; 2
     b84:	80 e0       	ldi	r24, 0x00	; 0
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	4d e2       	ldi	r20, 0x2D	; 45
     b8a:	52 e0       	ldi	r21, 0x02	; 2
     b8c:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     b90:	a1 14       	cp	r10, r1
     b92:	b1 04       	cpc	r11, r1
     b94:	29 f4       	brne	.+10     	; 0xba0 <xQueueGenericSend+0x52>
     b96:	f8 01       	movw	r30, r16
     b98:	84 8d       	ldd	r24, Z+28	; 0x1c
     b9a:	88 23       	and	r24, r24
     b9c:	09 f0       	breq	.+2      	; 0xba0 <xQueueGenericSend+0x52>
     b9e:	96 c0       	rjmp	.+300    	; 0xccc <xQueueGenericSend+0x17e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     ba0:	f2 e0       	ldi	r31, 0x02	; 2
     ba2:	ff 16       	cp	r15, r31
     ba4:	29 f4       	brne	.+10     	; 0xbb0 <xQueueGenericSend+0x62>
     ba6:	f8 01       	movw	r30, r16
     ba8:	83 8d       	ldd	r24, Z+27	; 0x1b
     baa:	81 30       	cpi	r24, 0x01	; 1
     bac:	09 f0       	breq	.+2      	; 0xbb0 <xQueueGenericSend+0x62>
     bae:	97 c0       	rjmp	.+302    	; 0xcde <xQueueGenericSend+0x190>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     bb0:	38 d1       	rcall	.+624    	; 0xe22 <xTaskGetSchedulerState>
     bb2:	88 23       	and	r24, r24
     bb4:	29 f4       	brne	.+10     	; 0xbc0 <xQueueGenericSend+0x72>
     bb6:	8c 81       	ldd	r24, Y+4	; 0x04
     bb8:	9d 81       	ldd	r25, Y+5	; 0x05
     bba:	89 2b       	or	r24, r25
     bbc:	09 f0       	breq	.+2      	; 0xbc0 <xQueueGenericSend+0x72>
     bbe:	98 c0       	rjmp	.+304    	; 0xcf0 <xQueueGenericSend+0x1a2>
     bc0:	68 e0       	ldi	r22, 0x08	; 8
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     bc2:	c6 2e       	mov	r12, r22
     bc4:	d1 2c       	mov	r13, r1
     bc6:	c0 0e       	add	r12, r16
     bc8:	d1 1e       	adc	r13, r17
     bca:	20 e0       	ldi	r18, 0x00	; 0
     bcc:	4e 01       	movw	r8, r28
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     bce:	08 94       	sec
     bd0:	81 1c       	adc	r8, r1
     bd2:	91 1c       	adc	r9, r1
     bd4:	54 e0       	ldi	r21, 0x04	; 4

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     bd6:	65 2e       	mov	r6, r21
     bd8:	71 2c       	mov	r7, r1
     bda:	6c 0e       	add	r6, r28
     bdc:	7d 1e       	adc	r7, r29
     bde:	01 c0       	rjmp	.+2      	; 0xbe2 <xQueueGenericSend+0x94>
     be0:	21 e0       	ldi	r18, 0x01	; 1
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     be2:	0f b6       	in	r0, 0x3f	; 63
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     be4:	f8 94       	cli
     be6:	0f 92       	push	r0
     be8:	f8 01       	movw	r30, r16
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     bea:	92 8d       	ldd	r25, Z+26	; 0x1a
     bec:	83 8d       	ldd	r24, Z+27	; 0x1b
     bee:	98 17       	cp	r25, r24
     bf0:	18 f0       	brcs	.+6      	; 0xbf8 <xQueueGenericSend+0xaa>
     bf2:	f2 e0       	ldi	r31, 0x02	; 2
     bf4:	ff 16       	cp	r15, r31
     bf6:	b1 f4       	brne	.+44     	; 0xc24 <xQueueGenericSend+0xd6>
     bf8:	c8 01       	movw	r24, r16
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     bfa:	b5 01       	movw	r22, r10
     bfc:	4f 2d       	mov	r20, r15
     bfe:	be dd       	rcall	.-1156   	; 0x77c <prvCopyDataToQueue>
     c00:	98 2f       	mov	r25, r24
     c02:	f8 01       	movw	r30, r16
     c04:	81 89       	ldd	r24, Z+17	; 0x11
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c06:	88 23       	and	r24, r24
     c08:	31 f0       	breq	.+12     	; 0xc16 <xQueueGenericSend+0xc8>
     c0a:	c8 01       	movw	r24, r16
     c0c:	41 96       	adiw	r24, 0x11	; 17
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c0e:	e5 d2       	rcall	.+1482   	; 0x11da <xTaskRemoveFromEventList>
     c10:	88 23       	and	r24, r24
     c12:	21 f0       	breq	.+8      	; 0xc1c <xQueueGenericSend+0xce>
     c14:	02 c0       	rjmp	.+4      	; 0xc1a <xQueueGenericSend+0xcc>
     c16:	99 23       	and	r25, r25
     c18:	09 f0       	breq	.+2      	; 0xc1c <xQueueGenericSend+0xce>
     c1a:	2c dc       	rcall	.-1960   	; 0x474 <vPortYield>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     c1c:	0f 90       	pop	r0
     c1e:	0f be       	out	0x3f, r0	; 63
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     c20:	81 e0       	ldi	r24, 0x01	; 1
     c22:	41 c0       	rjmp	.+130    	; 0xca6 <xQueueGenericSend+0x158>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     c24:	8c 81       	ldd	r24, Y+4	; 0x04
     c26:	9d 81       	ldd	r25, Y+5	; 0x05
     c28:	89 2b       	or	r24, r25
     c2a:	19 f4       	brne	.+6      	; 0xc32 <xQueueGenericSend+0xe4>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     c2c:	0f 90       	pop	r0
     c2e:	0f be       	out	0x3f, r0	; 63
     c30:	39 c0       	rjmp	.+114    	; 0xca4 <xQueueGenericSend+0x156>
     c32:	22 23       	and	r18, r18
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     c34:	11 f4       	brne	.+4      	; 0xc3a <xQueueGenericSend+0xec>
     c36:	c4 01       	movw	r24, r8
     c38:	17 d1       	rcall	.+558    	; 0xe68 <vTaskSetTimeOutState>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     c3a:	0f 90       	pop	r0
     c3c:	0f be       	out	0x3f, r0	; 63
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     c3e:	dc d0       	rcall	.+440    	; 0xdf8 <vTaskSuspendAll>
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     c44:	0f 92       	push	r0
     c46:	f8 01       	movw	r30, r16

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     c48:	85 8d       	ldd	r24, Z+29	; 0x1d
     c4a:	8f 3f       	cpi	r24, 0xFF	; 255
		prvLockQueue( pxQueue );
     c4c:	09 f4       	brne	.+2      	; 0xc50 <xQueueGenericSend+0x102>
     c4e:	15 8e       	std	Z+29, r1	; 0x1d
     c50:	f8 01       	movw	r30, r16
     c52:	86 8d       	ldd	r24, Z+30	; 0x1e
     c54:	8f 3f       	cpi	r24, 0xFF	; 255
     c56:	09 f4       	brne	.+2      	; 0xc5a <xQueueGenericSend+0x10c>
     c58:	16 8e       	std	Z+30, r1	; 0x1e
     c5a:	0f 90       	pop	r0
     c5c:	0f be       	out	0x3f, r0	; 63
     c5e:	c4 01       	movw	r24, r8
     c60:	b3 01       	movw	r22, r6
     c62:	1b d1       	rcall	.+566    	; 0xe9a <xTaskCheckForTimeOut>
     c64:	88 23       	and	r24, r24
     c66:	d9 f4       	brne	.+54     	; 0xc9e <xQueueGenericSend+0x150>
     c68:	0f b6       	in	r0, 0x3f	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c6a:	f8 94       	cli
     c6c:	0f 92       	push	r0
     c6e:	f8 01       	movw	r30, r16
     c70:	92 8d       	ldd	r25, Z+26	; 0x1a
     c72:	0f 90       	pop	r0
     c74:	0f be       	out	0x3f, r0	; 63

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c76:	f8 01       	movw	r30, r16
     c78:	83 8d       	ldd	r24, Z+27	; 0x1b
     c7a:	98 17       	cp	r25, r24
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     c7c:	61 f4       	brne	.+24     	; 0xc96 <xQueueGenericSend+0x148>
     c7e:	6c 81       	ldd	r22, Y+4	; 0x04
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     c80:	7d 81       	ldd	r23, Y+5	; 0x05
     c82:	c6 01       	movw	r24, r12
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     c84:	3e d5       	rcall	.+2684   	; 0x1702 <vTaskPlaceOnEventList>
     c86:	c8 01       	movw	r24, r16
     c88:	20 dd       	rcall	.-1472   	; 0x6ca <prvUnlockQueue>
     c8a:	3c d6       	rcall	.+3192   	; 0x1904 <xTaskResumeAll>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     c8c:	88 23       	and	r24, r24
     c8e:	09 f0       	breq	.+2      	; 0xc92 <xQueueGenericSend+0x144>
     c90:	a7 cf       	rjmp	.-178    	; 0xbe0 <xQueueGenericSend+0x92>
     c92:	f0 db       	rcall	.-2080   	; 0x474 <vPortYield>
     c94:	a5 cf       	rjmp	.-182    	; 0xbe0 <xQueueGenericSend+0x92>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     c96:	c8 01       	movw	r24, r16
     c98:	18 dd       	rcall	.-1488   	; 0x6ca <prvUnlockQueue>
     c9a:	34 d6       	rcall	.+3176   	; 0x1904 <xTaskResumeAll>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     c9c:	a1 cf       	rjmp	.-190    	; 0xbe0 <xQueueGenericSend+0x92>
     c9e:	c8 01       	movw	r24, r16
     ca0:	14 dd       	rcall	.-1496   	; 0x6ca <prvUnlockQueue>
     ca2:	30 d6       	rcall	.+3168   	; 0x1904 <xTaskResumeAll>
     ca4:	80 e0       	ldi	r24, 0x00	; 0
				{
					portYIELD_WITHIN_API();
     ca6:	0f 90       	pop	r0
     ca8:	0f 90       	pop	r0
     caa:	0f 90       	pop	r0
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     cac:	0f 90       	pop	r0
     cae:	0f 90       	pop	r0
     cb0:	cf 91       	pop	r28
				( void ) xTaskResumeAll();
     cb2:	df 91       	pop	r29
     cb4:	1f 91       	pop	r17
     cb6:	0f 91       	pop	r16
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     cb8:	ff 90       	pop	r15
     cba:	df 90       	pop	r13
     cbc:	cf 90       	pop	r12
			( void ) xTaskResumeAll();
     cbe:	bf 90       	pop	r11
     cc0:	af 90       	pop	r10
     cc2:	9f 90       	pop	r9

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
     cc4:	8f 90       	pop	r8
     cc6:	7f 90       	pop	r7
     cc8:	6f 90       	pop	r6
     cca:	08 95       	ret
     ccc:	6a ed       	ldi	r22, 0xDA	; 218
     cce:	72 e0       	ldi	r23, 0x02	; 2
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	90 e0       	ldi	r25, 0x00	; 0
     cd4:	4d e2       	ldi	r20, 0x2D	; 45
     cd6:	52 e0       	ldi	r21, 0x02	; 2
     cd8:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     cdc:	61 cf       	rjmp	.-318    	; 0xba0 <xQueueGenericSend+0x52>
     cde:	6b ed       	ldi	r22, 0xDB	; 219
     ce0:	72 e0       	ldi	r23, 0x02	; 2
     ce2:	80 e0       	ldi	r24, 0x00	; 0
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	4d e2       	ldi	r20, 0x2D	; 45
     ce8:	52 e0       	ldi	r21, 0x02	; 2
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     cea:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     cee:	60 cf       	rjmp	.-320    	; 0xbb0 <xQueueGenericSend+0x62>
     cf0:	6e ed       	ldi	r22, 0xDE	; 222
     cf2:	72 e0       	ldi	r23, 0x02	; 2
     cf4:	80 e0       	ldi	r24, 0x00	; 0
     cf6:	90 e0       	ldi	r25, 0x00	; 0
     cf8:	4d e2       	ldi	r20, 0x2D	; 45
     cfa:	52 e0       	ldi	r21, 0x02	; 2
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     cfc:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     d00:	5f cf       	rjmp	.-322    	; 0xbc0 <xQueueGenericSend+0x72>

00000d02 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     d02:	1f 93       	push	r17
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	16 2f       	mov	r17, r22
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     d0a:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );
     d0c:	00 97       	sbiw	r24, 0x00	; 0
     d0e:	41 f4       	brne	.+16     	; 0xd20 <xQueueGenericReset+0x1e>
     d10:	6b e1       	ldi	r22, 0x1B	; 27
     d12:	71 e0       	ldi	r23, 0x01	; 1
     d14:	80 e0       	ldi	r24, 0x00	; 0
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	4d e2       	ldi	r20, 0x2D	; 45
     d1a:	52 e0       	ldi	r21, 0x02	; 2
     d1c:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

	taskENTER_CRITICAL();
     d20:	0f b6       	in	r0, 0x3f	; 63
     d22:	f8 94       	cli
     d24:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     d26:	6c 8d       	ldd	r22, Y+28	; 0x1c
     d28:	2b 8d       	ldd	r18, Y+27	; 0x1b
     d2a:	62 9f       	mul	r22, r18
     d2c:	c0 01       	movw	r24, r0
     d2e:	11 24       	eor	r1, r1
     d30:	48 81       	ld	r20, Y
     d32:	59 81       	ldd	r21, Y+1	; 0x01
     d34:	84 0f       	add	r24, r20
     d36:	95 1f       	adc	r25, r21
     d38:	9b 83       	std	Y+3, r25	; 0x03
     d3a:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     d3c:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     d3e:	5d 83       	std	Y+5, r21	; 0x05
     d40:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     d42:	30 e0       	ldi	r19, 0x00	; 0
     d44:	21 50       	subi	r18, 0x01	; 1
     d46:	30 40       	sbci	r19, 0x00	; 0
     d48:	70 e0       	ldi	r23, 0x00	; 0
     d4a:	26 9f       	mul	r18, r22
     d4c:	c0 01       	movw	r24, r0
     d4e:	27 9f       	mul	r18, r23
     d50:	90 0d       	add	r25, r0
     d52:	36 9f       	mul	r19, r22
     d54:	90 0d       	add	r25, r0
     d56:	11 24       	eor	r1, r1
     d58:	48 0f       	add	r20, r24
     d5a:	59 1f       	adc	r21, r25
     d5c:	5f 83       	std	Y+7, r21	; 0x07
     d5e:	4e 83       	std	Y+6, r20	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     d60:	8f ef       	ldi	r24, 0xFF	; 255
     d62:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     d64:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     d66:	11 23       	and	r17, r17
     d68:	51 f4       	brne	.+20     	; 0xd7e <xQueueGenericReset+0x7c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d6a:	88 85       	ldd	r24, Y+8	; 0x08
     d6c:	88 23       	and	r24, r24
     d6e:	69 f0       	breq	.+26     	; 0xd8a <xQueueGenericReset+0x88>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d70:	ce 01       	movw	r24, r28
     d72:	08 96       	adiw	r24, 0x08	; 8
     d74:	32 d2       	rcall	.+1124   	; 0x11da <xTaskRemoveFromEventList>
     d76:	88 23       	and	r24, r24
     d78:	41 f0       	breq	.+16     	; 0xd8a <xQueueGenericReset+0x88>
     d7a:	7c db       	rcall	.-2312   	; 0x474 <vPortYield>
				{
					queueYIELD_IF_USING_PREEMPTION();
     d7c:	06 c0       	rjmp	.+12     	; 0xd8a <xQueueGenericReset+0x88>
     d7e:	ce 01       	movw	r24, r28
     d80:	08 96       	adiw	r24, 0x08	; 8
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     d82:	14 dc       	rcall	.-2008   	; 0x5ac <vListInitialise>
     d84:	ce 01       	movw	r24, r28
     d86:	41 96       	adiw	r24, 0x11	; 17
     d88:	11 dc       	rcall	.-2014   	; 0x5ac <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     d8a:	0f 90       	pop	r0
     d8c:	0f be       	out	0x3f, r0	; 63
     d8e:	81 e0       	ldi	r24, 0x01	; 1
     d90:	df 91       	pop	r29
		}
	}
	taskEXIT_CRITICAL();
     d92:	cf 91       	pop	r28
     d94:	1f 91       	pop	r17

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     d96:	08 95       	ret

00000d98 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     d98:	0f 93       	push	r16
     d9a:	1f 93       	push	r17
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	08 2f       	mov	r16, r24
     da2:	16 2f       	mov	r17, r22
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
     da4:	88 23       	and	r24, r24
     da6:	41 f4       	brne	.+16     	; 0xdb8 <xQueueGenericCreate+0x20>
     da8:	68 e8       	ldi	r22, 0x88	; 136
     daa:	71 e0       	ldi	r23, 0x01	; 1
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	4d e2       	ldi	r20, 0x2D	; 45
     db2:	52 e0       	ldi	r21, 0x02	; 2
     db4:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

		if( uxItemSize == ( UBaseType_t ) 0 )
     db8:	11 23       	and	r17, r17
     dba:	19 f4       	brne	.+6      	; 0xdc2 <xQueueGenericCreate+0x2a>
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	03 c0       	rjmp	.+6      	; 0xdc8 <xQueueGenericCreate+0x30>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     dc2:	10 9f       	mul	r17, r16
     dc4:	c0 01       	movw	r24, r0
     dc6:	11 24       	eor	r1, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     dc8:	4f 96       	adiw	r24, 0x1f	; 31
     dca:	bf db       	rcall	.-2178   	; 0x54a <pvPortMalloc>
     dcc:	ec 01       	movw	r28, r24
     dce:	00 97       	sbiw	r24, 0x00	; 0

		if( pxNewQueue != NULL )
     dd0:	69 f0       	breq	.+26     	; 0xdec <xQueueGenericCreate+0x54>
     dd2:	11 23       	and	r17, r17
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     dd4:	19 f4       	brne	.+6      	; 0xddc <xQueueGenericCreate+0x44>
     dd6:	99 83       	std	Y+1, r25	; 0x01
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     dd8:	88 83       	st	Y, r24
     dda:	03 c0       	rjmp	.+6      	; 0xde2 <xQueueGenericCreate+0x4a>
     ddc:	4f 96       	adiw	r24, 0x1f	; 31
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     dde:	99 83       	std	Y+1, r25	; 0x01
     de0:	88 83       	st	Y, r24
     de2:	0b 8f       	std	Y+27, r16	; 0x1b
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     de4:	1c 8f       	std	Y+28, r17	; 0x1c
	pxNewQueue->uxItemSize = uxItemSize;
     de6:	ce 01       	movw	r24, r28
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     de8:	61 e0       	ldi	r22, 0x01	; 1
     dea:	8b df       	rcall	.-234    	; 0xd02 <xQueueGenericReset>
     dec:	ce 01       	movw	r24, r28
     dee:	df 91       	pop	r29

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
     df0:	cf 91       	pop	r28
     df2:	1f 91       	pop	r17
     df4:	0f 91       	pop	r16
     df6:	08 95       	ret

00000df8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     df8:	80 91 7b 1e 	lds	r24, 0x1E7B
     dfc:	8f 5f       	subi	r24, 0xFF	; 255
     dfe:	80 93 7b 1e 	sts	0x1E7B, r24
}
     e02:	08 95       	ret

00000e04 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     e04:	0f b6       	in	r0, 0x3f	; 63
     e06:	f8 94       	cli
     e08:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     e0a:	20 91 7e 1e 	lds	r18, 0x1E7E
     e0e:	30 91 7f 1e 	lds	r19, 0x1E7F
	}
	portTICK_TYPE_EXIT_CRITICAL();
     e12:	0f 90       	pop	r0
     e14:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     e16:	c9 01       	movw	r24, r18
     e18:	08 95       	ret

00000e1a <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     e1a:	81 e0       	ldi	r24, 0x01	; 1
     e1c:	80 93 7d 1e 	sts	0x1E7D, r24
}
     e20:	08 95       	ret

00000e22 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
     e22:	80 91 82 1e 	lds	r24, 0x1E82
     e26:	88 23       	and	r24, r24
     e28:	11 f4       	brne	.+4      	; 0xe2e <xTaskGetSchedulerState+0xc>
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	08 95       	ret
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e2e:	80 91 7b 1e 	lds	r24, 0x1E7B
     e32:	88 23       	and	r24, r24
     e34:	11 f0       	breq	.+4      	; 0xe3a <xTaskGetSchedulerState+0x18>
     e36:	80 e0       	ldi	r24, 0x00	; 0
     e38:	08 95       	ret
     e3a:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
     e3c:	08 95       	ret

00000e3e <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
     e3e:	00 97       	sbiw	r24, 0x00	; 0
     e40:	29 f4       	brne	.+10     	; 0xe4c <xTaskNotifyStateClear+0xe>
     e42:	e0 91 79 1e 	lds	r30, 0x1E79
     e46:	f0 91 7a 1e 	lds	r31, 0x1E7A
     e4a:	01 c0       	rjmp	.+2      	; 0xe4e <xTaskNotifyStateClear+0x10>
     e4c:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
     e54:	85 a1       	ldd	r24, Z+37	; 0x25
     e56:	82 30       	cpi	r24, 0x02	; 2
     e58:	11 f0       	breq	.+4      	; 0xe5e <xTaskNotifyStateClear+0x20>
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	02 c0       	rjmp	.+4      	; 0xe62 <xTaskNotifyStateClear+0x24>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     e5e:	15 a2       	std	Z+37, r1	; 0x25
     e60:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		taskEXIT_CRITICAL();
     e62:	0f 90       	pop	r0
     e64:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     e66:	08 95       	ret

00000e68 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
     e68:	cf 93       	push	r28
     e6a:	df 93       	push	r29
     e6c:	ec 01       	movw	r28, r24
	configASSERT( pxTimeOut );
     e6e:	00 97       	sbiw	r24, 0x00	; 0
     e70:	41 f4       	brne	.+16     	; 0xe82 <vTaskSetTimeOutState+0x1a>
     e72:	61 ec       	ldi	r22, 0xC1	; 193
     e74:	7b e0       	ldi	r23, 0x0B	; 11
     e76:	80 e0       	ldi	r24, 0x00	; 0
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	48 e4       	ldi	r20, 0x48	; 72
     e7c:	52 e0       	ldi	r21, 0x02	; 2
     e7e:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     e82:	80 91 83 1e 	lds	r24, 0x1E83
     e86:	88 83       	st	Y, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     e88:	80 91 7e 1e 	lds	r24, 0x1E7E
     e8c:	90 91 7f 1e 	lds	r25, 0x1E7F
     e90:	9a 83       	std	Y+2, r25	; 0x02
     e92:	89 83       	std	Y+1, r24	; 0x01
}
     e94:	df 91       	pop	r29
     e96:	cf 91       	pop	r28
     e98:	08 95       	ret

00000e9a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     e9a:	0f 93       	push	r16
     e9c:	1f 93       	push	r17
     e9e:	cf 93       	push	r28
     ea0:	df 93       	push	r29
     ea2:	ec 01       	movw	r28, r24
     ea4:	8b 01       	movw	r16, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
     ea6:	00 97       	sbiw	r24, 0x00	; 0
     ea8:	41 f4       	brne	.+16     	; 0xeba <xTaskCheckForTimeOut+0x20>
     eaa:	6b ec       	ldi	r22, 0xCB	; 203
     eac:	7b e0       	ldi	r23, 0x0B	; 11
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	48 e4       	ldi	r20, 0x48	; 72
     eb4:	52 e0       	ldi	r21, 0x02	; 2
     eb6:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	configASSERT( pxTicksToWait );
     eba:	01 15       	cp	r16, r1
     ebc:	11 05       	cpc	r17, r1
     ebe:	41 f4       	brne	.+16     	; 0xed0 <xTaskCheckForTimeOut+0x36>
     ec0:	6c ec       	ldi	r22, 0xCC	; 204
     ec2:	7b e0       	ldi	r23, 0x0B	; 11
     ec4:	80 e0       	ldi	r24, 0x00	; 0
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	48 e4       	ldi	r20, 0x48	; 72
     eca:	52 e0       	ldi	r21, 0x02	; 2
     ecc:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

	taskENTER_CRITICAL();
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	f8 94       	cli
     ed4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     ed6:	40 91 7e 1e 	lds	r20, 0x1E7E
     eda:	50 91 7f 1e 	lds	r21, 0x1E7F
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     ede:	90 91 83 1e 	lds	r25, 0x1E83
     ee2:	88 81       	ld	r24, Y
     ee4:	98 17       	cp	r25, r24
     ee6:	29 f0       	breq	.+10     	; 0xef2 <xTaskCheckForTimeOut+0x58>
     ee8:	89 81       	ldd	r24, Y+1	; 0x01
     eea:	9a 81       	ldd	r25, Y+2	; 0x02
     eec:	48 17       	cp	r20, r24
     eee:	59 07       	cpc	r21, r25
     ef0:	a8 f4       	brcc	.+42     	; 0xf1c <xTaskCheckForTimeOut+0x82>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     ef2:	29 81       	ldd	r18, Y+1	; 0x01
     ef4:	3a 81       	ldd	r19, Y+2	; 0x02
     ef6:	f8 01       	movw	r30, r16
     ef8:	60 81       	ld	r22, Z
     efa:	71 81       	ldd	r23, Z+1	; 0x01
     efc:	ca 01       	movw	r24, r20
     efe:	82 1b       	sub	r24, r18
     f00:	93 0b       	sbc	r25, r19
     f02:	86 17       	cp	r24, r22
     f04:	97 07       	cpc	r25, r23
     f06:	50 f4       	brcc	.+20     	; 0xf1c <xTaskCheckForTimeOut+0x82>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
     f08:	24 1b       	sub	r18, r20
     f0a:	35 0b       	sbc	r19, r21
     f0c:	26 0f       	add	r18, r22
     f0e:	37 1f       	adc	r19, r23
     f10:	31 83       	std	Z+1, r19	; 0x01
     f12:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
     f14:	ce 01       	movw	r24, r28
     f16:	a8 df       	rcall	.-176    	; 0xe68 <vTaskSetTimeOutState>
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	01 c0       	rjmp	.+2      	; 0xf1e <xTaskCheckForTimeOut+0x84>
     f1c:	81 e0       	ldi	r24, 0x01	; 1
     f1e:	0f 90       	pop	r0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     f20:	0f be       	out	0x3f, r0	; 63
     f22:	df 91       	pop	r29

	return xReturn;
}
     f24:	cf 91       	pop	r28
     f26:	1f 91       	pop	r17
     f28:	0f 91       	pop	r16
     f2a:	08 95       	ret

00000f2c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     f2c:	0f 93       	push	r16
     f2e:	1f 93       	push	r17
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     f30:	80 91 7b 1e 	lds	r24, 0x1E7B
     f34:	88 23       	and	r24, r24
     f36:	21 f0       	breq	.+8      	; 0xf40 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	80 93 7d 1e 	sts	0x1E7D, r24
     f3e:	3b c0       	rjmp	.+118    	; 0xfb6 <vTaskSwitchContext+0x8a>
	}
	else
	{
		xYieldPending = pdFALSE;
     f40:	10 92 7d 1e 	sts	0x1E7D, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     f44:	10 91 7c 1e 	lds	r17, 0x1E7C
     f48:	09 e0       	ldi	r16, 0x09	; 9
     f4a:	0b c0       	rjmp	.+22     	; 0xf62 <vTaskSwitchContext+0x36>
     f4c:	11 23       	and	r17, r17
     f4e:	41 f4       	brne	.+16     	; 0xf60 <vTaskSwitchContext+0x34>
     f50:	66 ef       	ldi	r22, 0xF6	; 246
     f52:	7a e0       	ldi	r23, 0x0A	; 10
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	48 e4       	ldi	r20, 0x48	; 72
     f5a:	52 e0       	ldi	r21, 0x02	; 2
     f5c:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
     f60:	11 50       	subi	r17, 0x01	; 1
     f62:	10 9f       	mul	r17, r16
     f64:	d0 01       	movw	r26, r0
     f66:	11 24       	eor	r1, r1
     f68:	a7 57       	subi	r26, 0x77	; 119
     f6a:	b1 4e       	sbci	r27, 0xE1	; 225
     f6c:	8c 91       	ld	r24, X
     f6e:	88 23       	and	r24, r24
     f70:	69 f3       	breq	.-38     	; 0xf4c <vTaskSwitchContext+0x20>
     f72:	11 96       	adiw	r26, 0x01	; 1
     f74:	ed 91       	ld	r30, X+
     f76:	fc 91       	ld	r31, X
     f78:	12 97       	sbiw	r26, 0x02	; 2
     f7a:	02 80       	ldd	r0, Z+2	; 0x02
     f7c:	f3 81       	ldd	r31, Z+3	; 0x03
     f7e:	e0 2d       	mov	r30, r0
     f80:	12 96       	adiw	r26, 0x02	; 2
     f82:	fc 93       	st	X, r31
     f84:	ee 93       	st	-X, r30
     f86:	11 97       	sbiw	r26, 0x01	; 1
     f88:	cd 01       	movw	r24, r26
     f8a:	03 96       	adiw	r24, 0x03	; 3
     f8c:	e8 17       	cp	r30, r24
     f8e:	f9 07       	cpc	r31, r25
     f90:	31 f4       	brne	.+12     	; 0xf9e <vTaskSwitchContext+0x72>
     f92:	82 81       	ldd	r24, Z+2	; 0x02
     f94:	93 81       	ldd	r25, Z+3	; 0x03
     f96:	12 96       	adiw	r26, 0x02	; 2
     f98:	9c 93       	st	X, r25
     f9a:	8e 93       	st	-X, r24
     f9c:	11 97       	sbiw	r26, 0x01	; 1
     f9e:	11 96       	adiw	r26, 0x01	; 1
     fa0:	ed 91       	ld	r30, X+
     fa2:	fc 91       	ld	r31, X
     fa4:	12 97       	sbiw	r26, 0x02	; 2
     fa6:	86 81       	ldd	r24, Z+6	; 0x06
     fa8:	97 81       	ldd	r25, Z+7	; 0x07
     faa:	90 93 7a 1e 	sts	0x1E7A, r25
     fae:	80 93 79 1e 	sts	0x1E79, r24
     fb2:	10 93 7c 1e 	sts	0x1E7C, r17
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
     fb6:	1f 91       	pop	r17
     fb8:	0f 91       	pop	r16
     fba:	08 95       	ret

00000fbc <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
     fbc:	ef 92       	push	r14
     fbe:	ff 92       	push	r15
     fc0:	0f 93       	push	r16
     fc2:	1f 93       	push	r17
     fc4:	cf 93       	push	r28
     fc6:	df 93       	push	r29
     fc8:	ec 01       	movw	r28, r24
     fca:	7b 01       	movw	r14, r22
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
     fcc:	00 97       	sbiw	r24, 0x00	; 0
     fce:	41 f4       	brne	.+16     	; 0xfe0 <vTaskNotifyGiveFromISR+0x24>
     fd0:	63 ee       	ldi	r22, 0xE3	; 227
     fd2:	71 e1       	ldi	r23, 0x11	; 17
     fd4:	80 e0       	ldi	r24, 0x00	; 0
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	48 e4       	ldi	r20, 0x48	; 72
     fda:	52 e0       	ldi	r21, 0x02	; 2
     fdc:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
     fe0:	2d a1       	ldd	r18, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     fe2:	82 e0       	ldi	r24, 0x02	; 2
     fe4:	8d a3       	std	Y+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
     fe6:	89 a1       	ldd	r24, Y+33	; 0x21
     fe8:	9a a1       	ldd	r25, Y+34	; 0x22
     fea:	ab a1       	ldd	r26, Y+35	; 0x23
     fec:	bc a1       	ldd	r27, Y+36	; 0x24
     fee:	01 96       	adiw	r24, 0x01	; 1
     ff0:	a1 1d       	adc	r26, r1
     ff2:	b1 1d       	adc	r27, r1
     ff4:	89 a3       	std	Y+33, r24	; 0x21
     ff6:	9a a3       	std	Y+34, r25	; 0x22
     ff8:	ab a3       	std	Y+35, r26	; 0x23
     ffa:	bc a3       	std	Y+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     ffc:	21 30       	cpi	r18, 0x01	; 1
     ffe:	e1 f5       	brne	.+120    	; 0x1078 <vTaskNotifyGiveFromISR+0xbc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    1000:	8c 89       	ldd	r24, Y+20	; 0x14
    1002:	9d 89       	ldd	r25, Y+21	; 0x15
    1004:	89 2b       	or	r24, r25
    1006:	41 f0       	breq	.+16     	; 0x1018 <vTaskNotifyGiveFromISR+0x5c>
    1008:	69 e0       	ldi	r22, 0x09	; 9
    100a:	72 e1       	ldi	r23, 0x12	; 18
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	48 e4       	ldi	r20, 0x48	; 72
    1012:	52 e0       	ldi	r21, 0x02	; 2
    1014:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1018:	80 91 7b 1e 	lds	r24, 0x1E7B
    101c:	88 23       	and	r24, r24
    101e:	a1 f4       	brne	.+40     	; 0x1048 <vTaskNotifyGiveFromISR+0x8c>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1020:	8e 01       	movw	r16, r28
    1022:	0e 5f       	subi	r16, 0xFE	; 254
    1024:	1f 4f       	sbci	r17, 0xFF	; 255
    1026:	c8 01       	movw	r24, r16
    1028:	26 db       	rcall	.-2484   	; 0x676 <uxListRemove>
    102a:	9e 89       	ldd	r25, Y+22	; 0x16
					prvAddTaskToReadyList( pxTCB );
    102c:	80 91 7c 1e 	lds	r24, 0x1E7C
    1030:	89 17       	cp	r24, r25
    1032:	10 f4       	brcc	.+4      	; 0x1038 <vTaskNotifyGiveFromISR+0x7c>
    1034:	90 93 7c 1e 	sts	0x1E7C, r25
    1038:	89 e0       	ldi	r24, 0x09	; 9
    103a:	98 9f       	mul	r25, r24
    103c:	c0 01       	movw	r24, r0
    103e:	11 24       	eor	r1, r1
    1040:	87 57       	subi	r24, 0x77	; 119
    1042:	91 4e       	sbci	r25, 0xE1	; 225
    1044:	b8 01       	movw	r22, r16
    1046:	05 c0       	rjmp	.+10     	; 0x1052 <vTaskNotifyGiveFromISR+0x96>
    1048:	be 01       	movw	r22, r28
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    104a:	64 5f       	subi	r22, 0xF4	; 244
    104c:	7f 4f       	sbci	r23, 0xFF	; 255
    104e:	83 ec       	ldi	r24, 0xC3	; 195
    1050:	9e e1       	ldi	r25, 0x1E	; 30
    1052:	c0 da       	rcall	.-2688   	; 0x5d4 <vListInsertEnd>
    1054:	e0 91 79 1e 	lds	r30, 0x1E79
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1058:	f0 91 7a 1e 	lds	r31, 0x1E7A
    105c:	9e 89       	ldd	r25, Y+22	; 0x16
    105e:	86 89       	ldd	r24, Z+22	; 0x16
    1060:	89 17       	cp	r24, r25
    1062:	50 f4       	brcc	.+20     	; 0x1078 <vTaskNotifyGiveFromISR+0xbc>
    1064:	e1 14       	cp	r14, r1
    1066:	f1 04       	cpc	r15, r1
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1068:	21 f0       	breq	.+8      	; 0x1072 <vTaskNotifyGiveFromISR+0xb6>
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	f7 01       	movw	r30, r14
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    106e:	80 83       	st	Z, r24
    1070:	03 c0       	rjmp	.+6      	; 0x1078 <vTaskNotifyGiveFromISR+0xbc>
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	80 93 7d 1e 	sts	0x1E7D, r24
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    1078:	df 91       	pop	r29
    107a:	cf 91       	pop	r28
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    107c:	1f 91       	pop	r17
    107e:	0f 91       	pop	r16
    1080:	ff 90       	pop	r15
    1082:	ef 90       	pop	r14
    1084:	08 95       	ret

00001086 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1086:	8f 92       	push	r8
    1088:	9f 92       	push	r9
    108a:	af 92       	push	r10
    108c:	bf 92       	push	r11
    108e:	cf 92       	push	r12
    1090:	df 92       	push	r13
    1092:	ef 92       	push	r14
    1094:	ff 92       	push	r15
    1096:	0f 93       	push	r16
    1098:	1f 93       	push	r17
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	ec 01       	movw	r28, r24
    10a0:	4a 01       	movw	r8, r20
    10a2:	5b 01       	movw	r10, r22
    10a4:	69 01       	movw	r12, r18
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
    10a6:	00 97       	sbiw	r24, 0x00	; 0
    10a8:	41 f4       	brne	.+16     	; 0x10ba <xTaskGenericNotifyFromISR+0x34>
    10aa:	68 e6       	ldi	r22, 0x68	; 104
    10ac:	71 e1       	ldi	r23, 0x11	; 17
    10ae:	80 e0       	ldi	r24, 0x00	; 0
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	48 e4       	ldi	r20, 0x48	; 72
    10b4:	52 e0       	ldi	r21, 0x02	; 2
    10b6:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    10ba:	01 15       	cp	r16, r1
    10bc:	11 05       	cpc	r17, r1
    10be:	49 f0       	breq	.+18     	; 0x10d2 <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    10c0:	89 a1       	ldd	r24, Y+33	; 0x21
    10c2:	9a a1       	ldd	r25, Y+34	; 0x22
    10c4:	ab a1       	ldd	r26, Y+35	; 0x23
    10c6:	bc a1       	ldd	r27, Y+36	; 0x24
    10c8:	f8 01       	movw	r30, r16
    10ca:	80 83       	st	Z, r24
    10cc:	91 83       	std	Z+1, r25	; 0x01
    10ce:	a2 83       	std	Z+2, r26	; 0x02
    10d0:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    10d2:	2d a1       	ldd	r18, Y+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    10d4:	82 e0       	ldi	r24, 0x02	; 2
    10d6:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
    10d8:	f2 e0       	ldi	r31, 0x02	; 2
    10da:	cf 16       	cp	r12, r31
    10dc:	d1 04       	cpc	r13, r1
    10de:	d9 f0       	breq	.+54     	; 0x1116 <xTaskGenericNotifyFromISR+0x90>
    10e0:	83 e0       	ldi	r24, 0x03	; 3
    10e2:	c8 16       	cp	r12, r24
    10e4:	d1 04       	cpc	r13, r1
    10e6:	28 f4       	brcc	.+10     	; 0x10f2 <xTaskGenericNotifyFromISR+0x6c>
    10e8:	e1 e0       	ldi	r30, 0x01	; 1
    10ea:	ce 16       	cp	r12, r30
    10ec:	d1 04       	cpc	r13, r1
    10ee:	39 f5       	brne	.+78     	; 0x113e <xTaskGenericNotifyFromISR+0xb8>
    10f0:	09 c0       	rjmp	.+18     	; 0x1104 <xTaskGenericNotifyFromISR+0x7e>
    10f2:	f3 e0       	ldi	r31, 0x03	; 3
    10f4:	cf 16       	cp	r12, r31
    10f6:	d1 04       	cpc	r13, r1
    10f8:	f1 f0       	breq	.+60     	; 0x1136 <xTaskGenericNotifyFromISR+0xb0>
    10fa:	84 e0       	ldi	r24, 0x04	; 4
    10fc:	c8 16       	cp	r12, r24
    10fe:	d1 04       	cpc	r13, r1
    1100:	f1 f4       	brne	.+60     	; 0x113e <xTaskGenericNotifyFromISR+0xb8>
    1102:	15 c0       	rjmp	.+42     	; 0x112e <xTaskGenericNotifyFromISR+0xa8>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1104:	89 a1       	ldd	r24, Y+33	; 0x21
    1106:	9a a1       	ldd	r25, Y+34	; 0x22
    1108:	ab a1       	ldd	r26, Y+35	; 0x23
    110a:	bc a1       	ldd	r27, Y+36	; 0x24
    110c:	88 29       	or	r24, r8
    110e:	99 29       	or	r25, r9
    1110:	aa 29       	or	r26, r10
    1112:	bb 29       	or	r27, r11
    1114:	07 c0       	rjmp	.+14     	; 0x1124 <xTaskGenericNotifyFromISR+0x9e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1116:	89 a1       	ldd	r24, Y+33	; 0x21
    1118:	9a a1       	ldd	r25, Y+34	; 0x22
    111a:	ab a1       	ldd	r26, Y+35	; 0x23
    111c:	bc a1       	ldd	r27, Y+36	; 0x24
    111e:	01 96       	adiw	r24, 0x01	; 1
    1120:	a1 1d       	adc	r26, r1
    1122:	b1 1d       	adc	r27, r1
    1124:	89 a3       	std	Y+33, r24	; 0x21
    1126:	9a a3       	std	Y+34, r25	; 0x22
    1128:	ab a3       	std	Y+35, r26	; 0x23
    112a:	bc a3       	std	Y+36, r27	; 0x24
    112c:	08 c0       	rjmp	.+16     	; 0x113e <xTaskGenericNotifyFromISR+0xb8>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    112e:	22 30       	cpi	r18, 0x02	; 2
    1130:	11 f4       	brne	.+4      	; 0x1136 <xTaskGenericNotifyFromISR+0xb0>
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	45 c0       	rjmp	.+138    	; 0x11c0 <xTaskGenericNotifyFromISR+0x13a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1136:	89 a2       	std	Y+33, r8	; 0x21
    1138:	9a a2       	std	Y+34, r9	; 0x22
    113a:	ab a2       	std	Y+35, r10	; 0x23
    113c:	bc a2       	std	Y+36, r11	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    113e:	21 30       	cpi	r18, 0x01	; 1
    1140:	09 f0       	breq	.+2      	; 0x1144 <xTaskGenericNotifyFromISR+0xbe>
    1142:	3d c0       	rjmp	.+122    	; 0x11be <xTaskGenericNotifyFromISR+0x138>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    1144:	8c 89       	ldd	r24, Y+20	; 0x14
    1146:	9d 89       	ldd	r25, Y+21	; 0x15
    1148:	89 2b       	or	r24, r25
    114a:	41 f0       	breq	.+16     	; 0x115c <xTaskGenericNotifyFromISR+0xd6>
    114c:	6f ea       	ldi	r22, 0xAF	; 175
    114e:	71 e1       	ldi	r23, 0x11	; 17
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	48 e4       	ldi	r20, 0x48	; 72
    1156:	52 e0       	ldi	r21, 0x02	; 2
    1158:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    115c:	80 91 7b 1e 	lds	r24, 0x1E7B
    1160:	88 23       	and	r24, r24
    1162:	a1 f4       	brne	.+40     	; 0x118c <xTaskGenericNotifyFromISR+0x106>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1164:	8e 01       	movw	r16, r28
    1166:	0e 5f       	subi	r16, 0xFE	; 254
    1168:	1f 4f       	sbci	r17, 0xFF	; 255
    116a:	c8 01       	movw	r24, r16
    116c:	84 da       	rcall	.-2808   	; 0x676 <uxListRemove>
    116e:	9e 89       	ldd	r25, Y+22	; 0x16
					prvAddTaskToReadyList( pxTCB );
    1170:	80 91 7c 1e 	lds	r24, 0x1E7C
    1174:	89 17       	cp	r24, r25
    1176:	10 f4       	brcc	.+4      	; 0x117c <xTaskGenericNotifyFromISR+0xf6>
    1178:	90 93 7c 1e 	sts	0x1E7C, r25
    117c:	89 e0       	ldi	r24, 0x09	; 9
    117e:	98 9f       	mul	r25, r24
    1180:	c0 01       	movw	r24, r0
    1182:	11 24       	eor	r1, r1
    1184:	87 57       	subi	r24, 0x77	; 119
    1186:	91 4e       	sbci	r25, 0xE1	; 225
    1188:	b8 01       	movw	r22, r16
    118a:	05 c0       	rjmp	.+10     	; 0x1196 <xTaskGenericNotifyFromISR+0x110>
    118c:	be 01       	movw	r22, r28
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    118e:	64 5f       	subi	r22, 0xF4	; 244
    1190:	7f 4f       	sbci	r23, 0xFF	; 255
    1192:	83 ec       	ldi	r24, 0xC3	; 195
    1194:	9e e1       	ldi	r25, 0x1E	; 30
    1196:	1e da       	rcall	.-3012   	; 0x5d4 <vListInsertEnd>
    1198:	e0 91 79 1e 	lds	r30, 0x1E79
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    119c:	f0 91 7a 1e 	lds	r31, 0x1E7A
    11a0:	9e 89       	ldd	r25, Y+22	; 0x16
    11a2:	86 89       	ldd	r24, Z+22	; 0x16
    11a4:	89 17       	cp	r24, r25
    11a6:	58 f4       	brcc	.+22     	; 0x11be <xTaskGenericNotifyFromISR+0x138>
    11a8:	e1 14       	cp	r14, r1
    11aa:	f1 04       	cpc	r15, r1
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    11ac:	21 f0       	breq	.+8      	; 0x11b6 <xTaskGenericNotifyFromISR+0x130>
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	f7 01       	movw	r30, r14
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    11b2:	80 83       	st	Z, r24
    11b4:	05 c0       	rjmp	.+10     	; 0x11c0 <xTaskGenericNotifyFromISR+0x13a>
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	80 93 7d 1e 	sts	0x1E7D, r24
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    11bc:	01 c0       	rjmp	.+2      	; 0x11c0 <xTaskGenericNotifyFromISR+0x13a>
    11be:	81 e0       	ldi	r24, 0x01	; 1
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    11c4:	1f 91       	pop	r17
    11c6:	0f 91       	pop	r16
    11c8:	ff 90       	pop	r15
    11ca:	ef 90       	pop	r14
    11cc:	df 90       	pop	r13
    11ce:	cf 90       	pop	r12
    11d0:	bf 90       	pop	r11
    11d2:	af 90       	pop	r10
    11d4:	9f 90       	pop	r9
    11d6:	8f 90       	pop	r8
    11d8:	08 95       	ret

000011da <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    11da:	0f 93       	push	r16
    11dc:	1f 93       	push	r17
    11de:	cf 93       	push	r28
    11e0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    11e2:	dc 01       	movw	r26, r24
    11e4:	15 96       	adiw	r26, 0x05	; 5
    11e6:	ed 91       	ld	r30, X+
    11e8:	fc 91       	ld	r31, X
    11ea:	16 97       	sbiw	r26, 0x06	; 6
    11ec:	c6 81       	ldd	r28, Z+6	; 0x06
    11ee:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
    11f0:	20 97       	sbiw	r28, 0x00	; 0
    11f2:	41 f4       	brne	.+16     	; 0x1204 <xTaskRemoveFromEventList+0x2a>
    11f4:	61 e6       	ldi	r22, 0x61	; 97
    11f6:	7b e0       	ldi	r23, 0x0B	; 11
    11f8:	80 e0       	ldi	r24, 0x00	; 0
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	48 e4       	ldi	r20, 0x48	; 72
    11fe:	52 e0       	ldi	r21, 0x02	; 2
    1200:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1204:	8e 01       	movw	r16, r28
    1206:	04 5f       	subi	r16, 0xF4	; 244
    1208:	1f 4f       	sbci	r17, 0xFF	; 255
    120a:	c8 01       	movw	r24, r16
    120c:	34 da       	rcall	.-2968   	; 0x676 <uxListRemove>
    120e:	80 91 7b 1e 	lds	r24, 0x1E7B

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1212:	88 23       	and	r24, r24
    1214:	99 f4       	brne	.+38     	; 0x123c <xTaskRemoveFromEventList+0x62>
    1216:	8e 01       	movw	r16, r28
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1218:	0e 5f       	subi	r16, 0xFE	; 254
    121a:	1f 4f       	sbci	r17, 0xFF	; 255
    121c:	c8 01       	movw	r24, r16
    121e:	2b da       	rcall	.-2986   	; 0x676 <uxListRemove>
    1220:	9e 89       	ldd	r25, Y+22	; 0x16
    1222:	80 91 7c 1e 	lds	r24, 0x1E7C
		prvAddTaskToReadyList( pxUnblockedTCB );
    1226:	89 17       	cp	r24, r25
    1228:	10 f4       	brcc	.+4      	; 0x122e <xTaskRemoveFromEventList+0x54>
    122a:	90 93 7c 1e 	sts	0x1E7C, r25
    122e:	89 e0       	ldi	r24, 0x09	; 9
    1230:	98 9f       	mul	r25, r24
    1232:	c0 01       	movw	r24, r0
    1234:	11 24       	eor	r1, r1
    1236:	87 57       	subi	r24, 0x77	; 119
    1238:	91 4e       	sbci	r25, 0xE1	; 225
    123a:	02 c0       	rjmp	.+4      	; 0x1240 <xTaskRemoveFromEventList+0x66>
    123c:	83 ec       	ldi	r24, 0xC3	; 195
    123e:	9e e1       	ldi	r25, 0x1E	; 30
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1240:	b8 01       	movw	r22, r16
    1242:	c8 d9       	rcall	.-3184   	; 0x5d4 <vListInsertEnd>
    1244:	e0 91 79 1e 	lds	r30, 0x1E79
    1248:	f0 91 7a 1e 	lds	r31, 0x1E7A
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    124c:	9e 89       	ldd	r25, Y+22	; 0x16
    124e:	86 89       	ldd	r24, Z+22	; 0x16
    1250:	89 17       	cp	r24, r25
    1252:	10 f0       	brcs	.+4      	; 0x1258 <xTaskRemoveFromEventList+0x7e>
    1254:	80 e0       	ldi	r24, 0x00	; 0
    1256:	03 c0       	rjmp	.+6      	; 0x125e <xTaskRemoveFromEventList+0x84>
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	80 93 7d 1e 	sts	0x1E7D, r24
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    125e:	df 91       	pop	r29
    1260:	cf 91       	pop	r28
    1262:	1f 91       	pop	r17
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1264:	0f 91       	pop	r16
    1266:	08 95       	ret

00001268 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1268:	af 92       	push	r10
    126a:	bf 92       	push	r11
    126c:	cf 92       	push	r12
    126e:	df 92       	push	r13
    1270:	ef 92       	push	r14
    1272:	ff 92       	push	r15
    1274:	0f 93       	push	r16
    1276:	1f 93       	push	r17
    1278:	cf 93       	push	r28
    127a:	df 93       	push	r29
    127c:	ec 01       	movw	r28, r24
    127e:	5a 01       	movw	r10, r20
    1280:	6b 01       	movw	r12, r22
    1282:	79 01       	movw	r14, r18
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
    1284:	00 97       	sbiw	r24, 0x00	; 0
    1286:	41 f4       	brne	.+16     	; 0x1298 <xTaskGenericNotify+0x30>
    1288:	6d ef       	ldi	r22, 0xFD	; 253
    128a:	70 e1       	ldi	r23, 0x10	; 16
    128c:	80 e0       	ldi	r24, 0x00	; 0
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	48 e4       	ldi	r20, 0x48	; 72
    1292:	52 e0       	ldi	r21, 0x02	; 2
    1294:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    129e:	01 15       	cp	r16, r1
    12a0:	11 05       	cpc	r17, r1
    12a2:	49 f0       	breq	.+18     	; 0x12b6 <xTaskGenericNotify+0x4e>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    12a4:	89 a1       	ldd	r24, Y+33	; 0x21
    12a6:	9a a1       	ldd	r25, Y+34	; 0x22
    12a8:	ab a1       	ldd	r26, Y+35	; 0x23
    12aa:	bc a1       	ldd	r27, Y+36	; 0x24
    12ac:	f8 01       	movw	r30, r16
    12ae:	80 83       	st	Z, r24
    12b0:	91 83       	std	Z+1, r25	; 0x01
    12b2:	a2 83       	std	Z+2, r26	; 0x02
    12b4:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    12b6:	2d a1       	ldd	r18, Y+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    12b8:	82 e0       	ldi	r24, 0x02	; 2
    12ba:	8d a3       	std	Y+37, r24	; 0x25

			switch( eAction )
    12bc:	f2 e0       	ldi	r31, 0x02	; 2
    12be:	ef 16       	cp	r14, r31
    12c0:	f1 04       	cpc	r15, r1
    12c2:	d9 f0       	breq	.+54     	; 0x12fa <xTaskGenericNotify+0x92>
    12c4:	83 e0       	ldi	r24, 0x03	; 3
    12c6:	e8 16       	cp	r14, r24
    12c8:	f1 04       	cpc	r15, r1
    12ca:	28 f4       	brcc	.+10     	; 0x12d6 <xTaskGenericNotify+0x6e>
    12cc:	e1 e0       	ldi	r30, 0x01	; 1
    12ce:	ee 16       	cp	r14, r30
    12d0:	f1 04       	cpc	r15, r1
    12d2:	39 f5       	brne	.+78     	; 0x1322 <xTaskGenericNotify+0xba>
    12d4:	09 c0       	rjmp	.+18     	; 0x12e8 <xTaskGenericNotify+0x80>
    12d6:	f3 e0       	ldi	r31, 0x03	; 3
    12d8:	ef 16       	cp	r14, r31
    12da:	f1 04       	cpc	r15, r1
    12dc:	f1 f0       	breq	.+60     	; 0x131a <xTaskGenericNotify+0xb2>
    12de:	84 e0       	ldi	r24, 0x04	; 4
    12e0:	e8 16       	cp	r14, r24
    12e2:	f1 04       	cpc	r15, r1
    12e4:	f1 f4       	brne	.+60     	; 0x1322 <xTaskGenericNotify+0xba>
    12e6:	15 c0       	rjmp	.+42     	; 0x1312 <xTaskGenericNotify+0xaa>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    12e8:	89 a1       	ldd	r24, Y+33	; 0x21
    12ea:	9a a1       	ldd	r25, Y+34	; 0x22
    12ec:	ab a1       	ldd	r26, Y+35	; 0x23
    12ee:	bc a1       	ldd	r27, Y+36	; 0x24
    12f0:	8a 29       	or	r24, r10
    12f2:	9b 29       	or	r25, r11
    12f4:	ac 29       	or	r26, r12
    12f6:	bd 29       	or	r27, r13
    12f8:	07 c0       	rjmp	.+14     	; 0x1308 <xTaskGenericNotify+0xa0>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    12fa:	89 a1       	ldd	r24, Y+33	; 0x21
    12fc:	9a a1       	ldd	r25, Y+34	; 0x22
    12fe:	ab a1       	ldd	r26, Y+35	; 0x23
    1300:	bc a1       	ldd	r27, Y+36	; 0x24
    1302:	01 96       	adiw	r24, 0x01	; 1
    1304:	a1 1d       	adc	r26, r1
    1306:	b1 1d       	adc	r27, r1
    1308:	89 a3       	std	Y+33, r24	; 0x21
    130a:	9a a3       	std	Y+34, r25	; 0x22
    130c:	ab a3       	std	Y+35, r26	; 0x23
    130e:	bc a3       	std	Y+36, r27	; 0x24
    1310:	08 c0       	rjmp	.+16     	; 0x1322 <xTaskGenericNotify+0xba>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1312:	22 30       	cpi	r18, 0x02	; 2
    1314:	11 f4       	brne	.+4      	; 0x131a <xTaskGenericNotify+0xb2>
    1316:	80 e0       	ldi	r24, 0x00	; 0
    1318:	30 c0       	rjmp	.+96     	; 0x137a <xTaskGenericNotify+0x112>
					{
						pxTCB->ulNotifiedValue = ulValue;
    131a:	a9 a2       	std	Y+33, r10	; 0x21
    131c:	ba a2       	std	Y+34, r11	; 0x22
    131e:	cb a2       	std	Y+35, r12	; 0x23
    1320:	dc a2       	std	Y+36, r13	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1322:	21 30       	cpi	r18, 0x01	; 1
    1324:	49 f5       	brne	.+82     	; 0x1378 <xTaskGenericNotify+0x110>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1326:	8e 01       	movw	r16, r28
    1328:	0e 5f       	subi	r16, 0xFE	; 254
    132a:	1f 4f       	sbci	r17, 0xFF	; 255
    132c:	c8 01       	movw	r24, r16
    132e:	a3 d9       	rcall	.-3258   	; 0x676 <uxListRemove>
    1330:	9e 89       	ldd	r25, Y+22	; 0x16
				prvAddTaskToReadyList( pxTCB );
    1332:	80 91 7c 1e 	lds	r24, 0x1E7C
    1336:	89 17       	cp	r24, r25
    1338:	10 f4       	brcc	.+4      	; 0x133e <xTaskGenericNotify+0xd6>
    133a:	90 93 7c 1e 	sts	0x1E7C, r25
    133e:	89 e0       	ldi	r24, 0x09	; 9
    1340:	98 9f       	mul	r25, r24
    1342:	c0 01       	movw	r24, r0
    1344:	11 24       	eor	r1, r1
    1346:	87 57       	subi	r24, 0x77	; 119
    1348:	91 4e       	sbci	r25, 0xE1	; 225
    134a:	b8 01       	movw	r22, r16
    134c:	43 d9       	rcall	.-3450   	; 0x5d4 <vListInsertEnd>
    134e:	8c 89       	ldd	r24, Y+20	; 0x14
    1350:	9d 89       	ldd	r25, Y+21	; 0x15

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    1352:	89 2b       	or	r24, r25
    1354:	41 f0       	breq	.+16     	; 0x1366 <xTaskGenericNotify+0xfe>
    1356:	65 e3       	ldi	r22, 0x35	; 53
    1358:	71 e1       	ldi	r23, 0x11	; 17
    135a:	80 e0       	ldi	r24, 0x00	; 0
    135c:	90 e0       	ldi	r25, 0x00	; 0
    135e:	48 e4       	ldi	r20, 0x48	; 72
    1360:	52 e0       	ldi	r21, 0x02	; 2
    1362:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
    1366:	e0 91 79 1e 	lds	r30, 0x1E79
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    136a:	f0 91 7a 1e 	lds	r31, 0x1E7A
    136e:	9e 89       	ldd	r25, Y+22	; 0x16
    1370:	86 89       	ldd	r24, Z+22	; 0x16
    1372:	89 17       	cp	r24, r25
    1374:	08 f4       	brcc	.+2      	; 0x1378 <xTaskGenericNotify+0x110>
    1376:	7e d8       	rcall	.-3844   	; 0x474 <vPortYield>
    1378:	81 e0       	ldi	r24, 0x01	; 1
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    137a:	0f 90       	pop	r0
    137c:	0f be       	out	0x3f, r0	; 63
    137e:	df 91       	pop	r29
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1380:	cf 91       	pop	r28
    1382:	1f 91       	pop	r17

		return xReturn;
	}
    1384:	0f 91       	pop	r16
    1386:	ff 90       	pop	r15
    1388:	ef 90       	pop	r14
    138a:	df 90       	pop	r13
    138c:	cf 90       	pop	r12
    138e:	bf 90       	pop	r11
    1390:	af 90       	pop	r10
    1392:	08 95       	ret

00001394 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1394:	ff 92       	push	r15
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
    13a0:	64 30       	cpi	r22, 0x04	; 4
    13a2:	48 f0       	brcs	.+18     	; 0x13b6 <vTaskPrioritySet+0x22>
    13a4:	60 e8       	ldi	r22, 0x80	; 128
    13a6:	75 e0       	ldi	r23, 0x05	; 5
    13a8:	80 e0       	ldi	r24, 0x00	; 0
    13aa:	90 e0       	ldi	r25, 0x00	; 0
    13ac:	48 e4       	ldi	r20, 0x48	; 72
    13ae:	52 e0       	ldi	r21, 0x02	; 2
    13b0:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
    13b4:	63 e0       	ldi	r22, 0x03	; 3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    13b6:	0f b6       	in	r0, 0x3f	; 63
    13b8:	f8 94       	cli
    13ba:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    13bc:	20 97       	sbiw	r28, 0x00	; 0
    13be:	21 f4       	brne	.+8      	; 0x13c8 <vTaskPrioritySet+0x34>
    13c0:	c0 91 79 1e 	lds	r28, 0x1E79
    13c4:	d0 91 7a 1e 	lds	r29, 0x1E7A
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    13c8:	2e 89       	ldd	r18, Y+22	; 0x16
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    13ca:	26 17       	cp	r18, r22
    13cc:	09 f4       	brne	.+2      	; 0x13d0 <vTaskPrioritySet+0x3c>
    13ce:	4b c0       	rjmp	.+150    	; 0x1466 <vTaskPrioritySet+0xd2>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    13d0:	26 17       	cp	r18, r22
    13d2:	90 f4       	brcc	.+36     	; 0x13f8 <vTaskPrioritySet+0x64>
				{
					if( pxTCB != pxCurrentTCB )
    13d4:	80 91 79 1e 	lds	r24, 0x1E79
    13d8:	90 91 7a 1e 	lds	r25, 0x1E7A
    13dc:	c8 17       	cp	r28, r24
    13de:	d9 07       	cpc	r29, r25
    13e0:	11 f4       	brne	.+4      	; 0x13e6 <vTaskPrioritySet+0x52>
    13e2:	ff 24       	eor	r15, r15
    13e4:	13 c0       	rjmp	.+38     	; 0x140c <vTaskPrioritySet+0x78>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    13e6:	e0 91 79 1e 	lds	r30, 0x1E79
    13ea:	f0 91 7a 1e 	lds	r31, 0x1E7A
    13ee:	ff 24       	eor	r15, r15
    13f0:	86 89       	ldd	r24, Z+22	; 0x16
    13f2:	68 17       	cp	r22, r24
    13f4:	58 f0       	brcs	.+22     	; 0x140c <vTaskPrioritySet+0x78>
    13f6:	08 c0       	rjmp	.+16     	; 0x1408 <vTaskPrioritySet+0x74>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    13f8:	80 91 79 1e 	lds	r24, 0x1E79
    13fc:	90 91 7a 1e 	lds	r25, 0x1E7A
    1400:	ff 24       	eor	r15, r15
    1402:	c8 17       	cp	r28, r24
    1404:	d9 07       	cpc	r29, r25
    1406:	11 f4       	brne	.+4      	; 0x140c <vTaskPrioritySet+0x78>
    1408:	ff 24       	eor	r15, r15
    140a:	f3 94       	inc	r15
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    140c:	6e 8b       	std	Y+22, r22	; 0x16
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    140e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1410:	9d 85       	ldd	r25, Y+13	; 0x0d
    1412:	97 fd       	sbrc	r25, 7
    1414:	06 c0       	rjmp	.+12     	; 0x1422 <vTaskPrioritySet+0x8e>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1416:	84 e0       	ldi	r24, 0x04	; 4
    1418:	90 e0       	ldi	r25, 0x00	; 0
    141a:	86 1b       	sub	r24, r22
    141c:	91 09       	sbc	r25, r1
    141e:	9d 87       	std	Y+13, r25	; 0x0d
    1420:	8c 87       	std	Y+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1422:	89 e0       	ldi	r24, 0x09	; 9
    1424:	28 9f       	mul	r18, r24
    1426:	c0 01       	movw	r24, r0
    1428:	11 24       	eor	r1, r1
    142a:	87 57       	subi	r24, 0x77	; 119
    142c:	91 4e       	sbci	r25, 0xE1	; 225
    142e:	2a 85       	ldd	r18, Y+10	; 0x0a
    1430:	3b 85       	ldd	r19, Y+11	; 0x0b
    1432:	28 17       	cp	r18, r24
    1434:	39 07       	cpc	r19, r25
    1436:	a1 f4       	brne	.+40     	; 0x1460 <vTaskPrioritySet+0xcc>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1438:	8e 01       	movw	r16, r28
    143a:	0e 5f       	subi	r16, 0xFE	; 254
    143c:	1f 4f       	sbci	r17, 0xFF	; 255
    143e:	c8 01       	movw	r24, r16
    1440:	1a d9       	rcall	.-3532   	; 0x676 <uxListRemove>
    1442:	9e 89       	ldd	r25, Y+22	; 0x16
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1444:	80 91 7c 1e 	lds	r24, 0x1E7C
    1448:	89 17       	cp	r24, r25
    144a:	10 f4       	brcc	.+4      	; 0x1450 <vTaskPrioritySet+0xbc>
    144c:	90 93 7c 1e 	sts	0x1E7C, r25
    1450:	89 e0       	ldi	r24, 0x09	; 9
    1452:	98 9f       	mul	r25, r24
    1454:	c0 01       	movw	r24, r0
    1456:	11 24       	eor	r1, r1
    1458:	87 57       	subi	r24, 0x77	; 119
    145a:	91 4e       	sbci	r25, 0xE1	; 225
    145c:	b8 01       	movw	r22, r16
    145e:	ba d8       	rcall	.-3724   	; 0x5d4 <vListInsertEnd>
    1460:	ff 20       	and	r15, r15
    1462:	09 f0       	breq	.+2      	; 0x1466 <vTaskPrioritySet+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    1464:	07 d8       	rcall	.-4082   	; 0x474 <vPortYield>
    1466:	0f 90       	pop	r0
				{
					taskYIELD_IF_USING_PREEMPTION();
    1468:	0f be       	out	0x3f, r0	; 63
    146a:	df 91       	pop	r29
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    146c:	cf 91       	pop	r28
    146e:	1f 91       	pop	r17
	}
    1470:	0f 91       	pop	r16
    1472:	ff 90       	pop	r15
    1474:	08 95       	ret

00001476 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1476:	0f 93       	push	r16
    1478:	1f 93       	push	r17
    147a:	cf 93       	push	r28
    147c:	df 93       	push	r29
    147e:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1480:	00 91 7e 1e 	lds	r16, 0x1E7E
    1484:	10 91 7f 1e 	lds	r17, 0x1E7F
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1488:	80 91 79 1e 	lds	r24, 0x1E79
    148c:	90 91 7a 1e 	lds	r25, 0x1E7A
    1490:	02 96       	adiw	r24, 0x02	; 2
    1492:	f1 d8       	rcall	.-3614   	; 0x676 <uxListRemove>
    1494:	c0 0f       	add	r28, r16
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    1496:	d1 1f       	adc	r29, r17
    1498:	e0 91 79 1e 	lds	r30, 0x1E79

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    149c:	f0 91 7a 1e 	lds	r31, 0x1E7A
    14a0:	d3 83       	std	Z+3, r29	; 0x03
    14a2:	c2 83       	std	Z+2, r28	; 0x02
    14a4:	c0 17       	cp	r28, r16

		if( xTimeToWake < xConstTickCount )
    14a6:	d1 07       	cpc	r29, r17
    14a8:	60 f4       	brcc	.+24     	; 0x14c2 <prvAddCurrentTaskToDelayedList+0x4c>
    14aa:	80 91 c1 1e 	lds	r24, 0x1EC1
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    14ae:	90 91 c2 1e 	lds	r25, 0x1EC2
    14b2:	60 91 79 1e 	lds	r22, 0x1E79
    14b6:	70 91 7a 1e 	lds	r23, 0x1E7A
    14ba:	6e 5f       	subi	r22, 0xFE	; 254
    14bc:	7f 4f       	sbci	r23, 0xFF	; 255
    14be:	a9 d8       	rcall	.-3758   	; 0x612 <vListInsert>
    14c0:	16 c0       	rjmp	.+44     	; 0x14ee <prvAddCurrentTaskToDelayedList+0x78>
    14c2:	80 91 bf 1e 	lds	r24, 0x1EBF
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    14c6:	90 91 c0 1e 	lds	r25, 0x1EC0
    14ca:	60 91 79 1e 	lds	r22, 0x1E79
    14ce:	70 91 7a 1e 	lds	r23, 0x1E7A
    14d2:	6e 5f       	subi	r22, 0xFE	; 254
    14d4:	7f 4f       	sbci	r23, 0xFF	; 255
    14d6:	9d d8       	rcall	.-3782   	; 0x612 <vListInsert>
    14d8:	80 91 80 1e 	lds	r24, 0x1E80
    14dc:	90 91 81 1e 	lds	r25, 0x1E81

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    14e0:	c8 17       	cp	r28, r24
    14e2:	d9 07       	cpc	r29, r25
    14e4:	20 f4       	brcc	.+8      	; 0x14ee <prvAddCurrentTaskToDelayedList+0x78>
    14e6:	d0 93 81 1e 	sts	0x1E81, r29
    14ea:	c0 93 80 1e 	sts	0x1E80, r28
			{
				xNextTaskUnblockTime = xTimeToWake;
    14ee:	df 91       	pop	r29
    14f0:	cf 91       	pop	r28
    14f2:	1f 91       	pop	r17

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    14f4:	0f 91       	pop	r16
    14f6:	08 95       	ret

000014f8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    14f8:	6f 92       	push	r6
    14fa:	7f 92       	push	r7
    14fc:	8f 92       	push	r8
    14fe:	9f 92       	push	r9
    1500:	af 92       	push	r10
    1502:	bf 92       	push	r11
    1504:	cf 92       	push	r12
    1506:	df 92       	push	r13
    1508:	ef 92       	push	r14
    150a:	ff 92       	push	r15
    150c:	0f 93       	push	r16
    150e:	1f 93       	push	r17
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    1514:	5b 01       	movw	r10, r22
    1516:	6c 01       	movw	r12, r24
    1518:	39 01       	movw	r6, r18
    151a:	4a 01       	movw	r8, r20
    151c:	e8 01       	movw	r28, r16
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    151e:	0f b6       	in	r0, 0x3f	; 63
    1520:	f8 94       	cli
    1522:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1524:	e0 91 79 1e 	lds	r30, 0x1E79
    1528:	f0 91 7a 1e 	lds	r31, 0x1E7A
    152c:	85 a1       	ldd	r24, Z+37	; 0x25
    152e:	82 30       	cpi	r24, 0x02	; 2
    1530:	11 f1       	breq	.+68     	; 0x1576 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1532:	e0 91 79 1e 	lds	r30, 0x1E79
    1536:	f0 91 7a 1e 	lds	r31, 0x1E7A
    153a:	81 a1       	ldd	r24, Z+33	; 0x21
    153c:	92 a1       	ldd	r25, Z+34	; 0x22
    153e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1540:	b4 a1       	ldd	r27, Z+36	; 0x24
    1542:	a0 94       	com	r10
    1544:	b0 94       	com	r11
    1546:	c0 94       	com	r12
    1548:	d0 94       	com	r13
    154a:	8a 21       	and	r24, r10
    154c:	9b 21       	and	r25, r11
    154e:	ac 21       	and	r26, r12
    1550:	bd 21       	and	r27, r13
    1552:	81 a3       	std	Z+33, r24	; 0x21
    1554:	92 a3       	std	Z+34, r25	; 0x22
    1556:	a3 a3       	std	Z+35, r26	; 0x23
    1558:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    155a:	e0 91 79 1e 	lds	r30, 0x1E79
    155e:	f0 91 7a 1e 	lds	r31, 0x1E7A
    1562:	81 e0       	ldi	r24, 0x01	; 1
    1564:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1566:	e1 14       	cp	r14, r1
    1568:	f1 04       	cpc	r15, r1
    156a:	29 f0       	breq	.+10     	; 0x1576 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    156c:	c7 01       	movw	r24, r14
    156e:	61 e0       	ldi	r22, 0x01	; 1
    1570:	82 df       	rcall	.-252    	; 0x1476 <prvAddCurrentTaskToDelayedList>
    1572:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1576:	0f 90       	pop	r0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1578:	0f be       	out	0x3f, r0	; 63
    157a:	0f b6       	in	r0, 0x3f	; 63

		taskENTER_CRITICAL();
    157c:	f8 94       	cli
    157e:	0f 92       	push	r0
    1580:	20 97       	sbiw	r28, 0x00	; 0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1582:	61 f0       	breq	.+24     	; 0x159c <xTaskNotifyWait+0xa4>
    1584:	e0 91 79 1e 	lds	r30, 0x1E79
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1588:	f0 91 7a 1e 	lds	r31, 0x1E7A
    158c:	81 a1       	ldd	r24, Z+33	; 0x21
    158e:	92 a1       	ldd	r25, Z+34	; 0x22
    1590:	a3 a1       	ldd	r26, Z+35	; 0x23
    1592:	b4 a1       	ldd	r27, Z+36	; 0x24
    1594:	88 83       	st	Y, r24
    1596:	99 83       	std	Y+1, r25	; 0x01
    1598:	aa 83       	std	Y+2, r26	; 0x02
    159a:	bb 83       	std	Y+3, r27	; 0x03
    159c:	e0 91 79 1e 	lds	r30, 0x1E79

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    15a0:	f0 91 7a 1e 	lds	r31, 0x1E7A
    15a4:	85 a1       	ldd	r24, Z+37	; 0x25
    15a6:	81 30       	cpi	r24, 0x01	; 1
    15a8:	11 f4       	brne	.+4      	; 0x15ae <xTaskNotifyWait+0xb6>
    15aa:	80 e0       	ldi	r24, 0x00	; 0
    15ac:	15 c0       	rjmp	.+42     	; 0x15d8 <xTaskNotifyWait+0xe0>
    15ae:	e0 91 79 1e 	lds	r30, 0x1E79
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    15b2:	f0 91 7a 1e 	lds	r31, 0x1E7A
    15b6:	81 a1       	ldd	r24, Z+33	; 0x21
    15b8:	92 a1       	ldd	r25, Z+34	; 0x22
    15ba:	a3 a1       	ldd	r26, Z+35	; 0x23
    15bc:	b4 a1       	ldd	r27, Z+36	; 0x24
    15be:	60 94       	com	r6
    15c0:	70 94       	com	r7
    15c2:	80 94       	com	r8
    15c4:	90 94       	com	r9
    15c6:	86 21       	and	r24, r6
    15c8:	97 21       	and	r25, r7
    15ca:	a8 21       	and	r26, r8
    15cc:	b9 21       	and	r27, r9
    15ce:	81 a3       	std	Z+33, r24	; 0x21
    15d0:	92 a3       	std	Z+34, r25	; 0x22
    15d2:	a3 a3       	std	Z+35, r26	; 0x23
    15d4:	b4 a3       	std	Z+36, r27	; 0x24
    15d6:	81 e0       	ldi	r24, 0x01	; 1
    15d8:	e0 91 79 1e 	lds	r30, 0x1E79
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    15dc:	f0 91 7a 1e 	lds	r31, 0x1E7A
    15e0:	15 a2       	std	Z+37, r1	; 0x25
    15e2:	0f 90       	pop	r0
		}
		taskEXIT_CRITICAL();
    15e4:	0f be       	out	0x3f, r0	; 63
    15e6:	df 91       	pop	r29

		return xReturn;
	}
    15e8:	cf 91       	pop	r28
    15ea:	1f 91       	pop	r17
    15ec:	0f 91       	pop	r16
    15ee:	ff 90       	pop	r15
    15f0:	ef 90       	pop	r14
    15f2:	df 90       	pop	r13
    15f4:	cf 90       	pop	r12
    15f6:	bf 90       	pop	r11
    15f8:	af 90       	pop	r10
    15fa:	9f 90       	pop	r9
    15fc:	8f 90       	pop	r8
    15fe:	7f 90       	pop	r7
    1600:	6f 90       	pop	r6
    1602:	08 95       	ret

00001604 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1604:	1f 93       	push	r17
    1606:	18 2f       	mov	r17, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1608:	0f b6       	in	r0, 0x3f	; 63
    160a:	f8 94       	cli
    160c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    160e:	e0 91 79 1e 	lds	r30, 0x1E79
    1612:	f0 91 7a 1e 	lds	r31, 0x1E7A
    1616:	81 a1       	ldd	r24, Z+33	; 0x21
    1618:	92 a1       	ldd	r25, Z+34	; 0x22
    161a:	a3 a1       	ldd	r26, Z+35	; 0x23
    161c:	b4 a1       	ldd	r27, Z+36	; 0x24
    161e:	00 97       	sbiw	r24, 0x00	; 0
    1620:	a1 05       	cpc	r26, r1
    1622:	b1 05       	cpc	r27, r1
    1624:	71 f4       	brne	.+28     	; 0x1642 <ulTaskNotifyTake+0x3e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1626:	e0 91 79 1e 	lds	r30, 0x1E79
    162a:	f0 91 7a 1e 	lds	r31, 0x1E7A
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1632:	61 15       	cp	r22, r1
    1634:	71 05       	cpc	r23, r1
    1636:	29 f0       	breq	.+10     	; 0x1642 <ulTaskNotifyTake+0x3e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1638:	cb 01       	movw	r24, r22
    163a:	61 e0       	ldi	r22, 0x01	; 1
    163c:	1c df       	rcall	.-456    	; 0x1476 <prvAddCurrentTaskToDelayedList>
    163e:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1642:	0f 90       	pop	r0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1644:	0f be       	out	0x3f, r0	; 63
    1646:	0f b6       	in	r0, 0x3f	; 63

		taskENTER_CRITICAL();
    1648:	f8 94       	cli
    164a:	0f 92       	push	r0
    164c:	e0 91 79 1e 	lds	r30, 0x1E79
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1650:	f0 91 7a 1e 	lds	r31, 0x1E7A
    1654:	21 a1       	ldd	r18, Z+33	; 0x21
    1656:	32 a1       	ldd	r19, Z+34	; 0x22
    1658:	43 a1       	ldd	r20, Z+35	; 0x23
    165a:	54 a1       	ldd	r21, Z+36	; 0x24
    165c:	21 15       	cp	r18, r1

			if( ulReturn != 0UL )
    165e:	31 05       	cpc	r19, r1
    1660:	41 05       	cpc	r20, r1
    1662:	51 05       	cpc	r21, r1
    1664:	d9 f0       	breq	.+54     	; 0x169c <ulTaskNotifyTake+0x98>
    1666:	11 23       	and	r17, r17
			{
				if( xClearCountOnExit != pdFALSE )
    1668:	49 f0       	breq	.+18     	; 0x167c <ulTaskNotifyTake+0x78>
    166a:	e0 91 79 1e 	lds	r30, 0x1E79
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    166e:	f0 91 7a 1e 	lds	r31, 0x1E7A
    1672:	11 a2       	std	Z+33, r1	; 0x21
    1674:	12 a2       	std	Z+34, r1	; 0x22
    1676:	13 a2       	std	Z+35, r1	; 0x23
    1678:	14 a2       	std	Z+36, r1	; 0x24
    167a:	10 c0       	rjmp	.+32     	; 0x169c <ulTaskNotifyTake+0x98>
    167c:	e0 91 79 1e 	lds	r30, 0x1E79
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    1680:	f0 91 7a 1e 	lds	r31, 0x1E7A
    1684:	21 50       	subi	r18, 0x01	; 1
    1686:	30 40       	sbci	r19, 0x00	; 0
    1688:	40 40       	sbci	r20, 0x00	; 0
    168a:	50 40       	sbci	r21, 0x00	; 0
    168c:	21 a3       	std	Z+33, r18	; 0x21
    168e:	32 a3       	std	Z+34, r19	; 0x22
    1690:	43 a3       	std	Z+35, r20	; 0x23
    1692:	54 a3       	std	Z+36, r21	; 0x24
    1694:	2f 5f       	subi	r18, 0xFF	; 255
    1696:	3f 4f       	sbci	r19, 0xFF	; 255
    1698:	4f 4f       	sbci	r20, 0xFF	; 255
    169a:	5f 4f       	sbci	r21, 0xFF	; 255
    169c:	e0 91 79 1e 	lds	r30, 0x1E79
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    16a0:	f0 91 7a 1e 	lds	r31, 0x1E7A
    16a4:	15 a2       	std	Z+37, r1	; 0x25
    16a6:	0f 90       	pop	r0
		}
		taskEXIT_CRITICAL();
    16a8:	0f be       	out	0x3f, r0	; 63
    16aa:	b9 01       	movw	r22, r18

		return ulReturn;
	}
    16ac:	ca 01       	movw	r24, r20
    16ae:	1f 91       	pop	r17
    16b0:	08 95       	ret

000016b2 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    16b2:	ff 92       	push	r15
    16b4:	0f 93       	push	r16
    16b6:	1f 93       	push	r17
    16b8:	cf 93       	push	r28
    16ba:	df 93       	push	r29
    16bc:	ec 01       	movw	r28, r24
    16be:	8b 01       	movw	r16, r22
    16c0:	f4 2e       	mov	r15, r20
		configASSERT( pxEventList );
    16c2:	00 97       	sbiw	r24, 0x00	; 0
    16c4:	41 f4       	brne	.+16     	; 0x16d6 <vTaskPlaceOnEventListRestricted+0x24>
    16c6:	61 e3       	ldi	r22, 0x31	; 49
    16c8:	7b e0       	ldi	r23, 0x0B	; 11
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	90 e0       	ldi	r25, 0x00	; 0
    16ce:	48 e4       	ldi	r20, 0x48	; 72
    16d0:	52 e0       	ldi	r21, 0x02	; 2
    16d2:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    16d6:	60 91 79 1e 	lds	r22, 0x1E79
    16da:	70 91 7a 1e 	lds	r23, 0x1E7A
    16de:	64 5f       	subi	r22, 0xF4	; 244
    16e0:	7f 4f       	sbci	r23, 0xFF	; 255
    16e2:	ce 01       	movw	r24, r28
    16e4:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
    16e8:	ff 20       	and	r15, r15
    16ea:	11 f0       	breq	.+4      	; 0x16f0 <vTaskPlaceOnEventListRestricted+0x3e>
    16ec:	0f ef       	ldi	r16, 0xFF	; 255
    16ee:	1f ef       	ldi	r17, 0xFF	; 255
		{
			xTicksToWait = portMAX_DELAY;
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    16f0:	c8 01       	movw	r24, r16
    16f2:	6f 2d       	mov	r22, r15
    16f4:	c0 de       	rcall	.-640    	; 0x1476 <prvAddCurrentTaskToDelayedList>
    16f6:	df 91       	pop	r29
	}
    16f8:	cf 91       	pop	r28
    16fa:	1f 91       	pop	r17
    16fc:	0f 91       	pop	r16
    16fe:	ff 90       	pop	r15
    1700:	08 95       	ret

00001702 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	ec 01       	movw	r28, r24
    170c:	8b 01       	movw	r16, r22
	configASSERT( pxEventList );
    170e:	00 97       	sbiw	r24, 0x00	; 0
    1710:	41 f4       	brne	.+16     	; 0x1722 <vTaskPlaceOnEventList+0x20>
    1712:	66 e0       	ldi	r22, 0x06	; 6
    1714:	7b e0       	ldi	r23, 0x0B	; 11
    1716:	80 e0       	ldi	r24, 0x00	; 0
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	48 e4       	ldi	r20, 0x48	; 72
    171c:	52 e0       	ldi	r21, 0x02	; 2
    171e:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1722:	60 91 79 1e 	lds	r22, 0x1E79
    1726:	70 91 7a 1e 	lds	r23, 0x1E7A
    172a:	64 5f       	subi	r22, 0xF4	; 244
    172c:	7f 4f       	sbci	r23, 0xFF	; 255
    172e:	ce 01       	movw	r24, r28
    1730:	0e 94 09 03 	call	0x612	; 0x612 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1734:	c8 01       	movw	r24, r16
    1736:	61 e0       	ldi	r22, 0x01	; 1
    1738:	9e de       	rcall	.-708    	; 0x1476 <prvAddCurrentTaskToDelayedList>
    173a:	df 91       	pop	r29
}
    173c:	cf 91       	pop	r28
    173e:	1f 91       	pop	r17
    1740:	0f 91       	pop	r16
    1742:	08 95       	ret

00001744 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1744:	cf 92       	push	r12
    1746:	df 92       	push	r13
    1748:	ef 92       	push	r14
    174a:	ff 92       	push	r15
    174c:	0f 93       	push	r16
    174e:	1f 93       	push	r17
    1750:	cf 93       	push	r28
    1752:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1754:	80 91 7b 1e 	lds	r24, 0x1E7B
    1758:	88 23       	and	r24, r24
    175a:	09 f0       	breq	.+2      	; 0x175e <xTaskIncrementTick+0x1a>
    175c:	bb c0       	rjmp	.+374    	; 0x18d4 <xTaskIncrementTick+0x190>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    175e:	00 91 7e 1e 	lds	r16, 0x1E7E
    1762:	10 91 7f 1e 	lds	r17, 0x1E7F
    1766:	0f 5f       	subi	r16, 0xFF	; 255
    1768:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    176a:	10 93 7f 1e 	sts	0x1E7F, r17
    176e:	00 93 7e 1e 	sts	0x1E7E, r16

		if( xConstTickCount == ( TickType_t ) 0U )
    1772:	01 15       	cp	r16, r1
    1774:	11 05       	cpc	r17, r1
    1776:	f1 f5       	brne	.+124    	; 0x17f4 <xTaskIncrementTick+0xb0>
		{
			taskSWITCH_DELAYED_LISTS();
    1778:	e0 91 bf 1e 	lds	r30, 0x1EBF
    177c:	f0 91 c0 1e 	lds	r31, 0x1EC0
    1780:	80 81       	ld	r24, Z
    1782:	88 23       	and	r24, r24
    1784:	41 f0       	breq	.+16     	; 0x1796 <xTaskIncrementTick+0x52>
    1786:	69 ed       	ldi	r22, 0xD9	; 217
    1788:	79 e0       	ldi	r23, 0x09	; 9
    178a:	80 e0       	ldi	r24, 0x00	; 0
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	48 e4       	ldi	r20, 0x48	; 72
    1790:	52 e0       	ldi	r21, 0x02	; 2
    1792:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
    1796:	20 91 bf 1e 	lds	r18, 0x1EBF
    179a:	30 91 c0 1e 	lds	r19, 0x1EC0
    179e:	80 91 c1 1e 	lds	r24, 0x1EC1
    17a2:	90 91 c2 1e 	lds	r25, 0x1EC2
    17a6:	90 93 c0 1e 	sts	0x1EC0, r25
    17aa:	80 93 bf 1e 	sts	0x1EBF, r24
    17ae:	30 93 c2 1e 	sts	0x1EC2, r19
    17b2:	20 93 c1 1e 	sts	0x1EC1, r18
    17b6:	80 91 83 1e 	lds	r24, 0x1E83
    17ba:	8f 5f       	subi	r24, 0xFF	; 255
    17bc:	80 93 83 1e 	sts	0x1E83, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    17c0:	e0 91 bf 1e 	lds	r30, 0x1EBF
    17c4:	f0 91 c0 1e 	lds	r31, 0x1EC0
    17c8:	80 81       	ld	r24, Z
    17ca:	88 23       	and	r24, r24
    17cc:	19 f4       	brne	.+6      	; 0x17d4 <xTaskIncrementTick+0x90>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    17ce:	8f ef       	ldi	r24, 0xFF	; 255
    17d0:	9f ef       	ldi	r25, 0xFF	; 255
    17d2:	0c c0       	rjmp	.+24     	; 0x17ec <xTaskIncrementTick+0xa8>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    17d4:	e0 91 bf 1e 	lds	r30, 0x1EBF
    17d8:	f0 91 c0 1e 	lds	r31, 0x1EC0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    17dc:	05 80       	ldd	r0, Z+5	; 0x05
    17de:	f6 81       	ldd	r31, Z+6	; 0x06
    17e0:	e0 2d       	mov	r30, r0
    17e2:	06 80       	ldd	r0, Z+6	; 0x06
    17e4:	f7 81       	ldd	r31, Z+7	; 0x07
    17e6:	e0 2d       	mov	r30, r0
    17e8:	82 81       	ldd	r24, Z+2	; 0x02
    17ea:	93 81       	ldd	r25, Z+3	; 0x03
    17ec:	90 93 81 1e 	sts	0x1E81, r25
    17f0:	80 93 80 1e 	sts	0x1E80, r24

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    17f4:	80 91 80 1e 	lds	r24, 0x1E80
    17f8:	90 91 81 1e 	lds	r25, 0x1E81
    17fc:	08 17       	cp	r16, r24
    17fe:	19 07       	cpc	r17, r25
    1800:	08 f4       	brcc	.+2      	; 0x1804 <xTaskIncrementTick+0xc0>
    1802:	4b c0       	rjmp	.+150    	; 0x189a <xTaskIncrementTick+0x156>
    1804:	dd 24       	eor	r13, r13
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1806:	49 e0       	ldi	r20, 0x09	; 9
    1808:	c4 2e       	mov	r12, r20
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    180a:	e0 91 bf 1e 	lds	r30, 0x1EBF
    180e:	f0 91 c0 1e 	lds	r31, 0x1EC0
    1812:	80 81       	ld	r24, Z
    1814:	88 23       	and	r24, r24
    1816:	19 f4       	brne	.+6      	; 0x181e <xTaskIncrementTick+0xda>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1818:	8f ef       	ldi	r24, 0xFF	; 255
    181a:	9f ef       	ldi	r25, 0xFF	; 255
    181c:	0e c0       	rjmp	.+28     	; 0x183a <xTaskIncrementTick+0xf6>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    181e:	e0 91 bf 1e 	lds	r30, 0x1EBF
    1822:	f0 91 c0 1e 	lds	r31, 0x1EC0
    1826:	05 80       	ldd	r0, Z+5	; 0x05
    1828:	f6 81       	ldd	r31, Z+6	; 0x06
    182a:	e0 2d       	mov	r30, r0
    182c:	c6 81       	ldd	r28, Z+6	; 0x06
    182e:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1830:	8a 81       	ldd	r24, Y+2	; 0x02
    1832:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1834:	08 17       	cp	r16, r24
    1836:	19 07       	cpc	r17, r25
    1838:	28 f4       	brcc	.+10     	; 0x1844 <xTaskIncrementTick+0x100>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    183a:	90 93 81 1e 	sts	0x1E81, r25
    183e:	80 93 80 1e 	sts	0x1E80, r24
    1842:	2c c0       	rjmp	.+88     	; 0x189c <xTaskIncrementTick+0x158>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1844:	32 e0       	ldi	r19, 0x02	; 2
    1846:	e3 2e       	mov	r14, r19
    1848:	f1 2c       	mov	r15, r1
    184a:	ec 0e       	add	r14, r28
    184c:	fd 1e       	adc	r15, r29
    184e:	c7 01       	movw	r24, r14
    1850:	0e 94 3b 03 	call	0x676	; 0x676 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1854:	8c 89       	ldd	r24, Y+20	; 0x14
    1856:	9d 89       	ldd	r25, Y+21	; 0x15
    1858:	89 2b       	or	r24, r25
    185a:	21 f0       	breq	.+8      	; 0x1864 <xTaskIncrementTick+0x120>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    185c:	ce 01       	movw	r24, r28
    185e:	0c 96       	adiw	r24, 0x0c	; 12
    1860:	0e 94 3b 03 	call	0x676	; 0x676 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1864:	9e 89       	ldd	r25, Y+22	; 0x16
    1866:	80 91 7c 1e 	lds	r24, 0x1E7C
    186a:	89 17       	cp	r24, r25
    186c:	10 f4       	brcc	.+4      	; 0x1872 <xTaskIncrementTick+0x12e>
    186e:	90 93 7c 1e 	sts	0x1E7C, r25
    1872:	9c 9d       	mul	r25, r12
    1874:	c0 01       	movw	r24, r0
    1876:	11 24       	eor	r1, r1
    1878:	87 57       	subi	r24, 0x77	; 119
    187a:	91 4e       	sbci	r25, 0xE1	; 225
    187c:	b7 01       	movw	r22, r14
    187e:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1882:	e0 91 79 1e 	lds	r30, 0x1E79
    1886:	f0 91 7a 1e 	lds	r31, 0x1E7A
    188a:	9e 89       	ldd	r25, Y+22	; 0x16
    188c:	86 89       	ldd	r24, Z+22	; 0x16
    188e:	98 17       	cp	r25, r24
    1890:	08 f4       	brcc	.+2      	; 0x1894 <xTaskIncrementTick+0x150>
    1892:	bb cf       	rjmp	.-138    	; 0x180a <xTaskIncrementTick+0xc6>
    1894:	dd 24       	eor	r13, r13
    1896:	d3 94       	inc	r13
    1898:	b8 cf       	rjmp	.-144    	; 0x180a <xTaskIncrementTick+0xc6>
    189a:	dd 24       	eor	r13, r13
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    189c:	e0 91 79 1e 	lds	r30, 0x1E79
    18a0:	f0 91 7a 1e 	lds	r31, 0x1E7A
    18a4:	86 89       	ldd	r24, Z+22	; 0x16
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	fc 01       	movw	r30, r24
    18aa:	23 e0       	ldi	r18, 0x03	; 3
    18ac:	ee 0f       	add	r30, r30
    18ae:	ff 1f       	adc	r31, r31
    18b0:	2a 95       	dec	r18
    18b2:	e1 f7       	brne	.-8      	; 0x18ac <xTaskIncrementTick+0x168>
    18b4:	e8 0f       	add	r30, r24
    18b6:	f9 1f       	adc	r31, r25
    18b8:	e7 57       	subi	r30, 0x77	; 119
    18ba:	f1 4e       	sbci	r31, 0xE1	; 225
    18bc:	80 81       	ld	r24, Z
    18be:	82 30       	cpi	r24, 0x02	; 2
    18c0:	10 f0       	brcs	.+4      	; 0x18c6 <xTaskIncrementTick+0x182>
    18c2:	dd 24       	eor	r13, r13
    18c4:	d3 94       	inc	r13

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
    18c6:	80 91 84 1e 	lds	r24, 0x1E84
    18ca:	88 23       	and	r24, r24
    18cc:	59 f4       	brne	.+22     	; 0x18e4 <xTaskIncrementTick+0x1a0>
			{
				vApplicationTickHook();
    18ce:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vApplicationTickHook>
    18d2:	08 c0       	rjmp	.+16     	; 0x18e4 <xTaskIncrementTick+0x1a0>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    18d4:	80 91 84 1e 	lds	r24, 0x1E84
    18d8:	8f 5f       	subi	r24, 0xFF	; 255
    18da:	80 93 84 1e 	sts	0x1E84, r24

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
    18de:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <vApplicationTickHook>
    18e2:	dd 24       	eor	r13, r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    18e4:	80 91 7d 1e 	lds	r24, 0x1E7D
    18e8:	88 23       	and	r24, r24
    18ea:	11 f0       	breq	.+4      	; 0x18f0 <xTaskIncrementTick+0x1ac>
    18ec:	dd 24       	eor	r13, r13
    18ee:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    18f0:	8d 2d       	mov	r24, r13
    18f2:	df 91       	pop	r29
    18f4:	cf 91       	pop	r28
    18f6:	1f 91       	pop	r17
    18f8:	0f 91       	pop	r16
    18fa:	ff 90       	pop	r15
    18fc:	ef 90       	pop	r14
    18fe:	df 90       	pop	r13
    1900:	cf 90       	pop	r12
    1902:	08 95       	ret

00001904 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1904:	ef 92       	push	r14
    1906:	ff 92       	push	r15
    1908:	0f 93       	push	r16
    190a:	1f 93       	push	r17
    190c:	cf 93       	push	r28
    190e:	df 93       	push	r29
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
    1910:	80 91 7b 1e 	lds	r24, 0x1E7B
    1914:	88 23       	and	r24, r24
    1916:	41 f4       	brne	.+16     	; 0x1928 <xTaskResumeAll+0x24>
    1918:	68 ee       	ldi	r22, 0xE8	; 232
    191a:	77 e0       	ldi	r23, 0x07	; 7
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	48 e4       	ldi	r20, 0x48	; 72
    1922:	52 e0       	ldi	r21, 0x02	; 2
    1924:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    192e:	80 91 7b 1e 	lds	r24, 0x1E7B
    1932:	81 50       	subi	r24, 0x01	; 1
    1934:	80 93 7b 1e 	sts	0x1E7B, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1938:	80 91 7b 1e 	lds	r24, 0x1E7B
    193c:	88 23       	and	r24, r24
    193e:	09 f0       	breq	.+2      	; 0x1942 <xTaskResumeAll+0x3e>
    1940:	6b c0       	rjmp	.+214    	; 0x1a18 <xTaskResumeAll+0x114>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1942:	80 91 85 1e 	lds	r24, 0x1E85
    1946:	88 23       	and	r24, r24
    1948:	09 f4       	brne	.+2      	; 0x194c <xTaskResumeAll+0x48>
    194a:	66 c0       	rjmp	.+204    	; 0x1a18 <xTaskResumeAll+0x114>
    194c:	c0 e0       	ldi	r28, 0x00	; 0
    194e:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
    1950:	59 e0       	ldi	r21, 0x09	; 9
    1952:	e5 2e       	mov	r14, r21

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    1954:	ff 24       	eor	r15, r15
    1956:	f3 94       	inc	r15
    1958:	29 c0       	rjmp	.+82     	; 0x19ac <xTaskResumeAll+0xa8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    195a:	e0 91 c8 1e 	lds	r30, 0x1EC8
    195e:	f0 91 c9 1e 	lds	r31, 0x1EC9
    1962:	c6 81       	ldd	r28, Z+6	; 0x06
    1964:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1966:	ce 01       	movw	r24, r28
    1968:	0c 96       	adiw	r24, 0x0c	; 12
    196a:	0e 94 3b 03 	call	0x676	; 0x676 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    196e:	8e 01       	movw	r16, r28
    1970:	0e 5f       	subi	r16, 0xFE	; 254
    1972:	1f 4f       	sbci	r17, 0xFF	; 255
    1974:	c8 01       	movw	r24, r16
    1976:	0e 94 3b 03 	call	0x676	; 0x676 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    197a:	9e 89       	ldd	r25, Y+22	; 0x16
    197c:	80 91 7c 1e 	lds	r24, 0x1E7C
    1980:	89 17       	cp	r24, r25
    1982:	10 f4       	brcc	.+4      	; 0x1988 <xTaskResumeAll+0x84>
    1984:	90 93 7c 1e 	sts	0x1E7C, r25
    1988:	9e 9d       	mul	r25, r14
    198a:	c0 01       	movw	r24, r0
    198c:	11 24       	eor	r1, r1
    198e:	87 57       	subi	r24, 0x77	; 119
    1990:	91 4e       	sbci	r25, 0xE1	; 225
    1992:	b8 01       	movw	r22, r16
    1994:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1998:	e0 91 79 1e 	lds	r30, 0x1E79
    199c:	f0 91 7a 1e 	lds	r31, 0x1E7A
    19a0:	9e 89       	ldd	r25, Y+22	; 0x16
    19a2:	86 89       	ldd	r24, Z+22	; 0x16
    19a4:	98 17       	cp	r25, r24
    19a6:	10 f0       	brcs	.+4      	; 0x19ac <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    19a8:	f0 92 7d 1e 	sts	0x1E7D, r15
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    19ac:	80 91 c3 1e 	lds	r24, 0x1EC3
    19b0:	88 23       	and	r24, r24
    19b2:	99 f6       	brne	.-90     	; 0x195a <xTaskResumeAll+0x56>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    19b4:	cd 2b       	or	r28, r29
    19b6:	d1 f0       	breq	.+52     	; 0x19ec <xTaskResumeAll+0xe8>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    19b8:	e0 91 bf 1e 	lds	r30, 0x1EBF
    19bc:	f0 91 c0 1e 	lds	r31, 0x1EC0
    19c0:	80 81       	ld	r24, Z
    19c2:	88 23       	and	r24, r24
    19c4:	19 f4       	brne	.+6      	; 0x19cc <xTaskResumeAll+0xc8>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    19c6:	8f ef       	ldi	r24, 0xFF	; 255
    19c8:	9f ef       	ldi	r25, 0xFF	; 255
    19ca:	0c c0       	rjmp	.+24     	; 0x19e4 <xTaskResumeAll+0xe0>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    19cc:	e0 91 bf 1e 	lds	r30, 0x1EBF
    19d0:	f0 91 c0 1e 	lds	r31, 0x1EC0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    19d4:	05 80       	ldd	r0, Z+5	; 0x05
    19d6:	f6 81       	ldd	r31, Z+6	; 0x06
    19d8:	e0 2d       	mov	r30, r0
    19da:	06 80       	ldd	r0, Z+6	; 0x06
    19dc:	f7 81       	ldd	r31, Z+7	; 0x07
    19de:	e0 2d       	mov	r30, r0
    19e0:	82 81       	ldd	r24, Z+2	; 0x02
    19e2:	93 81       	ldd	r25, Z+3	; 0x03
    19e4:	90 93 81 1e 	sts	0x1E81, r25
    19e8:	80 93 80 1e 	sts	0x1E80, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    19ec:	10 91 84 1e 	lds	r17, 0x1E84

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    19f0:	11 23       	and	r17, r17
    19f2:	51 f0       	breq	.+20     	; 0x1a08 <xTaskResumeAll+0x104>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    19f4:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    19f6:	a6 de       	rcall	.-692    	; 0x1744 <xTaskIncrementTick>
    19f8:	88 23       	and	r24, r24
    19fa:	11 f0       	breq	.+4      	; 0x1a00 <xTaskResumeAll+0xfc>
    19fc:	00 93 7d 1e 	sts	0x1E7D, r16
							{
								xYieldPending = pdTRUE;
    1a00:	11 50       	subi	r17, 0x01	; 1
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1a02:	c9 f7       	brne	.-14     	; 0x19f6 <xTaskResumeAll+0xf2>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1a04:	10 92 84 1e 	sts	0x1E84, r1

						uxPendedTicks = 0;
    1a08:	80 91 7d 1e 	lds	r24, 0x1E7D
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1a0c:	88 23       	and	r24, r24
    1a0e:	21 f0       	breq	.+8      	; 0x1a18 <xTaskResumeAll+0x114>
    1a10:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <xTaskResumeAll+0x116>
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	0f 90       	pop	r0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	df 91       	pop	r29

	return xAlreadyYielded;
}
    1a20:	cf 91       	pop	r28
    1a22:	1f 91       	pop	r17
    1a24:	0f 91       	pop	r16
    1a26:	ff 90       	pop	r15
    1a28:	ef 90       	pop	r14
    1a2a:	08 95       	ret

00001a2c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1a2c:	0f 93       	push	r16
    1a2e:	1f 93       	push	r17
    1a30:	cf 93       	push	r28
    1a32:	df 93       	push	r29
    1a34:	ec 01       	movw	r28, r24
    1a36:	8b 01       	movw	r16, r22
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
    1a38:	00 97       	sbiw	r24, 0x00	; 0
    1a3a:	41 f4       	brne	.+16     	; 0x1a4c <vTaskDelayUntil+0x20>
    1a3c:	69 e7       	ldi	r22, 0x79	; 121
    1a3e:	74 e0       	ldi	r23, 0x04	; 4
    1a40:	80 e0       	ldi	r24, 0x00	; 0
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	48 e4       	ldi	r20, 0x48	; 72
    1a46:	52 e0       	ldi	r21, 0x02	; 2
    1a48:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
		configASSERT( ( xTimeIncrement > 0U ) );
    1a4c:	01 15       	cp	r16, r1
    1a4e:	11 05       	cpc	r17, r1
    1a50:	41 f4       	brne	.+16     	; 0x1a62 <vTaskDelayUntil+0x36>
    1a52:	6a e7       	ldi	r22, 0x7A	; 122
    1a54:	74 e0       	ldi	r23, 0x04	; 4
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	48 e4       	ldi	r20, 0x48	; 72
    1a5c:	52 e0       	ldi	r21, 0x02	; 2
    1a5e:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
		configASSERT( uxSchedulerSuspended == 0 );
    1a62:	80 91 7b 1e 	lds	r24, 0x1E7B
    1a66:	88 23       	and	r24, r24
    1a68:	41 f0       	breq	.+16     	; 0x1a7a <vTaskDelayUntil+0x4e>
    1a6a:	6b e7       	ldi	r22, 0x7B	; 123
    1a6c:	74 e0       	ldi	r23, 0x04	; 4
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	90 e0       	ldi	r25, 0x00	; 0
    1a72:	48 e4       	ldi	r20, 0x48	; 72
    1a74:	52 e0       	ldi	r21, 0x02	; 2
    1a76:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1a7a:	80 91 7b 1e 	lds	r24, 0x1E7B
    1a7e:	8f 5f       	subi	r24, 0xFF	; 255
    1a80:	80 93 7b 1e 	sts	0x1E7B, r24

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1a84:	40 91 7e 1e 	lds	r20, 0x1E7E
    1a88:	50 91 7f 1e 	lds	r21, 0x1E7F

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1a8c:	28 81       	ld	r18, Y
    1a8e:	39 81       	ldd	r19, Y+1	; 0x01
    1a90:	b9 01       	movw	r22, r18
    1a92:	60 0f       	add	r22, r16
    1a94:	71 1f       	adc	r23, r17

			if( xConstTickCount < *pxPreviousWakeTime )
    1a96:	42 17       	cp	r20, r18
    1a98:	53 07       	cpc	r21, r19
    1a9a:	28 f4       	brcc	.+10     	; 0x1aa6 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1a9c:	62 17       	cp	r22, r18
    1a9e:	73 07       	cpc	r23, r19
    1aa0:	28 f0       	brcs	.+10     	; 0x1aac <vTaskDelayUntil+0x80>
    1aa2:	80 e0       	ldi	r24, 0x00	; 0
    1aa4:	08 c0       	rjmp	.+16     	; 0x1ab6 <vTaskDelayUntil+0x8a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1aa6:	62 17       	cp	r22, r18
    1aa8:	73 07       	cpc	r23, r19
    1aaa:	20 f0       	brcs	.+8      	; 0x1ab4 <vTaskDelayUntil+0x88>
    1aac:	80 e0       	ldi	r24, 0x00	; 0
    1aae:	46 17       	cp	r20, r22
    1ab0:	57 07       	cpc	r21, r23
    1ab2:	08 f4       	brcc	.+2      	; 0x1ab6 <vTaskDelayUntil+0x8a>
    1ab4:	81 e0       	ldi	r24, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1ab6:	79 83       	std	Y+1, r23	; 0x01
    1ab8:	68 83       	st	Y, r22

			if( xShouldDelay != pdFALSE )
    1aba:	88 23       	and	r24, r24
    1abc:	29 f0       	breq	.+10     	; 0x1ac8 <vTaskDelayUntil+0x9c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1abe:	cb 01       	movw	r24, r22
    1ac0:	84 1b       	sub	r24, r20
    1ac2:	95 0b       	sbc	r25, r21
    1ac4:	60 e0       	ldi	r22, 0x00	; 0
    1ac6:	d7 dc       	rcall	.-1618   	; 0x1476 <prvAddCurrentTaskToDelayedList>
    1ac8:	1d df       	rcall	.-454    	; 0x1904 <xTaskResumeAll>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1aca:	88 23       	and	r24, r24
    1acc:	11 f4       	brne	.+4      	; 0x1ad2 <vTaskDelayUntil+0xa6>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ace:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
		{
			portYIELD_WITHIN_API();
    1ad2:	df 91       	pop	r29
    1ad4:	cf 91       	pop	r28
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1ad6:	1f 91       	pop	r17
    1ad8:	0f 91       	pop	r16
    1ada:	08 95       	ret

00001adc <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1adc:	80 91 89 1e 	lds	r24, 0x1E89
    1ae0:	82 30       	cpi	r24, 0x02	; 2
    1ae2:	10 f0       	brcs	.+4      	; 0x1ae8 <prvIdleTask+0xc>
			{
				taskYIELD();
    1ae4:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    1ae8:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vApplicationIdleHook>
    1aec:	f7 cf       	rjmp	.-18     	; 0x1adc <prvIdleTask>

00001aee <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1aee:	4f 92       	push	r4
    1af0:	5f 92       	push	r5
    1af2:	6f 92       	push	r6
    1af4:	7f 92       	push	r7
    1af6:	8f 92       	push	r8
    1af8:	9f 92       	push	r9
    1afa:	af 92       	push	r10
    1afc:	bf 92       	push	r11
    1afe:	cf 92       	push	r12
    1b00:	df 92       	push	r13
    1b02:	ef 92       	push	r14
    1b04:	ff 92       	push	r15
    1b06:	0f 93       	push	r16
    1b08:	1f 93       	push	r17
    1b0a:	cf 93       	push	r28
    1b0c:	df 93       	push	r29
    1b0e:	2c 01       	movw	r4, r24
    1b10:	16 2f       	mov	r17, r22
    1b12:	97 2e       	mov	r9, r23
    1b14:	6a 01       	movw	r12, r20
    1b16:	39 01       	movw	r6, r18
    1b18:	57 01       	movw	r10, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b1a:	ca 01       	movw	r24, r20
    1b1c:	0e 94 a5 02 	call	0x54a	; 0x54a <pvPortMalloc>
    1b20:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1b22:	00 97       	sbiw	r24, 0x00	; 0
    1b24:	99 f0       	breq	.+38     	; 0x1b4c <xTaskCreate+0x5e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1b26:	86 e2       	ldi	r24, 0x26	; 38
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	0e 94 a5 02 	call	0x54a	; 0x54a <pvPortMalloc>
    1b2e:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    1b30:	00 97       	sbiw	r24, 0x00	; 0
    1b32:	49 f0       	breq	.+18     	; 0x1b46 <xTaskCreate+0x58>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1b34:	f8 8e       	std	Y+24, r15	; 0x18
    1b36:	ef 8a       	std	Y+23, r14	; 0x17
    1b38:	81 2f       	mov	r24, r17
    1b3a:	99 2d       	mov	r25, r9
    1b3c:	9c 01       	movw	r18, r24
    1b3e:	f9 01       	movw	r30, r18
    1b40:	de 01       	movw	r26, r28
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	05 c0       	rjmp	.+10     	; 0x1b50 <xTaskCreate+0x62>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1b46:	c7 01       	movw	r24, r14
    1b48:	0e 94 9a 02 	call	0x534	; 0x534 <vPortFree>
    1b4c:	8f ef       	ldi	r24, 0xFF	; 255
    1b4e:	b3 c0       	rjmp	.+358    	; 0x1cb6 <xTaskCreate+0x1c8>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1b50:	80 81       	ld	r24, Z
    1b52:	59 96       	adiw	r26, 0x19	; 25
    1b54:	8c 93       	st	X, r24
    1b56:	59 97       	sbiw	r26, 0x19	; 25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1b58:	80 81       	ld	r24, Z
    1b5a:	88 23       	and	r24, r24
    1b5c:	29 f0       	breq	.+10     	; 0x1b68 <xTaskCreate+0x7a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1b5e:	9f 5f       	subi	r25, 0xFF	; 255
    1b60:	31 96       	adiw	r30, 0x01	; 1
    1b62:	11 96       	adiw	r26, 0x01	; 1
    1b64:	98 30       	cpi	r25, 0x08	; 8
    1b66:	a1 f7       	brne	.-24     	; 0x1b50 <xTaskCreate+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1b68:	18 a2       	std	Y+32, r1	; 0x20
    1b6a:	04 30       	cpi	r16, 0x04	; 4
    1b6c:	08 f0       	brcs	.+2      	; 0x1b70 <xTaskCreate+0x82>
    1b6e:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1b70:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1b72:	72 e0       	ldi	r23, 0x02	; 2
    1b74:	87 2e       	mov	r8, r23
    1b76:	91 2c       	mov	r9, r1
    1b78:	8c 0e       	add	r8, r28
    1b7a:	9d 1e       	adc	r9, r29
    1b7c:	c4 01       	movw	r24, r8
    1b7e:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1b82:	ce 01       	movw	r24, r28
    1b84:	0c 96       	adiw	r24, 0x0c	; 12
    1b86:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1b8a:	d9 87       	std	Y+9, r29	; 0x09
    1b8c:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b8e:	84 e0       	ldi	r24, 0x04	; 4
    1b90:	90 e0       	ldi	r25, 0x00	; 0
    1b92:	80 1b       	sub	r24, r16
    1b94:	91 09       	sbc	r25, r1
    1b96:	9d 87       	std	Y+13, r25	; 0x0d
    1b98:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1b9a:	db 8b       	std	Y+19, r29	; 0x13
    1b9c:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1b9e:	19 a2       	std	Y+33, r1	; 0x21
    1ba0:	1a a2       	std	Y+34, r1	; 0x22
    1ba2:	1b a2       	std	Y+35, r1	; 0x23
    1ba4:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1ba6:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1ba8:	08 94       	sec
    1baa:	c1 08       	sbc	r12, r1
    1bac:	d1 08       	sbc	r13, r1
    1bae:	c7 01       	movw	r24, r14
    1bb0:	8c 0d       	add	r24, r12
    1bb2:	9d 1d       	adc	r25, r13
    1bb4:	b2 01       	movw	r22, r4
    1bb6:	a3 01       	movw	r20, r6
    1bb8:	0e 94 49 01 	call	0x292	; 0x292 <pxPortInitialiseStack>
    1bbc:	99 83       	std	Y+1, r25	; 0x01
    1bbe:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1bc0:	a1 14       	cp	r10, r1
    1bc2:	b1 04       	cpc	r11, r1
    1bc4:	19 f0       	breq	.+6      	; 0x1bcc <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1bc6:	f5 01       	movw	r30, r10
    1bc8:	d1 83       	std	Z+1, r29	; 0x01
    1bca:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1bcc:	0f b6       	in	r0, 0x3f	; 63
    1bce:	f8 94       	cli
    1bd0:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1bd2:	80 91 85 1e 	lds	r24, 0x1E85
    1bd6:	8f 5f       	subi	r24, 0xFF	; 255
    1bd8:	80 93 85 1e 	sts	0x1E85, r24
		if( pxCurrentTCB == NULL )
    1bdc:	80 91 79 1e 	lds	r24, 0x1E79
    1be0:	90 91 7a 1e 	lds	r25, 0x1E7A
    1be4:	89 2b       	or	r24, r25
    1be6:	89 f5       	brne	.+98     	; 0x1c4a <xTaskCreate+0x15c>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1be8:	d0 93 7a 1e 	sts	0x1E7A, r29
    1bec:	c0 93 79 1e 	sts	0x1E79, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1bf0:	80 91 85 1e 	lds	r24, 0x1E85
    1bf4:	81 30       	cpi	r24, 0x01	; 1
    1bf6:	c9 f5       	brne	.+114    	; 0x1c6a <xTaskCreate+0x17c>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1bf8:	89 e8       	ldi	r24, 0x89	; 137
    1bfa:	9e e1       	ldi	r25, 0x1E	; 30
    1bfc:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
    1c00:	82 e9       	ldi	r24, 0x92	; 146
    1c02:	9e e1       	ldi	r25, 0x1E	; 30
    1c04:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
    1c08:	8b e9       	ldi	r24, 0x9B	; 155
    1c0a:	9e e1       	ldi	r25, 0x1E	; 30
    1c0c:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
    1c10:	84 ea       	ldi	r24, 0xA4	; 164
    1c12:	9e e1       	ldi	r25, 0x1E	; 30
    1c14:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    1c18:	6d ea       	ldi	r22, 0xAD	; 173
    1c1a:	e6 2e       	mov	r14, r22
    1c1c:	6e e1       	ldi	r22, 0x1E	; 30
    1c1e:	f6 2e       	mov	r15, r22
    1c20:	c7 01       	movw	r24, r14
    1c22:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1c26:	06 eb       	ldi	r16, 0xB6	; 182
    1c28:	1e e1       	ldi	r17, 0x1E	; 30
    1c2a:	c8 01       	movw	r24, r16
    1c2c:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1c30:	83 ec       	ldi	r24, 0xC3	; 195
    1c32:	9e e1       	ldi	r25, 0x1E	; 30
    1c34:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1c38:	f0 92 c0 1e 	sts	0x1EC0, r15
    1c3c:	e0 92 bf 1e 	sts	0x1EBF, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1c40:	10 93 c2 1e 	sts	0x1EC2, r17
    1c44:	00 93 c1 1e 	sts	0x1EC1, r16
    1c48:	10 c0       	rjmp	.+32     	; 0x1c6a <xTaskCreate+0x17c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1c4a:	80 91 82 1e 	lds	r24, 0x1E82
    1c4e:	88 23       	and	r24, r24
    1c50:	61 f4       	brne	.+24     	; 0x1c6a <xTaskCreate+0x17c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1c52:	e0 91 79 1e 	lds	r30, 0x1E79
    1c56:	f0 91 7a 1e 	lds	r31, 0x1E7A
    1c5a:	96 89       	ldd	r25, Z+22	; 0x16
    1c5c:	8e 89       	ldd	r24, Y+22	; 0x16
    1c5e:	89 17       	cp	r24, r25
    1c60:	20 f0       	brcs	.+8      	; 0x1c6a <xTaskCreate+0x17c>
				{
					pxCurrentTCB = pxNewTCB;
    1c62:	d0 93 7a 1e 	sts	0x1E7A, r29
    1c66:	c0 93 79 1e 	sts	0x1E79, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1c6a:	80 91 88 1e 	lds	r24, 0x1E88
    1c6e:	8f 5f       	subi	r24, 0xFF	; 255
    1c70:	80 93 88 1e 	sts	0x1E88, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1c74:	9e 89       	ldd	r25, Y+22	; 0x16
    1c76:	80 91 7c 1e 	lds	r24, 0x1E7C
    1c7a:	89 17       	cp	r24, r25
    1c7c:	10 f4       	brcc	.+4      	; 0x1c82 <xTaskCreate+0x194>
    1c7e:	90 93 7c 1e 	sts	0x1E7C, r25
    1c82:	89 e0       	ldi	r24, 0x09	; 9
    1c84:	98 9f       	mul	r25, r24
    1c86:	c0 01       	movw	r24, r0
    1c88:	11 24       	eor	r1, r1
    1c8a:	87 57       	subi	r24, 0x77	; 119
    1c8c:	91 4e       	sbci	r25, 0xE1	; 225
    1c8e:	b4 01       	movw	r22, r8
    1c90:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1c94:	0f 90       	pop	r0
    1c96:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1c98:	80 91 82 1e 	lds	r24, 0x1E82
    1c9c:	88 23       	and	r24, r24
    1c9e:	51 f0       	breq	.+20     	; 0x1cb4 <xTaskCreate+0x1c6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1ca0:	e0 91 79 1e 	lds	r30, 0x1E79
    1ca4:	f0 91 7a 1e 	lds	r31, 0x1E7A
    1ca8:	96 89       	ldd	r25, Z+22	; 0x16
    1caa:	8e 89       	ldd	r24, Y+22	; 0x16
    1cac:	98 17       	cp	r25, r24
    1cae:	10 f4       	brcc	.+4      	; 0x1cb4 <xTaskCreate+0x1c6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1cb0:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1cb6:	df 91       	pop	r29
    1cb8:	cf 91       	pop	r28
    1cba:	1f 91       	pop	r17
    1cbc:	0f 91       	pop	r16
    1cbe:	ff 90       	pop	r15
    1cc0:	ef 90       	pop	r14
    1cc2:	df 90       	pop	r13
    1cc4:	cf 90       	pop	r12
    1cc6:	bf 90       	pop	r11
    1cc8:	af 90       	pop	r10
    1cca:	9f 90       	pop	r9
    1ccc:	8f 90       	pop	r8
    1cce:	7f 90       	pop	r7
    1cd0:	6f 90       	pop	r6
    1cd2:	5f 90       	pop	r5
    1cd4:	4f 90       	pop	r4
    1cd6:	08 95       	ret

00001cd8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1cd8:	ef 92       	push	r14
    1cda:	ff 92       	push	r15
    1cdc:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1cde:	8e e6       	ldi	r24, 0x6E	; 110
    1ce0:	9d e0       	ldi	r25, 0x0D	; 13
    1ce2:	63 e6       	ldi	r22, 0x63	; 99
    1ce4:	72 e0       	ldi	r23, 0x02	; 2
    1ce6:	45 e5       	ldi	r20, 0x55	; 85
    1ce8:	50 e0       	ldi	r21, 0x00	; 0
    1cea:	20 e0       	ldi	r18, 0x00	; 0
    1cec:	30 e0       	ldi	r19, 0x00	; 0
    1cee:	00 e0       	ldi	r16, 0x00	; 0
    1cf0:	e6 e8       	ldi	r30, 0x86	; 134
    1cf2:	ee 2e       	mov	r14, r30
    1cf4:	ee e1       	ldi	r30, 0x1E	; 30
    1cf6:	fe 2e       	mov	r15, r30
    1cf8:	fa de       	rcall	.-524    	; 0x1aee <xTaskCreate>
    1cfa:	81 30       	cpi	r24, 0x01	; 1
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
    1cfc:	a1 f4       	brne	.+40     	; 0x1d26 <vTaskStartScheduler+0x4e>
    1cfe:	e8 d0       	rcall	.+464    	; 0x1ed0 <xTimerCreateTimerTask>
		{
			xReturn = xTimerCreateTimerTask();
    1d00:	81 30       	cpi	r24, 0x01	; 1
    1d02:	89 f4       	brne	.+34     	; 0x1d26 <vTaskStartScheduler+0x4e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1d04:	f8 94       	cli
    1d06:	8f ef       	ldi	r24, 0xFF	; 255
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1d08:	9f ef       	ldi	r25, 0xFF	; 255
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1d0a:	90 93 81 1e 	sts	0x1E81, r25
    1d0e:	80 93 80 1e 	sts	0x1E80, r24
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	80 93 82 1e 	sts	0x1E82, r24
		xSchedulerRunning = pdTRUE;
    1d18:	10 92 7f 1e 	sts	0x1E7F, r1
		xTickCount = ( TickType_t ) 0U;
    1d1c:	10 92 7e 1e 	sts	0x1E7E, r1
    1d20:	0e 94 94 01 	call	0x328	; 0x328 <xPortStartScheduler>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d24:	0a c0       	rjmp	.+20     	; 0x1d3a <vTaskStartScheduler+0x62>
    1d26:	8f 3f       	cpi	r24, 0xFF	; 255
    1d28:	41 f4       	brne	.+16     	; 0x1d3a <vTaskStartScheduler+0x62>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1d2a:	64 e8       	ldi	r22, 0x84	; 132
    1d2c:	77 e0       	ldi	r23, 0x07	; 7
    1d2e:	80 e0       	ldi	r24, 0x00	; 0
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	48 e4       	ldi	r20, 0x48	; 72
    1d34:	52 e0       	ldi	r21, 0x02	; 2
    1d36:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>
    1d3a:	0f 91       	pop	r16
    1d3c:	ff 90       	pop	r15
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1d3e:	ef 90       	pop	r14
    1d40:	08 95       	ret

00001d42 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1d42:	9f 92       	push	r9
    1d44:	af 92       	push	r10
    1d46:	bf 92       	push	r11
    1d48:	cf 92       	push	r12
    1d4a:	df 92       	push	r13
    1d4c:	ef 92       	push	r14
    1d4e:	ff 92       	push	r15
    1d50:	0f 93       	push	r16
    1d52:	1f 93       	push	r17
    1d54:	df 93       	push	r29
    1d56:	cf 93       	push	r28
    1d58:	00 d0       	rcall	.+0      	; 0x1d5a <xTimerGenericCommand+0x18>
    1d5a:	0f 92       	push	r0
    1d5c:	0f 92       	push	r0
    1d5e:	cd b7       	in	r28, 0x3d	; 61
    1d60:	de b7       	in	r29, 0x3e	; 62
    1d62:	7c 01       	movw	r14, r24
    1d64:	96 2e       	mov	r9, r22
    1d66:	6a 01       	movw	r12, r20
    1d68:	59 01       	movw	r10, r18
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
    1d6a:	00 97       	sbiw	r24, 0x00	; 0
    1d6c:	41 f4       	brne	.+16     	; 0x1d7e <xTimerGenericCommand+0x3c>
    1d6e:	66 ea       	ldi	r22, 0xA6	; 166
    1d70:	71 e0       	ldi	r23, 0x01	; 1
    1d72:	80 e0       	ldi	r24, 0x00	; 0
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	48 e6       	ldi	r20, 0x68	; 104
    1d78:	52 e0       	ldi	r21, 0x02	; 2
    1d7a:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    1d7e:	80 91 ce 1e 	lds	r24, 0x1ECE
    1d82:	90 91 cf 1e 	lds	r25, 0x1ECF
    1d86:	00 97       	sbiw	r24, 0x00	; 0
    1d88:	11 f4       	brne	.+4      	; 0x1d8e <xTimerGenericCommand+0x4c>
    1d8a:	80 e0       	ldi	r24, 0x00	; 0
    1d8c:	23 c0       	rjmp	.+70     	; 0x1dd4 <xTimerGenericCommand+0x92>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1d8e:	99 82       	std	Y+1, r9	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1d90:	db 82       	std	Y+3, r13	; 0x03
    1d92:	ca 82       	std	Y+2, r12	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1d94:	fd 82       	std	Y+5, r15	; 0x05
    1d96:	ec 82       	std	Y+4, r14	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1d98:	25 e0       	ldi	r18, 0x05	; 5
    1d9a:	29 15       	cp	r18, r9
    1d9c:	a4 f0       	brlt	.+40     	; 0x1dc6 <xTimerGenericCommand+0x84>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1d9e:	41 d8       	rcall	.-3966   	; 0xe22 <xTaskGetSchedulerState>
    1da0:	20 91 ce 1e 	lds	r18, 0x1ECE
    1da4:	30 91 cf 1e 	lds	r19, 0x1ECF
    1da8:	be 01       	movw	r22, r28
    1daa:	6f 5f       	subi	r22, 0xFF	; 255
    1dac:	7f 4f       	sbci	r23, 0xFF	; 255
    1dae:	82 30       	cpi	r24, 0x02	; 2
    1db0:	19 f4       	brne	.+6      	; 0x1db8 <xTimerGenericCommand+0x76>
    1db2:	c9 01       	movw	r24, r18
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1db4:	a8 01       	movw	r20, r16
    1db6:	03 c0       	rjmp	.+6      	; 0x1dbe <xTimerGenericCommand+0x7c>
    1db8:	c9 01       	movw	r24, r18
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1dba:	40 e0       	ldi	r20, 0x00	; 0
    1dbc:	50 e0       	ldi	r21, 0x00	; 0
    1dbe:	20 e0       	ldi	r18, 0x00	; 0
    1dc0:	0e 94 a7 05 	call	0xb4e	; 0xb4e <xQueueGenericSend>
    1dc4:	07 c0       	rjmp	.+14     	; 0x1dd4 <xTimerGenericCommand+0x92>
    1dc6:	be 01       	movw	r22, r28
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1dc8:	6f 5f       	subi	r22, 0xFF	; 255
    1dca:	7f 4f       	sbci	r23, 0xFF	; 255
    1dcc:	a5 01       	movw	r20, r10
    1dce:	20 e0       	ldi	r18, 0x00	; 0
    1dd0:	0e 94 72 04 	call	0x8e4	; 0x8e4 <xQueueGenericSendFromISR>
    1dd4:	0f 90       	pop	r0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    1dd6:	0f 90       	pop	r0
    1dd8:	0f 90       	pop	r0
    1dda:	0f 90       	pop	r0
    1ddc:	0f 90       	pop	r0
    1dde:	cf 91       	pop	r28
    1de0:	df 91       	pop	r29
    1de2:	1f 91       	pop	r17
    1de4:	0f 91       	pop	r16
    1de6:	ff 90       	pop	r15
    1de8:	ef 90       	pop	r14
    1dea:	df 90       	pop	r13
    1dec:	cf 90       	pop	r12
    1dee:	bf 90       	pop	r11
    1df0:	af 90       	pop	r10
    1df2:	9f 90       	pop	r9
    1df4:	08 95       	ret

00001df6 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    1df6:	ef 92       	push	r14
    1df8:	ff 92       	push	r15
    1dfa:	0f 93       	push	r16
    1dfc:	1f 93       	push	r17
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    1dfe:	0f b6       	in	r0, 0x3f	; 63
    1e00:	f8 94       	cli
    1e02:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    1e04:	80 91 ce 1e 	lds	r24, 0x1ECE
    1e08:	90 91 cf 1e 	lds	r25, 0x1ECF
    1e0c:	89 2b       	or	r24, r25
    1e0e:	e9 f4       	brne	.+58     	; 0x1e4a <prvCheckForValidListAndQueue+0x54>
		{
			vListInitialise( &xActiveTimerList1 );
    1e10:	82 ed       	ldi	r24, 0xD2	; 210
    1e12:	e8 2e       	mov	r14, r24
    1e14:	8e e1       	ldi	r24, 0x1E	; 30
    1e16:	f8 2e       	mov	r15, r24
    1e18:	c7 01       	movw	r24, r14
    1e1a:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    1e1e:	0b ed       	ldi	r16, 0xDB	; 219
    1e20:	1e e1       	ldi	r17, 0x1E	; 30
    1e22:	c8 01       	movw	r24, r16
    1e24:	0e 94 d6 02 	call	0x5ac	; 0x5ac <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    1e28:	f0 92 e5 1e 	sts	0x1EE5, r15
    1e2c:	e0 92 e4 1e 	sts	0x1EE4, r14
			pxOverflowTimerList = &xActiveTimerList2;
    1e30:	10 93 e7 1e 	sts	0x1EE7, r17
    1e34:	00 93 e6 1e 	sts	0x1EE6, r16

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1e38:	84 e1       	ldi	r24, 0x14	; 20
    1e3a:	65 e0       	ldi	r22, 0x05	; 5
    1e3c:	40 e0       	ldi	r20, 0x00	; 0
    1e3e:	0e 94 cc 06 	call	0xd98	; 0xd98 <xQueueGenericCreate>
    1e42:	90 93 cf 1e 	sts	0x1ECF, r25
    1e46:	80 93 ce 1e 	sts	0x1ECE, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1e4a:	0f 90       	pop	r0
    1e4c:	0f be       	out	0x3f, r0	; 63
}
    1e4e:	1f 91       	pop	r17
    1e50:	0f 91       	pop	r16
    1e52:	ff 90       	pop	r15
    1e54:	ef 90       	pop	r14
    1e56:	08 95       	ret

00001e58 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1e58:	9f 92       	push	r9
    1e5a:	af 92       	push	r10
    1e5c:	bf 92       	push	r11
    1e5e:	cf 92       	push	r12
    1e60:	df 92       	push	r13
    1e62:	ef 92       	push	r14
    1e64:	ff 92       	push	r15
    1e66:	0f 93       	push	r16
    1e68:	1f 93       	push	r17
    1e6a:	cf 93       	push	r28
    1e6c:	df 93       	push	r29
    1e6e:	6c 01       	movw	r12, r24
    1e70:	7b 01       	movw	r14, r22
    1e72:	94 2e       	mov	r9, r20
    1e74:	59 01       	movw	r10, r18
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    1e76:	83 e1       	ldi	r24, 0x13	; 19
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	0e 94 a5 02 	call	0x54a	; 0x54a <pvPortMalloc>
    1e7e:	ec 01       	movw	r28, r24

		if( pxNewTimer != NULL )
    1e80:	00 97       	sbiw	r24, 0x00	; 0
    1e82:	c9 f0       	breq	.+50     	; 0x1eb6 <xTimerCreate+0x5e>
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
    1e84:	e1 14       	cp	r14, r1
    1e86:	f1 04       	cpc	r15, r1
    1e88:	41 f4       	brne	.+16     	; 0x1e9a <xTimerCreate+0x42>
    1e8a:	6c e8       	ldi	r22, 0x8C	; 140
    1e8c:	71 e0       	ldi	r23, 0x01	; 1
    1e8e:	80 e0       	ldi	r24, 0x00	; 0
    1e90:	90 e0       	ldi	r25, 0x00	; 0
    1e92:	48 e6       	ldi	r20, 0x68	; 104
    1e94:	52 e0       	ldi	r21, 0x02	; 2
    1e96:	0e 94 5c 17 	call	0x2eb8	; 0x2eb8 <vAssertCalled>

	if( pxNewTimer != NULL )
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
    1e9a:	ad df       	rcall	.-166    	; 0x1df6 <prvCheckForValidListAndQueue>
    1e9c:	d9 82       	std	Y+1, r13	; 0x01

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
    1e9e:	c8 82       	st	Y, r12
    1ea0:	fd 86       	std	Y+13, r15	; 0x0d
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    1ea2:	ec 86       	std	Y+12, r14	; 0x0c
    1ea4:	9e 86       	std	Y+14, r9	; 0x0e
		pxNewTimer->uxAutoReload = uxAutoReload;
    1ea6:	b8 8a       	std	Y+16, r11	; 0x10
		pxNewTimer->pvTimerID = pvTimerID;
    1ea8:	af 86       	std	Y+15, r10	; 0x0f
    1eaa:	1a 8b       	std	Y+18, r17	; 0x12
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    1eac:	09 8b       	std	Y+17, r16	; 0x11
    1eae:	ce 01       	movw	r24, r28
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    1eb0:	02 96       	adiw	r24, 0x02	; 2
    1eb2:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialiseItem>
    1eb6:	ce 01       	movw	r24, r28
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    1eb8:	df 91       	pop	r29
    1eba:	cf 91       	pop	r28
    1ebc:	1f 91       	pop	r17
    1ebe:	0f 91       	pop	r16
    1ec0:	ff 90       	pop	r15
    1ec2:	ef 90       	pop	r14
    1ec4:	df 90       	pop	r13
    1ec6:	cf 90       	pop	r12
    1ec8:	bf 90       	pop	r11
    1eca:	af 90       	pop	r10
    1ecc:	9f 90       	pop	r9
    1ece:	08 95       	ret

00001ed0 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    1ed0:	ef 92       	push	r14
    1ed2:	ff 92       	push	r15
    1ed4:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    1ed6:	8f df       	rcall	.-226    	; 0x1df6 <prvCheckForValidListAndQueue>
    1ed8:	80 91 ce 1e 	lds	r24, 0x1ECE

	if( xTimerQueue != NULL )
    1edc:	90 91 cf 1e 	lds	r25, 0x1ECF
    1ee0:	89 2b       	or	r24, r25
    1ee2:	81 f0       	breq	.+32     	; 0x1f04 <xTimerCreateTimerTask+0x34>
    1ee4:	8f e2       	ldi	r24, 0x2F	; 47
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    1ee6:	90 e1       	ldi	r25, 0x10	; 16
    1ee8:	64 e8       	ldi	r22, 0x84	; 132
    1eea:	72 e0       	ldi	r23, 0x02	; 2
    1eec:	4a ea       	ldi	r20, 0xAA	; 170
    1eee:	50 e0       	ldi	r21, 0x00	; 0
    1ef0:	20 e0       	ldi	r18, 0x00	; 0
    1ef2:	30 e0       	ldi	r19, 0x00	; 0
    1ef4:	03 e0       	ldi	r16, 0x03	; 3
    1ef6:	ec ec       	ldi	r30, 0xCC	; 204
    1ef8:	ee 2e       	mov	r14, r30
    1efa:	ee e1       	ldi	r30, 0x1E	; 30
    1efc:	fe 2e       	mov	r15, r30
    1efe:	f7 dd       	rcall	.-1042   	; 0x1aee <xTaskCreate>
    1f00:	88 23       	and	r24, r24
    1f02:	41 f4       	brne	.+16     	; 0x1f14 <xTimerCreateTimerTask+0x44>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
    1f04:	63 e3       	ldi	r22, 0x33	; 51
    1f06:	71 e0       	ldi	r23, 0x01	; 1
    1f08:	80 e0       	ldi	r24, 0x00	; 0
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	48 e6       	ldi	r20, 0x68	; 104
    1f0e:	52 e0       	ldi	r21, 0x02	; 2
    1f10:	d3 d7       	rcall	.+4006   	; 0x2eb8 <vAssertCalled>
    1f12:	80 e0       	ldi	r24, 0x00	; 0
    1f14:	0f 91       	pop	r16
    1f16:	ff 90       	pop	r15
    1f18:	ef 90       	pop	r14
	return xReturn;
}
    1f1a:	08 95       	ret

00001f1c <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    1f1c:	af 92       	push	r10
    1f1e:	bf 92       	push	r11
    1f20:	cf 92       	push	r12
    1f22:	df 92       	push	r13
    1f24:	ef 92       	push	r14
    1f26:	ff 92       	push	r15
    1f28:	0f 93       	push	r16
    1f2a:	1f 93       	push	r17
    1f2c:	cf 93       	push	r28
    1f2e:	df 93       	push	r29
    1f30:	5c 01       	movw	r10, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    1f32:	0e 94 02 07 	call	0xe04	; 0xe04 <xTaskGetTickCount>
    1f36:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    1f38:	80 91 d0 1e 	lds	r24, 0x1ED0
    1f3c:	90 91 d1 1e 	lds	r25, 0x1ED1
    1f40:	e8 16       	cp	r14, r24
    1f42:	f9 06       	cpc	r15, r25
    1f44:	d8 f1       	brcs	.+118    	; 0x1fbc <prvSampleTimeNow+0xa0>
    1f46:	52 c0       	rjmp	.+164    	; 0x1fec <prvSampleTimeNow+0xd0>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1f48:	05 80       	ldd	r0, Z+5	; 0x05
    1f4a:	f6 81       	ldd	r31, Z+6	; 0x06
    1f4c:	e0 2d       	mov	r30, r0
    1f4e:	00 81       	ld	r16, Z
    1f50:	11 81       	ldd	r17, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1f52:	c6 81       	ldd	r28, Z+6	; 0x06
    1f54:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1f56:	f2 e0       	ldi	r31, 0x02	; 2
    1f58:	cf 2e       	mov	r12, r31
    1f5a:	d1 2c       	mov	r13, r1
    1f5c:	cc 0e       	add	r12, r28
    1f5e:	dd 1e       	adc	r13, r29
    1f60:	c6 01       	movw	r24, r12
    1f62:	0e 94 3b 03 	call	0x676	; 0x676 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1f66:	e9 89       	ldd	r30, Y+17	; 0x11
    1f68:	fa 89       	ldd	r31, Y+18	; 0x12
    1f6a:	ce 01       	movw	r24, r28
    1f6c:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1f6e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f70:	81 30       	cpi	r24, 0x01	; 1
    1f72:	21 f5       	brne	.+72     	; 0x1fbc <prvSampleTimeNow+0xa0>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1f74:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f76:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f78:	80 0f       	add	r24, r16
    1f7a:	91 1f       	adc	r25, r17
			if( xReloadTime > xNextExpireTime )
    1f7c:	08 17       	cp	r16, r24
    1f7e:	19 07       	cpc	r17, r25
    1f80:	60 f4       	brcc	.+24     	; 0x1f9a <prvSampleTimeNow+0x7e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1f82:	9b 83       	std	Y+3, r25	; 0x03
    1f84:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1f86:	d9 87       	std	Y+9, r29	; 0x09
    1f88:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1f8a:	80 91 e4 1e 	lds	r24, 0x1EE4
    1f8e:	90 91 e5 1e 	lds	r25, 0x1EE5
    1f92:	b6 01       	movw	r22, r12
    1f94:	0e 94 09 03 	call	0x612	; 0x612 <vListInsert>
    1f98:	11 c0       	rjmp	.+34     	; 0x1fbc <prvSampleTimeNow+0xa0>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1f9a:	ce 01       	movw	r24, r28
    1f9c:	60 e0       	ldi	r22, 0x00	; 0
    1f9e:	a8 01       	movw	r20, r16
    1fa0:	20 e0       	ldi	r18, 0x00	; 0
    1fa2:	30 e0       	ldi	r19, 0x00	; 0
    1fa4:	00 e0       	ldi	r16, 0x00	; 0
    1fa6:	10 e0       	ldi	r17, 0x00	; 0
    1fa8:	cc de       	rcall	.-616    	; 0x1d42 <xTimerGenericCommand>
    1faa:	88 23       	and	r24, r24
				configASSERT( xResult );
    1fac:	39 f4       	brne	.+14     	; 0x1fbc <prvSampleTimeNow+0xa0>
    1fae:	62 e9       	ldi	r22, 0x92	; 146
    1fb0:	73 e0       	ldi	r23, 0x03	; 3
    1fb2:	80 e0       	ldi	r24, 0x00	; 0
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	48 e6       	ldi	r20, 0x68	; 104
    1fb8:	52 e0       	ldi	r21, 0x02	; 2
    1fba:	7e d7       	rcall	.+3836   	; 0x2eb8 <vAssertCalled>
    1fbc:	e0 91 e4 1e 	lds	r30, 0x1EE4

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1fc0:	f0 91 e5 1e 	lds	r31, 0x1EE5
    1fc4:	80 81       	ld	r24, Z
    1fc6:	88 23       	and	r24, r24
    1fc8:	09 f0       	breq	.+2      	; 0x1fcc <prvSampleTimeNow+0xb0>
    1fca:	be cf       	rjmp	.-132    	; 0x1f48 <prvSampleTimeNow+0x2c>
    1fcc:	80 91 e6 1e 	lds	r24, 0x1EE6
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    1fd0:	90 91 e7 1e 	lds	r25, 0x1EE7
    1fd4:	90 93 e5 1e 	sts	0x1EE5, r25
    1fd8:	80 93 e4 1e 	sts	0x1EE4, r24
    1fdc:	f0 93 e7 1e 	sts	0x1EE7, r31
	pxOverflowTimerList = pxTemp;
    1fe0:	e0 93 e6 1e 	sts	0x1EE6, r30
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	f5 01       	movw	r30, r10
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    1fe8:	80 83       	st	Z, r24
    1fea:	02 c0       	rjmp	.+4      	; 0x1ff0 <prvSampleTimeNow+0xd4>
    1fec:	f5 01       	movw	r30, r10
    1fee:	10 82       	st	Z, r1
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    1ff0:	f0 92 d1 1e 	sts	0x1ED1, r15
	}

	xLastTime = xTimeNow;
    1ff4:	e0 92 d0 1e 	sts	0x1ED0, r14
    1ff8:	c7 01       	movw	r24, r14
    1ffa:	df 91       	pop	r29

	return xTimeNow;
}
    1ffc:	cf 91       	pop	r28
    1ffe:	1f 91       	pop	r17
    2000:	0f 91       	pop	r16
    2002:	ff 90       	pop	r15
    2004:	ef 90       	pop	r14
    2006:	df 90       	pop	r13
    2008:	cf 90       	pop	r12
    200a:	bf 90       	pop	r11
    200c:	af 90       	pop	r10
    200e:	08 95       	ret

00002010 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2010:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2012:	73 83       	std	Z+3, r23	; 0x03
    2014:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2016:	91 87       	std	Z+9, r25	; 0x09
    2018:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    201a:	46 17       	cp	r20, r22
    201c:	57 07       	cpc	r21, r23
    201e:	68 f0       	brcs	.+26     	; 0x203a <prvInsertTimerInActiveList+0x2a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2020:	42 1b       	sub	r20, r18
    2022:	53 0b       	sbc	r21, r19
    2024:	84 85       	ldd	r24, Z+12	; 0x0c
    2026:	95 85       	ldd	r25, Z+13	; 0x0d
    2028:	48 17       	cp	r20, r24
    202a:	59 07       	cpc	r21, r25
    202c:	b0 f4       	brcc	.+44     	; 0x205a <prvInsertTimerInActiveList+0x4a>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    202e:	32 96       	adiw	r30, 0x02	; 2
    2030:	80 91 e6 1e 	lds	r24, 0x1EE6
    2034:	90 91 e7 1e 	lds	r25, 0x1EE7
    2038:	0b c0       	rjmp	.+22     	; 0x2050 <prvInsertTimerInActiveList+0x40>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    203a:	42 17       	cp	r20, r18
    203c:	53 07       	cpc	r21, r19
    203e:	18 f4       	brcc	.+6      	; 0x2046 <prvInsertTimerInActiveList+0x36>
    2040:	62 17       	cp	r22, r18
    2042:	73 07       	cpc	r23, r19
    2044:	50 f4       	brcc	.+20     	; 0x205a <prvInsertTimerInActiveList+0x4a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2046:	32 96       	adiw	r30, 0x02	; 2
    2048:	80 91 e4 1e 	lds	r24, 0x1EE4
    204c:	90 91 e5 1e 	lds	r25, 0x1EE5
    2050:	bf 01       	movw	r22, r30
    2052:	0e 94 09 03 	call	0x612	; 0x612 <vListInsert>
    2056:	80 e0       	ldi	r24, 0x00	; 0
    2058:	08 95       	ret
    205a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}

	return xProcessTimerNow;
}
    205c:	08 95       	ret

0000205e <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    205e:	8f 92       	push	r8
    2060:	9f 92       	push	r9
    2062:	af 92       	push	r10
    2064:	bf 92       	push	r11
    2066:	cf 92       	push	r12
    2068:	df 92       	push	r13
    206a:	ef 92       	push	r14
    206c:	ff 92       	push	r15
    206e:	0f 93       	push	r16
    2070:	1f 93       	push	r17
    2072:	df 93       	push	r29
    2074:	cf 93       	push	r28
    2076:	00 d0       	rcall	.+0      	; 0x2078 <prvTimerTask+0x1a>
    2078:	00 d0       	rcall	.+0      	; 0x207a <prvTimerTask+0x1c>
    207a:	cd b7       	in	r28, 0x3d	; 61
    207c:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    207e:	5e 01       	movw	r10, r28
    2080:	08 94       	sec
    2082:	a1 1c       	adc	r10, r1
    2084:	b1 1c       	adc	r11, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2086:	a2 e0       	ldi	r26, 0x02	; 2
    2088:	8a 2e       	mov	r8, r26
    208a:	91 2c       	mov	r9, r1
    208c:	8c 0e       	add	r8, r28
    208e:	9d 1e       	adc	r9, r29
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2090:	e0 91 e4 1e 	lds	r30, 0x1EE4
    2094:	f0 91 e5 1e 	lds	r31, 0x1EE5
    2098:	ff 24       	eor	r15, r15
    209a:	80 81       	ld	r24, Z
    209c:	88 23       	and	r24, r24
    209e:	29 f4       	brne	.+10     	; 0x20aa <prvTimerTask+0x4c>
    20a0:	ff 24       	eor	r15, r15
    20a2:	f3 94       	inc	r15
	if( *pxListWasEmpty == pdFALSE )
    20a4:	00 e0       	ldi	r16, 0x00	; 0
    20a6:	10 e0       	ldi	r17, 0x00	; 0
    20a8:	05 c0       	rjmp	.+10     	; 0x20b4 <prvTimerTask+0x56>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    20aa:	05 80       	ldd	r0, Z+5	; 0x05
    20ac:	f6 81       	ldd	r31, Z+6	; 0x06
    20ae:	e0 2d       	mov	r30, r0
    20b0:	00 81       	ld	r16, Z
    20b2:	11 81       	ldd	r17, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    20b4:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    20b8:	c5 01       	movw	r24, r10
    20ba:	30 df       	rcall	.-416    	; 0x1f1c <prvSampleTimeNow>
    20bc:	6c 01       	movw	r12, r24
    20be:	89 81       	ldd	r24, Y+1	; 0x01
		if( xTimerListsWereSwitched == pdFALSE )
    20c0:	88 23       	and	r24, r24
    20c2:	09 f0       	breq	.+2      	; 0x20c6 <prvTimerTask+0x68>
    20c4:	5b c0       	rjmp	.+182    	; 0x217c <prvTimerTask+0x11e>
    20c6:	ff 20       	and	r15, r15
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    20c8:	09 f0       	breq	.+2      	; 0x20cc <prvTimerTask+0x6e>
    20ca:	3d c0       	rjmp	.+122    	; 0x2146 <prvTimerTask+0xe8>
    20cc:	c0 16       	cp	r12, r16
    20ce:	d1 06       	cpc	r13, r17
    20d0:	08 f4       	brcc	.+2      	; 0x20d4 <prvTimerTask+0x76>
    20d2:	43 c0       	rjmp	.+134    	; 0x215a <prvTimerTask+0xfc>
    20d4:	17 dc       	rcall	.-2002   	; 0x1904 <xTaskResumeAll>
			{
				( void ) xTaskResumeAll();
    20d6:	e0 91 e4 1e 	lds	r30, 0x1EE4
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    20da:	f0 91 e5 1e 	lds	r31, 0x1EE5
    20de:	05 80       	ldd	r0, Z+5	; 0x05
    20e0:	f6 81       	ldd	r31, Z+6	; 0x06
    20e2:	e0 2d       	mov	r30, r0
    20e4:	e6 80       	ldd	r14, Z+6	; 0x06
    20e6:	f7 80       	ldd	r15, Z+7	; 0x07
    20e8:	c7 01       	movw	r24, r14
    20ea:	02 96       	adiw	r24, 0x02	; 2

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    20ec:	0e 94 3b 03 	call	0x676	; 0x676 <uxListRemove>
    20f0:	d7 01       	movw	r26, r14
    20f2:	1e 96       	adiw	r26, 0x0e	; 14
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    20f4:	8c 91       	ld	r24, X
    20f6:	1e 97       	sbiw	r26, 0x0e	; 14
    20f8:	81 30       	cpi	r24, 0x01	; 1
    20fa:	e9 f4       	brne	.+58     	; 0x2136 <prvTimerTask+0xd8>
    20fc:	1c 96       	adiw	r26, 0x0c	; 12
    20fe:	6d 91       	ld	r22, X+
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2100:	7c 91       	ld	r23, X
    2102:	1d 97       	sbiw	r26, 0x0d	; 13
    2104:	60 0f       	add	r22, r16
    2106:	71 1f       	adc	r23, r17
    2108:	c7 01       	movw	r24, r14
    210a:	a6 01       	movw	r20, r12
    210c:	98 01       	movw	r18, r16
    210e:	80 df       	rcall	.-256    	; 0x2010 <prvInsertTimerInActiveList>
    2110:	88 23       	and	r24, r24
    2112:	89 f0       	breq	.+34     	; 0x2136 <prvTimerTask+0xd8>
    2114:	c7 01       	movw	r24, r14
    2116:	60 e0       	ldi	r22, 0x00	; 0
    2118:	a8 01       	movw	r20, r16
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    211a:	20 e0       	ldi	r18, 0x00	; 0
    211c:	30 e0       	ldi	r19, 0x00	; 0
    211e:	00 e0       	ldi	r16, 0x00	; 0
    2120:	10 e0       	ldi	r17, 0x00	; 0
    2122:	0f de       	rcall	.-994    	; 0x1d42 <xTimerGenericCommand>
    2124:	88 23       	and	r24, r24
    2126:	39 f4       	brne	.+14     	; 0x2136 <prvTimerTask+0xd8>
    2128:	68 e0       	ldi	r22, 0x08	; 8
    212a:	72 e0       	ldi	r23, 0x02	; 2
			configASSERT( xResult );
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	48 e6       	ldi	r20, 0x68	; 104
    2132:	52 e0       	ldi	r21, 0x02	; 2
    2134:	c1 d6       	rcall	.+3458   	; 0x2eb8 <vAssertCalled>
    2136:	d7 01       	movw	r26, r14
    2138:	51 96       	adiw	r26, 0x11	; 17
    213a:	ed 91       	ld	r30, X+
    213c:	fc 91       	ld	r31, X
    213e:	52 97       	sbiw	r26, 0x12	; 18
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2140:	c7 01       	movw	r24, r14
    2142:	19 95       	eicall
    2144:	90 c0       	rjmp	.+288    	; 0x2266 <__stack+0x67>
    2146:	ff 24       	eor	r15, r15
    2148:	e0 91 e6 1e 	lds	r30, 0x1EE6
    214c:	f0 91 e7 1e 	lds	r31, 0x1EE7
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2150:	80 81       	ld	r24, Z
    2152:	88 23       	and	r24, r24
    2154:	11 f4       	brne	.+4      	; 0x215a <prvTimerTask+0xfc>
    2156:	ff 24       	eor	r15, r15
    2158:	f3 94       	inc	r15
    215a:	0c 19       	sub	r16, r12
    215c:	1d 09       	sbc	r17, r13
    215e:	80 91 ce 1e 	lds	r24, 0x1ECE
    2162:	90 91 cf 1e 	lds	r25, 0x1ECF
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2166:	b8 01       	movw	r22, r16
    2168:	4f 2d       	mov	r20, r15
    216a:	0e 94 a3 03 	call	0x746	; 0x746 <vQueueWaitForMessageRestricted>
    216e:	ca db       	rcall	.-2156   	; 0x1904 <xTaskResumeAll>
    2170:	88 23       	and	r24, r24
    2172:	09 f0       	breq	.+2      	; 0x2176 <prvTimerTask+0x118>
    2174:	78 c0       	rjmp	.+240    	; 0x2266 <__stack+0x67>
    2176:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>

				if( xTaskResumeAll() == pdFALSE )
    217a:	75 c0       	rjmp	.+234    	; 0x2266 <__stack+0x67>
    217c:	c3 db       	rcall	.-2170   	; 0x1904 <xTaskResumeAll>
    217e:	73 c0       	rjmp	.+230    	; 0x2266 <__stack+0x67>
    2180:	8a 81       	ldd	r24, Y+2	; 0x02
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2182:	87 fd       	sbrc	r24, 7
    2184:	70 c0       	rjmp	.+224    	; 0x2266 <__stack+0x67>
    2186:	0d 81       	ldd	r16, Y+5	; 0x05
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2188:	1e 81       	ldd	r17, Y+6	; 0x06
    218a:	f8 01       	movw	r30, r16
    218c:	82 85       	ldd	r24, Z+10	; 0x0a
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    218e:	93 85       	ldd	r25, Z+11	; 0x0b
    2190:	89 2b       	or	r24, r25
    2192:	21 f0       	breq	.+8      	; 0x219c <prvTimerTask+0x13e>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2194:	c8 01       	movw	r24, r16
    2196:	02 96       	adiw	r24, 0x02	; 2

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2198:	0e 94 3b 03 	call	0x676	; 0x676 <uxListRemove>
    219c:	c5 01       	movw	r24, r10
    219e:	be de       	rcall	.-644    	; 0x1f1c <prvSampleTimeNow>
    21a0:	7c 01       	movw	r14, r24
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    21a2:	8a 81       	ldd	r24, Y+2	; 0x02
    21a4:	85 30       	cpi	r24, 0x05	; 5
    21a6:	09 f4       	brne	.+2      	; 0x21aa <prvTimerTask+0x14c>
    21a8:	5b c0       	rjmp	.+182    	; 0x2260 <__stack+0x61>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    21aa:	86 30       	cpi	r24, 0x06	; 6
    21ac:	44 f4       	brge	.+16     	; 0x21be <prvTimerTask+0x160>
    21ae:	87 fd       	sbrc	r24, 7
    21b0:	5a c0       	rjmp	.+180    	; 0x2266 <__stack+0x67>

			switch( xMessage.xMessageID )
    21b2:	83 30       	cpi	r24, 0x03	; 3
    21b4:	54 f0       	brlt	.+20     	; 0x21ca <prvTimerTask+0x16c>
    21b6:	84 30       	cpi	r24, 0x04	; 4
    21b8:	09 f0       	breq	.+2      	; 0x21bc <prvTimerTask+0x15e>
    21ba:	55 c0       	rjmp	.+170    	; 0x2266 <__stack+0x67>
    21bc:	37 c0       	rjmp	.+110    	; 0x222c <__stack+0x2d>
    21be:	88 30       	cpi	r24, 0x08	; 8
    21c0:	24 f0       	brlt	.+8      	; 0x21ca <prvTimerTask+0x16c>
    21c2:	89 30       	cpi	r24, 0x09	; 9
    21c4:	09 f0       	breq	.+2      	; 0x21c8 <prvTimerTask+0x16a>
    21c6:	4f c0       	rjmp	.+158    	; 0x2266 <__stack+0x67>
    21c8:	31 c0       	rjmp	.+98     	; 0x222c <__stack+0x2d>
    21ca:	2b 81       	ldd	r18, Y+3	; 0x03
    21cc:	3c 81       	ldd	r19, Y+4	; 0x04
    21ce:	d8 01       	movw	r26, r16
    21d0:	1c 96       	adiw	r26, 0x0c	; 12
    21d2:	6d 91       	ld	r22, X+
    21d4:	7c 91       	ld	r23, X
    21d6:	1d 97       	sbiw	r26, 0x0d	; 13
    21d8:	62 0f       	add	r22, r18
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    21da:	73 1f       	adc	r23, r19
    21dc:	c8 01       	movw	r24, r16
    21de:	a7 01       	movw	r20, r14
    21e0:	17 df       	rcall	.-466    	; 0x2010 <prvInsertTimerInActiveList>
    21e2:	88 23       	and	r24, r24
    21e4:	09 f4       	brne	.+2      	; 0x21e8 <prvTimerTask+0x18a>
    21e6:	3f c0       	rjmp	.+126    	; 0x2266 <__stack+0x67>
    21e8:	d8 01       	movw	r26, r16
    21ea:	51 96       	adiw	r26, 0x11	; 17
    21ec:	ed 91       	ld	r30, X+
    21ee:	fc 91       	ld	r31, X
    21f0:	52 97       	sbiw	r26, 0x12	; 18
    21f2:	c8 01       	movw	r24, r16
    21f4:	19 95       	eicall
    21f6:	f8 01       	movw	r30, r16
    21f8:	86 85       	ldd	r24, Z+14	; 0x0e
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    21fa:	81 30       	cpi	r24, 0x01	; 1
    21fc:	a1 f5       	brne	.+104    	; 0x2266 <__stack+0x67>
    21fe:	44 85       	ldd	r20, Z+12	; 0x0c
    2200:	55 85       	ldd	r21, Z+13	; 0x0d
    2202:	8b 81       	ldd	r24, Y+3	; 0x03
    2204:	9c 81       	ldd	r25, Y+4	; 0x04
    2206:	48 0f       	add	r20, r24
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2208:	59 1f       	adc	r21, r25
    220a:	c8 01       	movw	r24, r16
    220c:	60 e0       	ldi	r22, 0x00	; 0
    220e:	20 e0       	ldi	r18, 0x00	; 0
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2210:	30 e0       	ldi	r19, 0x00	; 0
    2212:	00 e0       	ldi	r16, 0x00	; 0
    2214:	10 e0       	ldi	r17, 0x00	; 0
    2216:	95 dd       	rcall	.-1238   	; 0x1d42 <xTimerGenericCommand>
    2218:	88 23       	and	r24, r24
    221a:	29 f5       	brne	.+74     	; 0x2266 <__stack+0x67>
    221c:	61 e2       	ldi	r22, 0x21	; 33
    221e:	73 e0       	ldi	r23, 0x03	; 3
    2220:	80 e0       	ldi	r24, 0x00	; 0
    2222:	90 e0       	ldi	r25, 0x00	; 0
    2224:	48 e6       	ldi	r20, 0x68	; 104
    2226:	52 e0       	ldi	r21, 0x02	; 2
    2228:	47 d6       	rcall	.+3214   	; 0x2eb8 <vAssertCalled>
    222a:	1d c0       	rjmp	.+58     	; 0x2266 <__stack+0x67>
							configASSERT( xResult );
    222c:	8b 81       	ldd	r24, Y+3	; 0x03
    222e:	9c 81       	ldd	r25, Y+4	; 0x04
    2230:	d8 01       	movw	r26, r16
    2232:	1d 96       	adiw	r26, 0x0d	; 13
    2234:	9c 93       	st	X, r25
    2236:	8e 93       	st	-X, r24
    2238:	1c 97       	sbiw	r26, 0x0c	; 12
    223a:	89 2b       	or	r24, r25
    223c:	39 f4       	brne	.+14     	; 0x224c <__stack+0x4d>
    223e:	68 e3       	ldi	r22, 0x38	; 56
    2240:	73 e0       	ldi	r23, 0x03	; 3
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2242:	80 e0       	ldi	r24, 0x00	; 0
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	48 e6       	ldi	r20, 0x68	; 104
    2248:	52 e0       	ldi	r21, 0x02	; 2
    224a:	36 d6       	rcall	.+3180   	; 0x2eb8 <vAssertCalled>
    224c:	f8 01       	movw	r30, r16
    224e:	64 85       	ldd	r22, Z+12	; 0x0c
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    2250:	75 85       	ldd	r23, Z+13	; 0x0d
    2252:	6e 0d       	add	r22, r14
    2254:	7f 1d       	adc	r23, r15
    2256:	c8 01       	movw	r24, r16
    2258:	a7 01       	movw	r20, r14
    225a:	97 01       	movw	r18, r14
    225c:	d9 de       	rcall	.-590    	; 0x2010 <prvInsertTimerInActiveList>
    225e:	03 c0       	rjmp	.+6      	; 0x2266 <__stack+0x67>
    2260:	c8 01       	movw	r24, r16
    2262:	0e 94 9a 02 	call	0x534	; 0x534 <vPortFree>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2266:	80 91 ce 1e 	lds	r24, 0x1ECE
    226a:	90 91 cf 1e 	lds	r25, 0x1ECF
    226e:	b4 01       	movw	r22, r8
    2270:	40 e0       	ldi	r20, 0x00	; 0
    2272:	50 e0       	ldi	r21, 0x00	; 0
    2274:	20 e0       	ldi	r18, 0x00	; 0
    2276:	0e 94 cf 04 	call	0x99e	; 0x99e <xQueueGenericReceive>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    227a:	88 23       	and	r24, r24
    227c:	09 f0       	breq	.+2      	; 0x2280 <__stack+0x81>
    227e:	80 cf       	rjmp	.-256    	; 0x2180 <prvTimerTask+0x122>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2280:	07 cf       	rjmp	.-498    	; 0x2090 <prvTimerTask+0x32>

00002282 <xAreTaskNotificationTasksStillRunning>:
static uint32_t ulLastNotifyCycleCount = 0;
const uint32_t ulMaxSendReceiveDeviation = 5UL;

	/* Check the cycle count is still incrementing to ensure the task is still
	actually running. */
	if( ulLastNotifyCycleCount == ulNotifyCycleCount )
    2282:	20 91 e8 1e 	lds	r18, 0x1EE8
    2286:	30 91 e9 1e 	lds	r19, 0x1EE9
    228a:	40 91 ea 1e 	lds	r20, 0x1EEA
    228e:	50 91 eb 1e 	lds	r21, 0x1EEB
    2292:	80 91 f4 1e 	lds	r24, 0x1EF4
    2296:	90 91 f5 1e 	lds	r25, 0x1EF5
    229a:	a0 91 f6 1e 	lds	r26, 0x1EF6
    229e:	b0 91 f7 1e 	lds	r27, 0x1EF7
    22a2:	82 17       	cp	r24, r18
    22a4:	93 07       	cpc	r25, r19
    22a6:	a4 07       	cpc	r26, r20
    22a8:	b5 07       	cpc	r27, r21
    22aa:	19 f4       	brne	.+6      	; 0x22b2 <xAreTaskNotificationTasksStillRunning+0x30>
	{
		xErrorStatus = pdFAIL;
    22ac:	10 92 13 03 	sts	0x0313, r1
    22b0:	10 c0       	rjmp	.+32     	; 0x22d2 <xAreTaskNotificationTasksStillRunning+0x50>
	}
	else
	{
		ulLastNotifyCycleCount = ulNotifyCycleCount;
    22b2:	80 91 e8 1e 	lds	r24, 0x1EE8
    22b6:	90 91 e9 1e 	lds	r25, 0x1EE9
    22ba:	a0 91 ea 1e 	lds	r26, 0x1EEA
    22be:	b0 91 eb 1e 	lds	r27, 0x1EEB
    22c2:	80 93 f4 1e 	sts	0x1EF4, r24
    22c6:	90 93 f5 1e 	sts	0x1EF5, r25
    22ca:	a0 93 f6 1e 	sts	0x1EF6, r26
    22ce:	b0 93 f7 1e 	sts	0x1EF7, r27
	}

	/* Check the count of 'takes' from the software timer is keeping track with
	the amount of 'gives'. */
	if( ulTimerNotificationsSent > ulTimerNotificationsReceived )
    22d2:	80 91 ec 1e 	lds	r24, 0x1EEC
    22d6:	90 91 ed 1e 	lds	r25, 0x1EED
    22da:	a0 91 ee 1e 	lds	r26, 0x1EEE
    22de:	b0 91 ef 1e 	lds	r27, 0x1EEF
    22e2:	20 91 f0 1e 	lds	r18, 0x1EF0
    22e6:	30 91 f1 1e 	lds	r19, 0x1EF1
    22ea:	40 91 f2 1e 	lds	r20, 0x1EF2
    22ee:	50 91 f3 1e 	lds	r21, 0x1EF3
    22f2:	28 17       	cp	r18, r24
    22f4:	39 07       	cpc	r19, r25
    22f6:	4a 07       	cpc	r20, r26
    22f8:	5b 07       	cpc	r21, r27
    22fa:	50 f4       	brcc	.+20     	; 0x2310 <xAreTaskNotificationTasksStillRunning+0x8e>
	{
		if( ( ulTimerNotificationsSent - ulTimerNotificationsReceived ) > ulMaxSendReceiveDeviation )
    22fc:	82 1b       	sub	r24, r18
    22fe:	93 0b       	sbc	r25, r19
    2300:	a4 0b       	sbc	r26, r20
    2302:	b5 0b       	sbc	r27, r21
    2304:	06 97       	sbiw	r24, 0x06	; 6
    2306:	a1 05       	cpc	r26, r1
    2308:	b1 05       	cpc	r27, r1
    230a:	10 f0       	brcs	.+4      	; 0x2310 <xAreTaskNotificationTasksStillRunning+0x8e>
		{
			xErrorStatus = pdFAIL;
    230c:	10 92 13 03 	sts	0x0313, r1
		}
	}

	return xErrorStatus;
}
    2310:	80 91 13 03 	lds	r24, 0x0313
    2314:	08 95       	ret

00002316 <prvRand>:
static UBaseType_t prvRand( void )
{
const size_t uxMultiplier = ( size_t ) 0x015a4e35, uxIncrement = ( size_t ) 1;

	/* Utility function to generate a pseudo random number. */
	uxNextRand = ( uxMultiplier * uxNextRand ) + uxIncrement;
    2316:	20 91 fe 1e 	lds	r18, 0x1EFE
    231a:	30 91 ff 1e 	lds	r19, 0x1EFF
    231e:	85 e3       	ldi	r24, 0x35	; 53
    2320:	9e e4       	ldi	r25, 0x4E	; 78
    2322:	ac 01       	movw	r20, r24
    2324:	24 9f       	mul	r18, r20
    2326:	c0 01       	movw	r24, r0
    2328:	25 9f       	mul	r18, r21
    232a:	90 0d       	add	r25, r0
    232c:	34 9f       	mul	r19, r20
    232e:	90 0d       	add	r25, r0
    2330:	11 24       	eor	r1, r1
    2332:	01 96       	adiw	r24, 0x01	; 1
    2334:	90 93 ff 1e 	sts	0x1EFF, r25
    2338:	80 93 fe 1e 	sts	0x1EFE, r24
	return( ( uxNextRand >> 16 ) & ( ( size_t ) 0x7fff ) );
}
    233c:	80 e0       	ldi	r24, 0x00	; 0
    233e:	08 95       	ret

00002340 <xNotifyTaskFromISR>:
	}
}
/*-----------------------------------------------------------*/

void xNotifyTaskFromISR( void )
{
    2340:	ef 92       	push	r14
    2342:	ff 92       	push	r15
    2344:	0f 93       	push	r16
    2346:	1f 93       	push	r17
    2348:	df 93       	push	r29
    234a:	cf 93       	push	r28
    234c:	00 d0       	rcall	.+0      	; 0x234e <xNotifyTaskFromISR+0xe>
    234e:	0f 92       	push	r0
    2350:	cd b7       	in	r28, 0x3d	; 61
    2352:	de b7       	in	r29, 0x3e	; 62

	/* The task performs some tests before starting the timer that gives the
	notification from this interrupt.  If the timer has not been created yet
	then the initial tests have not yet completed and the notification should
	not be sent. */
	if( xTimer != NULL )
    2354:	80 91 f8 1e 	lds	r24, 0x1EF8
    2358:	90 91 f9 1e 	lds	r25, 0x1EF9
    235c:	89 2b       	or	r24, r25
    235e:	09 f4       	brne	.+2      	; 0x2362 <xNotifyTaskFromISR+0x22>
    2360:	70 c0       	rjmp	.+224    	; 0x2442 <xNotifyTaskFromISR+0x102>
	{
		xCallCount++;
    2362:	80 91 fd 1e 	lds	r24, 0x1EFD
    2366:	8f 5f       	subi	r24, 0xFF	; 255
    2368:	80 93 fd 1e 	sts	0x1EFD, r24

		if( xCallCount >= xCallInterval )
    236c:	82 33       	cpi	r24, 0x32	; 50
    236e:	0c f4       	brge	.+2      	; 0x2372 <xNotifyTaskFromISR+0x32>
    2370:	68 c0       	rjmp	.+208    	; 0x2442 <xNotifyTaskFromISR+0x102>
		{
			/* It is time to 'give' the notification again. */
			xCallCount = 0;
    2372:	10 92 fd 1e 	sts	0x1EFD, r1

			/* Test using both vTaskNotifyGiveFromISR(), xTaskNotifyFromISR()
			and xTaskNotifyAndQueryFromISR(). */
			switch( xAPIToUse )
    2376:	80 91 fc 1e 	lds	r24, 0x1EFC
    237a:	81 30       	cpi	r24, 0x01	; 1
    237c:	71 f0       	breq	.+28     	; 0x239a <xNotifyTaskFromISR+0x5a>
    237e:	82 30       	cpi	r24, 0x02	; 2
    2380:	11 f1       	breq	.+68     	; 0x23c6 <xNotifyTaskFromISR+0x86>
    2382:	88 23       	and	r24, r24
    2384:	09 f0       	breq	.+2      	; 0x2388 <xNotifyTaskFromISR+0x48>
    2386:	4a c0       	rjmp	.+148    	; 0x241c <xNotifyTaskFromISR+0xdc>
			{
				case 0:	vTaskNotifyGiveFromISR( xTaskToNotify, NULL );
    2388:	80 91 fa 1e 	lds	r24, 0x1EFA
    238c:	90 91 fb 1e 	lds	r25, 0x1EFB
    2390:	60 e0       	ldi	r22, 0x00	; 0
    2392:	70 e0       	ldi	r23, 0x00	; 0
    2394:	0e 94 de 07 	call	0xfbc	; 0xfbc <vTaskNotifyGiveFromISR>
    2398:	10 c0       	rjmp	.+32     	; 0x23ba <xNotifyTaskFromISR+0x7a>
						xAPIToUse++;
						break;

				case 1:	xTaskNotifyFromISR( xTaskToNotify, 0, eIncrement, NULL );
    239a:	80 91 fa 1e 	lds	r24, 0x1EFA
    239e:	90 91 fb 1e 	lds	r25, 0x1EFB
    23a2:	40 e0       	ldi	r20, 0x00	; 0
    23a4:	50 e0       	ldi	r21, 0x00	; 0
    23a6:	60 e0       	ldi	r22, 0x00	; 0
    23a8:	70 e0       	ldi	r23, 0x00	; 0
    23aa:	22 e0       	ldi	r18, 0x02	; 2
    23ac:	30 e0       	ldi	r19, 0x00	; 0
    23ae:	00 e0       	ldi	r16, 0x00	; 0
    23b0:	10 e0       	ldi	r17, 0x00	; 0
    23b2:	ee 24       	eor	r14, r14
    23b4:	ff 24       	eor	r15, r15
    23b6:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskGenericNotifyFromISR>
						xAPIToUse++;
    23ba:	80 91 fc 1e 	lds	r24, 0x1EFC
    23be:	8f 5f       	subi	r24, 0xFF	; 255
    23c0:	80 93 fc 1e 	sts	0x1EFC, r24
    23c4:	2b c0       	rjmp	.+86     	; 0x241c <xNotifyTaskFromISR+0xdc>
						break;

				case 2: ulPreviousValue = ulUnexpectedValue;
    23c6:	8f ef       	ldi	r24, 0xFF	; 255
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	a0 e0       	ldi	r26, 0x00	; 0
    23cc:	b0 e0       	ldi	r27, 0x00	; 0
    23ce:	89 83       	std	Y+1, r24	; 0x01
    23d0:	9a 83       	std	Y+2, r25	; 0x02
    23d2:	ab 83       	std	Y+3, r26	; 0x03
    23d4:	bc 83       	std	Y+4, r27	; 0x04
						xTaskNotifyAndQueryFromISR( xTaskToNotify, 0, eIncrement, &ulPreviousValue, NULL );
    23d6:	80 91 fa 1e 	lds	r24, 0x1EFA
    23da:	90 91 fb 1e 	lds	r25, 0x1EFB
    23de:	40 e0       	ldi	r20, 0x00	; 0
    23e0:	50 e0       	ldi	r21, 0x00	; 0
    23e2:	60 e0       	ldi	r22, 0x00	; 0
    23e4:	70 e0       	ldi	r23, 0x00	; 0
    23e6:	22 e0       	ldi	r18, 0x02	; 2
    23e8:	30 e0       	ldi	r19, 0x00	; 0
    23ea:	8e 01       	movw	r16, r28
    23ec:	0f 5f       	subi	r16, 0xFF	; 255
    23ee:	1f 4f       	sbci	r17, 0xFF	; 255
    23f0:	ee 24       	eor	r14, r14
    23f2:	ff 24       	eor	r15, r15
    23f4:	0e 94 43 08 	call	0x1086	; 0x1086 <xTaskGenericNotifyFromISR>
						configASSERT( ulPreviousValue != ulUnexpectedValue );
    23f8:	89 81       	ldd	r24, Y+1	; 0x01
    23fa:	9a 81       	ldd	r25, Y+2	; 0x02
    23fc:	ab 81       	ldd	r26, Y+3	; 0x03
    23fe:	bc 81       	ldd	r27, Y+4	; 0x04
    2400:	8f 3f       	cpi	r24, 0xFF	; 255
    2402:	91 05       	cpc	r25, r1
    2404:	a1 05       	cpc	r26, r1
    2406:	b1 05       	cpc	r27, r1
    2408:	39 f4       	brne	.+14     	; 0x2418 <xNotifyTaskFromISR+0xd8>
    240a:	65 e2       	ldi	r22, 0x25	; 37
    240c:	72 e0       	ldi	r23, 0x02	; 2
    240e:	80 e0       	ldi	r24, 0x00	; 0
    2410:	90 e0       	ldi	r25, 0x00	; 0
    2412:	4c e8       	ldi	r20, 0x8C	; 140
    2414:	52 e0       	ldi	r21, 0x02	; 2
    2416:	50 d5       	rcall	.+2720   	; 0x2eb8 <vAssertCalled>
    2418:	10 92 fc 1e 	sts	0x1EFC, r1
						xAPIToUse = 0;
    241c:	80 91 ec 1e 	lds	r24, 0x1EEC

				default:/* Should never get here!. */
						break;
			}

			ulTimerNotificationsSent++;
    2420:	90 91 ed 1e 	lds	r25, 0x1EED
    2424:	a0 91 ee 1e 	lds	r26, 0x1EEE
    2428:	b0 91 ef 1e 	lds	r27, 0x1EEF
    242c:	01 96       	adiw	r24, 0x01	; 1
    242e:	a1 1d       	adc	r26, r1
    2430:	b1 1d       	adc	r27, r1
    2432:	80 93 ec 1e 	sts	0x1EEC, r24
    2436:	90 93 ed 1e 	sts	0x1EED, r25
    243a:	a0 93 ee 1e 	sts	0x1EEE, r26
    243e:	b0 93 ef 1e 	sts	0x1EEF, r27
    2442:	0f 90       	pop	r0
		}
	}
}
    2444:	0f 90       	pop	r0
    2446:	0f 90       	pop	r0
    2448:	0f 90       	pop	r0
    244a:	cf 91       	pop	r28
    244c:	df 91       	pop	r29
    244e:	1f 91       	pop	r17
    2450:	0f 91       	pop	r16
    2452:	ff 90       	pop	r15
    2454:	ef 90       	pop	r14
    2456:	08 95       	ret

00002458 <vStartTaskNotifyTask>:
static size_t uxNextRand = 0;

/*-----------------------------------------------------------*/

void vStartTaskNotifyTask( void  )
{
    2458:	ef 92       	push	r14
    245a:	ff 92       	push	r15
    245c:	0f 93       	push	r16
	/* Create the task that performs some tests by itself, then loops around
	being notified by both a software timer and an interrupt. */
	xTaskCreate( prvNotifiedTask, "Notified", configMINIMAL_STACK_SIZE, NULL, notifyTASK_PRIORITY, &xTaskToNotify );
    245e:	82 e7       	ldi	r24, 0x72	; 114
    2460:	92 e1       	ldi	r25, 0x12	; 18
    2462:	69 eb       	ldi	r22, 0xB9	; 185
    2464:	72 e0       	ldi	r23, 0x02	; 2
    2466:	45 e5       	ldi	r20, 0x55	; 85
    2468:	50 e0       	ldi	r21, 0x00	; 0
    246a:	20 e0       	ldi	r18, 0x00	; 0
    246c:	30 e0       	ldi	r19, 0x00	; 0
    246e:	00 e0       	ldi	r16, 0x00	; 0
    2470:	ea ef       	ldi	r30, 0xFA	; 250
    2472:	ee 2e       	mov	r14, r30
    2474:	ee e1       	ldi	r30, 0x1E	; 30
    2476:	fe 2e       	mov	r15, r30
    2478:	3a db       	rcall	.-2444   	; 0x1aee <xTaskCreate>
    247a:	8b e8       	ldi	r24, 0x8B	; 139

	/* Pseudo seed the random number generator. */
	uxNextRand = ( size_t ) prvRand;
    247c:	91 e1       	ldi	r25, 0x11	; 17
    247e:	90 93 ff 1e 	sts	0x1EFF, r25
    2482:	80 93 fe 1e 	sts	0x1EFE, r24
    2486:	0f 91       	pop	r16
}
    2488:	ff 90       	pop	r15
    248a:	ef 90       	pop	r14
    248c:	08 95       	ret

0000248e <prvNotifyingTimer>:
	xTaskNotifyWait( notifyUINT32_MAX, 0, NULL, 0 );
}
/*-----------------------------------------------------------*/

static void prvNotifyingTimer( TimerHandle_t xNotUsed )
{
    248e:	0f 93       	push	r16
    2490:	1f 93       	push	r17
	( void ) xNotUsed;

	xTaskNotifyGive( xTaskToNotify );
    2492:	80 91 fa 1e 	lds	r24, 0x1EFA
    2496:	90 91 fb 1e 	lds	r25, 0x1EFB
    249a:	40 e0       	ldi	r20, 0x00	; 0
    249c:	50 e0       	ldi	r21, 0x00	; 0
    249e:	60 e0       	ldi	r22, 0x00	; 0
    24a0:	70 e0       	ldi	r23, 0x00	; 0
    24a2:	22 e0       	ldi	r18, 0x02	; 2
    24a4:	30 e0       	ldi	r19, 0x00	; 0
    24a6:	00 e0       	ldi	r16, 0x00	; 0
    24a8:	10 e0       	ldi	r17, 0x00	; 0
    24aa:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>

	/* This value is also incremented from an interrupt. */
	taskENTER_CRITICAL();
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	0f 92       	push	r0
	{
		ulTimerNotificationsSent++;
    24b4:	80 91 ec 1e 	lds	r24, 0x1EEC
    24b8:	90 91 ed 1e 	lds	r25, 0x1EED
    24bc:	a0 91 ee 1e 	lds	r26, 0x1EEE
    24c0:	b0 91 ef 1e 	lds	r27, 0x1EEF
    24c4:	01 96       	adiw	r24, 0x01	; 1
    24c6:	a1 1d       	adc	r26, r1
    24c8:	b1 1d       	adc	r27, r1
    24ca:	80 93 ec 1e 	sts	0x1EEC, r24
    24ce:	90 93 ed 1e 	sts	0x1EED, r25
    24d2:	a0 93 ee 1e 	sts	0x1EEE, r26
    24d6:	b0 93 ef 1e 	sts	0x1EEF, r27
	}
	taskEXIT_CRITICAL();
    24da:	0f 90       	pop	r0
    24dc:	0f be       	out	0x3f, r0	; 63
}
    24de:	1f 91       	pop	r17
    24e0:	0f 91       	pop	r16
    24e2:	08 95       	ret

000024e4 <prvNotifiedTask>:
/*-----------------------------------------------------------*/

static void prvNotifiedTask( void *pvParameters )
{
    24e4:	3f 92       	push	r3
    24e6:	4f 92       	push	r4
    24e8:	5f 92       	push	r5
    24ea:	6f 92       	push	r6
    24ec:	7f 92       	push	r7
    24ee:	8f 92       	push	r8
    24f0:	9f 92       	push	r9
    24f2:	af 92       	push	r10
    24f4:	bf 92       	push	r11
    24f6:	cf 92       	push	r12
    24f8:	df 92       	push	r13
    24fa:	ef 92       	push	r14
    24fc:	ff 92       	push	r15
    24fe:	0f 93       	push	r16
    2500:	1f 93       	push	r17
    2502:	df 93       	push	r29
    2504:	cf 93       	push	r28
    2506:	cd b7       	in	r28, 0x3d	; 61
    2508:	de b7       	in	r29, 0x3e	; 62
    250a:	28 97       	sbiw	r28, 0x08	; 8
    250c:	0f b6       	in	r0, 0x3f	; 63
    250e:	f8 94       	cli
    2510:	de bf       	out	0x3e, r29	; 62
    2512:	0f be       	out	0x3f, r0	; 63
    2514:	cd bf       	out	0x3d, r28	; 61
const uint32_t ulFirstNotifiedConst = 100001UL, ulSecondNotifiedValueConst = 5555UL, ulMaxLoops = 5UL;
const uint32_t ulBit0 = 0x01UL, ulBit1 = 0x02UL;

	/* -------------------------------------------------------------------------
	Check blocking when there are no notifications. */
	xTimeOnEntering = xTaskGetTickCount();
    2516:	0e 94 02 07 	call	0xe04	; 0xe04 <xTaskGetTickCount>
    251a:	6c 01       	movw	r12, r24
	xReturned = xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, xTicksToWait );
    251c:	6f ef       	ldi	r22, 0xFF	; 255
    251e:	7f ef       	ldi	r23, 0xFF	; 255
    2520:	8f ef       	ldi	r24, 0xFF	; 255
    2522:	9f ef       	ldi	r25, 0xFF	; 255
    2524:	20 e0       	ldi	r18, 0x00	; 0
    2526:	30 e0       	ldi	r19, 0x00	; 0
    2528:	40 e0       	ldi	r20, 0x00	; 0
    252a:	50 e0       	ldi	r21, 0x00	; 0
    252c:	8e 01       	movw	r16, r28
    252e:	0f 5f       	subi	r16, 0xFF	; 255
    2530:	1f 4f       	sbci	r17, 0xFF	; 255
    2532:	e4 e6       	ldi	r30, 0x64	; 100
    2534:	ee 2e       	mov	r14, r30
    2536:	f1 2c       	mov	r15, r1
    2538:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    253c:	18 2f       	mov	r17, r24

	/* Should have blocked for the entire block time. */
	if( ( xTaskGetTickCount() - xTimeOnEntering ) < xTicksToWait )
    253e:	0e 94 02 07 	call	0xe04	; 0xe04 <xTaskGetTickCount>
    2542:	8c 19       	sub	r24, r12
    2544:	9d 09       	sbc	r25, r13
    2546:	84 36       	cpi	r24, 0x64	; 100
    2548:	91 05       	cpc	r25, r1
    254a:	10 f4       	brcc	.+4      	; 0x2550 <prvNotifiedTask+0x6c>
	{
		xErrorStatus = pdFAIL;
    254c:	10 92 13 03 	sts	0x0313, r1
	}
	configASSERT( xReturned == pdFAIL );
    2550:	11 23       	and	r17, r17
    2552:	39 f0       	breq	.+14     	; 0x2562 <prvNotifiedTask+0x7e>
    2554:	65 ea       	ldi	r22, 0xA5	; 165
    2556:	70 e0       	ldi	r23, 0x00	; 0
    2558:	80 e0       	ldi	r24, 0x00	; 0
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	4c e8       	ldi	r20, 0x8C	; 140
    255e:	52 e0       	ldi	r21, 0x02	; 2
    2560:	ab d4       	rcall	.+2390   	; 0x2eb8 <vAssertCalled>
    2562:	89 81       	ldd	r24, Y+1	; 0x01
	configASSERT( ulNotifiedValue == 0UL );
    2564:	9a 81       	ldd	r25, Y+2	; 0x02
    2566:	ab 81       	ldd	r26, Y+3	; 0x03
    2568:	bc 81       	ldd	r27, Y+4	; 0x04
    256a:	00 97       	sbiw	r24, 0x00	; 0
    256c:	a1 05       	cpc	r26, r1
    256e:	b1 05       	cpc	r27, r1
    2570:	39 f0       	breq	.+14     	; 0x2580 <prvNotifiedTask+0x9c>
    2572:	66 ea       	ldi	r22, 0xA6	; 166
    2574:	70 e0       	ldi	r23, 0x00	; 0
    2576:	80 e0       	ldi	r24, 0x00	; 0
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	4c e8       	ldi	r20, 0x8C	; 140
    257c:	52 e0       	ldi	r21, 0x02	; 2
    257e:	9c d4       	rcall	.+2360   	; 0x2eb8 <vAssertCalled>
    2580:	80 91 fa 1e 	lds	r24, 0x1EFA

	/* -------------------------------------------------------------------------
	Check no blocking when notifications are pending.  First notify itself -
	this would not be a normal thing to do and is done here for test purposes
	only. */
	xReturned = xTaskNotifyAndQuery( xTaskToNotify, ulFirstNotifiedConst, eSetValueWithoutOverwrite, &ulPreviousValue );
    2584:	90 91 fb 1e 	lds	r25, 0x1EFB
    2588:	41 ea       	ldi	r20, 0xA1	; 161
    258a:	56 e8       	ldi	r21, 0x86	; 134
    258c:	61 e0       	ldi	r22, 0x01	; 1
    258e:	70 e0       	ldi	r23, 0x00	; 0
    2590:	24 e0       	ldi	r18, 0x04	; 4
    2592:	30 e0       	ldi	r19, 0x00	; 0
    2594:	8e 01       	movw	r16, r28
    2596:	0b 5f       	subi	r16, 0xFB	; 251
    2598:	1f 4f       	sbci	r17, 0xFF	; 255
    259a:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    259e:	81 30       	cpi	r24, 0x01	; 1
    25a0:	39 f0       	breq	.+14     	; 0x25b0 <prvNotifiedTask+0xcc>

	/* Even through the 'without overwrite' action was used the update should
	have been successful. */
	configASSERT( xReturned == pdPASS );
    25a2:	63 eb       	ldi	r22, 0xB3	; 179
    25a4:	70 e0       	ldi	r23, 0x00	; 0
    25a6:	80 e0       	ldi	r24, 0x00	; 0
    25a8:	90 e0       	ldi	r25, 0x00	; 0
    25aa:	4c e8       	ldi	r20, 0x8C	; 140
    25ac:	52 e0       	ldi	r21, 0x02	; 2
    25ae:	84 d4       	rcall	.+2312   	; 0x2eb8 <vAssertCalled>
    25b0:	8d 81       	ldd	r24, Y+5	; 0x05
    25b2:	9e 81       	ldd	r25, Y+6	; 0x06
    25b4:	af 81       	ldd	r26, Y+7	; 0x07

	/* No bits should have been pending previously. */
	configASSERT( ulPreviousValue == 0 );
    25b6:	b8 85       	ldd	r27, Y+8	; 0x08
    25b8:	00 97       	sbiw	r24, 0x00	; 0
    25ba:	a1 05       	cpc	r26, r1
    25bc:	b1 05       	cpc	r27, r1
    25be:	39 f0       	breq	.+14     	; 0x25ce <prvNotifiedTask+0xea>
    25c0:	66 eb       	ldi	r22, 0xB6	; 182
    25c2:	70 e0       	ldi	r23, 0x00	; 0
    25c4:	80 e0       	ldi	r24, 0x00	; 0
    25c6:	90 e0       	ldi	r25, 0x00	; 0
    25c8:	4c e8       	ldi	r20, 0x8C	; 140
    25ca:	52 e0       	ldi	r21, 0x02	; 2
    25cc:	75 d4       	rcall	.+2282   	; 0x2eb8 <vAssertCalled>
    25ce:	0e 94 02 07 	call	0xe04	; 0xe04 <xTaskGetTickCount>
    25d2:	6c 01       	movw	r12, r24
    25d4:	6f ef       	ldi	r22, 0xFF	; 255

	/* The task should now have a notification pending, and so not time out. */
	xTimeOnEntering = xTaskGetTickCount();
    25d6:	7f ef       	ldi	r23, 0xFF	; 255
    25d8:	8f ef       	ldi	r24, 0xFF	; 255
    25da:	9f ef       	ldi	r25, 0xFF	; 255
	xReturned = xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, xTicksToWait );
    25dc:	20 e0       	ldi	r18, 0x00	; 0
    25de:	30 e0       	ldi	r19, 0x00	; 0
    25e0:	40 e0       	ldi	r20, 0x00	; 0
    25e2:	50 e0       	ldi	r21, 0x00	; 0
    25e4:	8e 01       	movw	r16, r28
    25e6:	0f 5f       	subi	r16, 0xFF	; 255
    25e8:	1f 4f       	sbci	r17, 0xFF	; 255
    25ea:	b4 e6       	ldi	r27, 0x64	; 100
    25ec:	eb 2e       	mov	r14, r27
    25ee:	f1 2c       	mov	r15, r1
    25f0:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    25f4:	18 2f       	mov	r17, r24
    25f6:	0e 94 02 07 	call	0xe04	; 0xe04 <xTaskGetTickCount>
    25fa:	8c 19       	sub	r24, r12
    25fc:	9d 09       	sbc	r25, r13

	if( ( xTaskGetTickCount() - xTimeOnEntering ) >= xTicksToWait )
    25fe:	84 36       	cpi	r24, 0x64	; 100
    2600:	91 05       	cpc	r25, r1
    2602:	10 f0       	brcs	.+4      	; 0x2608 <prvNotifiedTask+0x124>
    2604:	10 92 13 03 	sts	0x0313, r1
    2608:	11 30       	cpi	r17, 0x01	; 1
    260a:	39 f0       	breq	.+14     	; 0x261a <prvNotifiedTask+0x136>
	{
		xErrorStatus = pdFAIL;
    260c:	63 ec       	ldi	r22, 0xC3	; 195
    260e:	70 e0       	ldi	r23, 0x00	; 0
	}

	/* The task should have been notified, and the notified value should
	be equal to ulFirstNotifiedConst. */
	configASSERT( xReturned == pdPASS );
    2610:	80 e0       	ldi	r24, 0x00	; 0
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	4c e8       	ldi	r20, 0x8C	; 140
    2616:	52 e0       	ldi	r21, 0x02	; 2
    2618:	4f d4       	rcall	.+2206   	; 0x2eb8 <vAssertCalled>
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	9a 81       	ldd	r25, Y+2	; 0x02
    261e:	ab 81       	ldd	r26, Y+3	; 0x03
    2620:	bc 81       	ldd	r27, Y+4	; 0x04
    2622:	81 5a       	subi	r24, 0xA1	; 161
	configASSERT( ulNotifiedValue == ulFirstNotifiedConst );
    2624:	96 48       	sbci	r25, 0x86	; 134
    2626:	a1 40       	sbci	r26, 0x01	; 1
    2628:	b0 40       	sbci	r27, 0x00	; 0
    262a:	39 f0       	breq	.+14     	; 0x263a <prvNotifiedTask+0x156>
    262c:	64 ec       	ldi	r22, 0xC4	; 196
    262e:	70 e0       	ldi	r23, 0x00	; 0
    2630:	80 e0       	ldi	r24, 0x00	; 0
    2632:	90 e0       	ldi	r25, 0x00	; 0
    2634:	4c e8       	ldi	r20, 0x8C	; 140
    2636:	52 e0       	ldi	r21, 0x02	; 2
    2638:	3f d4       	rcall	.+2174   	; 0x2eb8 <vAssertCalled>
    263a:	80 91 e8 1e 	lds	r24, 0x1EE8
    263e:	90 91 e9 1e 	lds	r25, 0x1EE9
    2642:	a0 91 ea 1e 	lds	r26, 0x1EEA

	/* Incremented to show the task is still running. */
	ulNotifyCycleCount++;
    2646:	b0 91 eb 1e 	lds	r27, 0x1EEB
    264a:	01 96       	adiw	r24, 0x01	; 1
    264c:	a1 1d       	adc	r26, r1
    264e:	b1 1d       	adc	r27, r1
    2650:	80 93 e8 1e 	sts	0x1EE8, r24
    2654:	90 93 e9 1e 	sts	0x1EE9, r25
    2658:	a0 93 ea 1e 	sts	0x1EEA, r26
    265c:	b0 93 eb 1e 	sts	0x1EEB, r27
    2660:	80 91 fa 1e 	lds	r24, 0x1EFA
    2664:	90 91 fb 1e 	lds	r25, 0x1EFB
    2668:	41 ea       	ldi	r20, 0xA1	; 161
    266a:	56 e8       	ldi	r21, 0x86	; 134
	/*--------------------------------------------------------------------------
	Check the non-overwriting functionality.  The notification is done twice
	using two different notification values.  The action says don't overwrite so
	only the first notification should pass and the value read back should also
	be that used with the first notification. */
	xReturned = xTaskNotify( xTaskToNotify, ulFirstNotifiedConst, eSetValueWithoutOverwrite );
    266c:	61 e0       	ldi	r22, 0x01	; 1
    266e:	70 e0       	ldi	r23, 0x00	; 0
    2670:	24 e0       	ldi	r18, 0x04	; 4
    2672:	30 e0       	ldi	r19, 0x00	; 0
    2674:	00 e0       	ldi	r16, 0x00	; 0
    2676:	10 e0       	ldi	r17, 0x00	; 0
    2678:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    267c:	81 30       	cpi	r24, 0x01	; 1
    267e:	39 f0       	breq	.+14     	; 0x268e <prvNotifiedTask+0x1aa>
    2680:	63 ed       	ldi	r22, 0xD3	; 211
    2682:	70 e0       	ldi	r23, 0x00	; 0
    2684:	80 e0       	ldi	r24, 0x00	; 0
    2686:	90 e0       	ldi	r25, 0x00	; 0
	configASSERT( xReturned == pdPASS );
    2688:	4c e8       	ldi	r20, 0x8C	; 140
    268a:	52 e0       	ldi	r21, 0x02	; 2
    268c:	15 d4       	rcall	.+2090   	; 0x2eb8 <vAssertCalled>
    268e:	80 91 fa 1e 	lds	r24, 0x1EFA
    2692:	90 91 fb 1e 	lds	r25, 0x1EFB
    2696:	43 eb       	ldi	r20, 0xB3	; 179
    2698:	55 e1       	ldi	r21, 0x15	; 21
    269a:	60 e0       	ldi	r22, 0x00	; 0

	xReturned = xTaskNotify( xTaskToNotify, ulSecondNotifiedValueConst, eSetValueWithoutOverwrite );
    269c:	70 e0       	ldi	r23, 0x00	; 0
    269e:	24 e0       	ldi	r18, 0x04	; 4
    26a0:	30 e0       	ldi	r19, 0x00	; 0
    26a2:	00 e0       	ldi	r16, 0x00	; 0
    26a4:	10 e0       	ldi	r17, 0x00	; 0
    26a6:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    26aa:	88 23       	and	r24, r24
    26ac:	39 f0       	breq	.+14     	; 0x26bc <prvNotifiedTask+0x1d8>
    26ae:	66 ed       	ldi	r22, 0xD6	; 214
    26b0:	70 e0       	ldi	r23, 0x00	; 0
    26b2:	80 e0       	ldi	r24, 0x00	; 0
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	4c e8       	ldi	r20, 0x8C	; 140
	configASSERT( xReturned == pdFAIL );
    26b8:	52 e0       	ldi	r21, 0x02	; 2
    26ba:	fe d3       	rcall	.+2044   	; 0x2eb8 <vAssertCalled>
    26bc:	6f ef       	ldi	r22, 0xFF	; 255
    26be:	7f ef       	ldi	r23, 0xFF	; 255
    26c0:	8f ef       	ldi	r24, 0xFF	; 255
    26c2:	9f ef       	ldi	r25, 0xFF	; 255
    26c4:	20 e0       	ldi	r18, 0x00	; 0
    26c6:	30 e0       	ldi	r19, 0x00	; 0
    26c8:	40 e0       	ldi	r20, 0x00	; 0
    26ca:	50 e0       	ldi	r21, 0x00	; 0

	/* Waiting for the notification should now return immediately so a block
	time of zero is used. */
	xReturned = xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, 0 );
    26cc:	8e 01       	movw	r16, r28
    26ce:	0f 5f       	subi	r16, 0xFF	; 255
    26d0:	1f 4f       	sbci	r17, 0xFF	; 255
    26d2:	ee 24       	eor	r14, r14
    26d4:	ff 24       	eor	r15, r15
    26d6:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    26da:	81 30       	cpi	r24, 0x01	; 1
    26dc:	39 f0       	breq	.+14     	; 0x26ec <prvNotifiedTask+0x208>
    26de:	6c ed       	ldi	r22, 0xDC	; 220
    26e0:	70 e0       	ldi	r23, 0x00	; 0
    26e2:	80 e0       	ldi	r24, 0x00	; 0
    26e4:	90 e0       	ldi	r25, 0x00	; 0
    26e6:	4c e8       	ldi	r20, 0x8C	; 140
    26e8:	52 e0       	ldi	r21, 0x02	; 2

	configASSERT( xReturned == pdPASS );
    26ea:	e6 d3       	rcall	.+1996   	; 0x2eb8 <vAssertCalled>
    26ec:	89 81       	ldd	r24, Y+1	; 0x01
    26ee:	9a 81       	ldd	r25, Y+2	; 0x02
    26f0:	ab 81       	ldd	r26, Y+3	; 0x03
    26f2:	bc 81       	ldd	r27, Y+4	; 0x04
    26f4:	81 5a       	subi	r24, 0xA1	; 161
    26f6:	96 48       	sbci	r25, 0x86	; 134
    26f8:	a1 40       	sbci	r26, 0x01	; 1
    26fa:	b0 40       	sbci	r27, 0x00	; 0
    26fc:	39 f0       	breq	.+14     	; 0x270c <prvNotifiedTask+0x228>
	configASSERT( ulNotifiedValue == ulFirstNotifiedConst );
    26fe:	6d ed       	ldi	r22, 0xDD	; 221
    2700:	70 e0       	ldi	r23, 0x00	; 0
    2702:	80 e0       	ldi	r24, 0x00	; 0
    2704:	90 e0       	ldi	r25, 0x00	; 0
    2706:	4c e8       	ldi	r20, 0x8C	; 140
    2708:	52 e0       	ldi	r21, 0x02	; 2
    270a:	d6 d3       	rcall	.+1964   	; 0x2eb8 <vAssertCalled>
    270c:	80 91 fa 1e 	lds	r24, 0x1EFA
    2710:	90 91 fb 1e 	lds	r25, 0x1EFB
    2714:	41 ea       	ldi	r20, 0xA1	; 161
    2716:	56 e8       	ldi	r21, 0x86	; 134
    2718:	61 e0       	ldi	r22, 0x01	; 1
    271a:	70 e0       	ldi	r23, 0x00	; 0
    271c:	23 e0       	ldi	r18, 0x03	; 3
    271e:	30 e0       	ldi	r19, 0x00	; 0
	/*--------------------------------------------------------------------------
	Do the same again, only this time use the overwriting version.  This time
	both notifications should pass, and the value written the second time should
	overwrite the value written the first time, and so be the value that is read
	back. */
	xReturned = xTaskNotify( xTaskToNotify, ulFirstNotifiedConst, eSetValueWithOverwrite );
    2720:	00 e0       	ldi	r16, 0x00	; 0
    2722:	10 e0       	ldi	r17, 0x00	; 0
    2724:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2728:	81 30       	cpi	r24, 0x01	; 1
    272a:	39 f0       	breq	.+14     	; 0x273a <prvNotifiedTask+0x256>
    272c:	69 ee       	ldi	r22, 0xE9	; 233
    272e:	70 e0       	ldi	r23, 0x00	; 0
    2730:	80 e0       	ldi	r24, 0x00	; 0
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	4c e8       	ldi	r20, 0x8C	; 140
    2736:	52 e0       	ldi	r21, 0x02	; 2
    2738:	bf d3       	rcall	.+1918   	; 0x2eb8 <vAssertCalled>
    273a:	80 91 fa 1e 	lds	r24, 0x1EFA
	configASSERT( xReturned == pdPASS );
    273e:	90 91 fb 1e 	lds	r25, 0x1EFB
    2742:	43 eb       	ldi	r20, 0xB3	; 179
    2744:	55 e1       	ldi	r21, 0x15	; 21
    2746:	60 e0       	ldi	r22, 0x00	; 0
    2748:	70 e0       	ldi	r23, 0x00	; 0
    274a:	23 e0       	ldi	r18, 0x03	; 3
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	00 e0       	ldi	r16, 0x00	; 0
	xReturned = xTaskNotify( xTaskToNotify, ulSecondNotifiedValueConst, eSetValueWithOverwrite );
    2750:	10 e0       	ldi	r17, 0x00	; 0
    2752:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2756:	81 30       	cpi	r24, 0x01	; 1
    2758:	39 f0       	breq	.+14     	; 0x2768 <prvNotifiedTask+0x284>
    275a:	6b ee       	ldi	r22, 0xEB	; 235
    275c:	70 e0       	ldi	r23, 0x00	; 0
    275e:	80 e0       	ldi	r24, 0x00	; 0
    2760:	90 e0       	ldi	r25, 0x00	; 0
    2762:	4c e8       	ldi	r20, 0x8C	; 140
    2764:	52 e0       	ldi	r21, 0x02	; 2
    2766:	a8 d3       	rcall	.+1872   	; 0x2eb8 <vAssertCalled>
    2768:	6f ef       	ldi	r22, 0xFF	; 255
    276a:	7f ef       	ldi	r23, 0xFF	; 255
	configASSERT( xReturned == pdPASS );
    276c:	8f ef       	ldi	r24, 0xFF	; 255
    276e:	9f ef       	ldi	r25, 0xFF	; 255
    2770:	20 e0       	ldi	r18, 0x00	; 0
    2772:	30 e0       	ldi	r19, 0x00	; 0
    2774:	40 e0       	ldi	r20, 0x00	; 0
    2776:	50 e0       	ldi	r21, 0x00	; 0
    2778:	8e 01       	movw	r16, r28
    277a:	0f 5f       	subi	r16, 0xFF	; 255
    277c:	1f 4f       	sbci	r17, 0xFF	; 255
    277e:	ee 24       	eor	r14, r14
	xReturned = xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, 0 );
    2780:	ff 24       	eor	r15, r15
    2782:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2786:	81 30       	cpi	r24, 0x01	; 1
    2788:	39 f0       	breq	.+14     	; 0x2798 <prvNotifiedTask+0x2b4>
    278a:	6d ee       	ldi	r22, 0xED	; 237
    278c:	70 e0       	ldi	r23, 0x00	; 0
    278e:	80 e0       	ldi	r24, 0x00	; 0
    2790:	90 e0       	ldi	r25, 0x00	; 0
    2792:	4c e8       	ldi	r20, 0x8C	; 140
    2794:	52 e0       	ldi	r21, 0x02	; 2
    2796:	90 d3       	rcall	.+1824   	; 0x2eb8 <vAssertCalled>
    2798:	89 81       	ldd	r24, Y+1	; 0x01
    279a:	9a 81       	ldd	r25, Y+2	; 0x02
    279c:	ab 81       	ldd	r26, Y+3	; 0x03
	configASSERT( xReturned == pdPASS );
    279e:	bc 81       	ldd	r27, Y+4	; 0x04
    27a0:	83 5b       	subi	r24, 0xB3	; 179
    27a2:	95 41       	sbci	r25, 0x15	; 21
    27a4:	a0 40       	sbci	r26, 0x00	; 0
    27a6:	b0 40       	sbci	r27, 0x00	; 0
    27a8:	39 f0       	breq	.+14     	; 0x27b8 <prvNotifiedTask+0x2d4>
    27aa:	6e ee       	ldi	r22, 0xEE	; 238
    27ac:	70 e0       	ldi	r23, 0x00	; 0
    27ae:	80 e0       	ldi	r24, 0x00	; 0
    27b0:	90 e0       	ldi	r25, 0x00	; 0
	configASSERT( ulNotifiedValue == ulSecondNotifiedValueConst );
    27b2:	4c e8       	ldi	r20, 0x8C	; 140
    27b4:	52 e0       	ldi	r21, 0x02	; 2
    27b6:	80 d3       	rcall	.+1792   	; 0x2eb8 <vAssertCalled>
    27b8:	80 91 fa 1e 	lds	r24, 0x1EFA
    27bc:	90 91 fb 1e 	lds	r25, 0x1EFB
    27c0:	41 ea       	ldi	r20, 0xA1	; 161
    27c2:	56 e8       	ldi	r21, 0x86	; 134
    27c4:	61 e0       	ldi	r22, 0x01	; 1
    27c6:	70 e0       	ldi	r23, 0x00	; 0
    27c8:	20 e0       	ldi	r18, 0x00	; 0
    27ca:	30 e0       	ldi	r19, 0x00	; 0
    27cc:	00 e0       	ldi	r16, 0x00	; 0
    27ce:	10 e0       	ldi	r17, 0x00	; 0
    27d0:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>

	/*--------------------------------------------------------------------------
	Check notifications with no action pass without updating the value.  Even
	though ulFirstNotifiedConst is used as the value the value read back should
	remain at ulSecondNotifiedConst. */
	xReturned = xTaskNotify( xTaskToNotify, ulFirstNotifiedConst, eNoAction );
    27d4:	81 30       	cpi	r24, 0x01	; 1
    27d6:	39 f0       	breq	.+14     	; 0x27e6 <prvNotifiedTask+0x302>
    27d8:	68 ef       	ldi	r22, 0xF8	; 248
    27da:	70 e0       	ldi	r23, 0x00	; 0
    27dc:	80 e0       	ldi	r24, 0x00	; 0
    27de:	90 e0       	ldi	r25, 0x00	; 0
    27e0:	4c e8       	ldi	r20, 0x8C	; 140
    27e2:	52 e0       	ldi	r21, 0x02	; 2
    27e4:	69 d3       	rcall	.+1746   	; 0x2eb8 <vAssertCalled>
    27e6:	6f ef       	ldi	r22, 0xFF	; 255
    27e8:	7f ef       	ldi	r23, 0xFF	; 255
    27ea:	8f ef       	ldi	r24, 0xFF	; 255
    27ec:	9f ef       	ldi	r25, 0xFF	; 255
    27ee:	20 e0       	ldi	r18, 0x00	; 0
	configASSERT( xReturned == pdPASS );
    27f0:	30 e0       	ldi	r19, 0x00	; 0
    27f2:	40 e0       	ldi	r20, 0x00	; 0
    27f4:	50 e0       	ldi	r21, 0x00	; 0
    27f6:	8e 01       	movw	r16, r28
    27f8:	0f 5f       	subi	r16, 0xFF	; 255
    27fa:	1f 4f       	sbci	r17, 0xFF	; 255
    27fc:	ee 24       	eor	r14, r14
    27fe:	ff 24       	eor	r15, r15
    2800:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
	xReturned = xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, 0 );
    2804:	89 81       	ldd	r24, Y+1	; 0x01
    2806:	9a 81       	ldd	r25, Y+2	; 0x02
    2808:	ab 81       	ldd	r26, Y+3	; 0x03
    280a:	bc 81       	ldd	r27, Y+4	; 0x04
    280c:	83 5b       	subi	r24, 0xB3	; 179
    280e:	95 41       	sbci	r25, 0x15	; 21
    2810:	a0 40       	sbci	r26, 0x00	; 0
    2812:	b0 40       	sbci	r27, 0x00	; 0
    2814:	39 f0       	breq	.+14     	; 0x2824 <prvNotifiedTask+0x340>
    2816:	6a ef       	ldi	r22, 0xFA	; 250
    2818:	70 e0       	ldi	r23, 0x00	; 0
    281a:	80 e0       	ldi	r24, 0x00	; 0
    281c:	90 e0       	ldi	r25, 0x00	; 0
    281e:	4c e8       	ldi	r20, 0x8C	; 140
    2820:	52 e0       	ldi	r21, 0x02	; 2
	configASSERT( ulNotifiedValue == ulSecondNotifiedValueConst );
    2822:	4a d3       	rcall	.+1684   	; 0x2eb8 <vAssertCalled>
    2824:	ee 24       	eor	r14, r14
    2826:	ff 24       	eor	r15, r15
    2828:	80 91 fa 1e 	lds	r24, 0x1EFA
    282c:	90 91 fb 1e 	lds	r25, 0x1EFB
    2830:	40 e0       	ldi	r20, 0x00	; 0
    2832:	50 e0       	ldi	r21, 0x00	; 0
    2834:	60 e0       	ldi	r22, 0x00	; 0
    2836:	70 e0       	ldi	r23, 0x00	; 0
    2838:	22 e0       	ldi	r18, 0x02	; 2
    283a:	30 e0       	ldi	r19, 0x00	; 0
    283c:	00 e0       	ldi	r16, 0x00	; 0
    283e:	10 e0       	ldi	r17, 0x00	; 0
    2840:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2844:	81 30       	cpi	r24, 0x01	; 1
    2846:	39 f0       	breq	.+14     	; 0x2856 <prvNotifiedTask+0x372>
	Check incrementing values.  Send ulMaxLoop increment notifications, then
	ensure the received value is as expected - which should be
	ulSecondNotificationValueConst plus how ever many times to loop iterated. */
	for( ulLoop = 0; ulLoop < ulMaxLoops; ulLoop++ )
	{
		xReturned = xTaskNotify( xTaskToNotify, 0, eIncrement );
    2848:	66 e0       	ldi	r22, 0x06	; 6
    284a:	71 e0       	ldi	r23, 0x01	; 1
    284c:	80 e0       	ldi	r24, 0x00	; 0
    284e:	90 e0       	ldi	r25, 0x00	; 0
    2850:	4c e8       	ldi	r20, 0x8C	; 140
    2852:	52 e0       	ldi	r21, 0x02	; 2
    2854:	31 d3       	rcall	.+1634   	; 0x2eb8 <vAssertCalled>
    2856:	08 94       	sec
    2858:	e1 1c       	adc	r14, r1
    285a:	f1 1c       	adc	r15, r1
    285c:	85 e0       	ldi	r24, 0x05	; 5
    285e:	e8 16       	cp	r14, r24
    2860:	f1 04       	cpc	r15, r1
    2862:	11 f7       	brne	.-60     	; 0x2828 <prvNotifiedTask+0x344>
		configASSERT( xReturned == pdPASS );
    2864:	6f ef       	ldi	r22, 0xFF	; 255
    2866:	7f ef       	ldi	r23, 0xFF	; 255
    2868:	8f ef       	ldi	r24, 0xFF	; 255
    286a:	9f ef       	ldi	r25, 0xFF	; 255
    286c:	20 e0       	ldi	r18, 0x00	; 0
    286e:	30 e0       	ldi	r19, 0x00	; 0
    2870:	40 e0       	ldi	r20, 0x00	; 0
    2872:	50 e0       	ldi	r21, 0x00	; 0
    2874:	8e 01       	movw	r16, r28
    2876:	0f 5f       	subi	r16, 0xFF	; 255
    2878:	1f 4f       	sbci	r17, 0xFF	; 255
    287a:	ee 24       	eor	r14, r14
    287c:	ff 24       	eor	r15, r15

	/*--------------------------------------------------------------------------
	Check incrementing values.  Send ulMaxLoop increment notifications, then
	ensure the received value is as expected - which should be
	ulSecondNotificationValueConst plus how ever many times to loop iterated. */
	for( ulLoop = 0; ulLoop < ulMaxLoops; ulLoop++ )
    287e:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2882:	81 30       	cpi	r24, 0x01	; 1
    2884:	39 f0       	breq	.+14     	; 0x2894 <prvNotifiedTask+0x3b0>
	{
		xReturned = xTaskNotify( xTaskToNotify, 0, eIncrement );
		configASSERT( xReturned == pdPASS );
	}

	xReturned = xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, 0 );
    2886:	6a e0       	ldi	r22, 0x0A	; 10
    2888:	71 e0       	ldi	r23, 0x01	; 1
    288a:	80 e0       	ldi	r24, 0x00	; 0
    288c:	90 e0       	ldi	r25, 0x00	; 0
    288e:	4c e8       	ldi	r20, 0x8C	; 140
    2890:	52 e0       	ldi	r21, 0x02	; 2
    2892:	12 d3       	rcall	.+1572   	; 0x2eb8 <vAssertCalled>
    2894:	89 81       	ldd	r24, Y+1	; 0x01
    2896:	9a 81       	ldd	r25, Y+2	; 0x02
    2898:	ab 81       	ldd	r26, Y+3	; 0x03
    289a:	bc 81       	ldd	r27, Y+4	; 0x04
    289c:	88 5b       	subi	r24, 0xB8	; 184
    289e:	95 41       	sbci	r25, 0x15	; 21
    28a0:	a0 40       	sbci	r26, 0x00	; 0
    28a2:	b0 40       	sbci	r27, 0x00	; 0
	configASSERT( xReturned == pdPASS );
    28a4:	39 f0       	breq	.+14     	; 0x28b4 <prvNotifiedTask+0x3d0>
    28a6:	6b e0       	ldi	r22, 0x0B	; 11
    28a8:	71 e0       	ldi	r23, 0x01	; 1
    28aa:	80 e0       	ldi	r24, 0x00	; 0
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	4c e8       	ldi	r20, 0x8C	; 140
    28b0:	52 e0       	ldi	r21, 0x02	; 2
    28b2:	02 d3       	rcall	.+1540   	; 0x2eb8 <vAssertCalled>
    28b4:	60 e0       	ldi	r22, 0x00	; 0
    28b6:	70 e0       	ldi	r23, 0x00	; 0
	configASSERT( ulNotifiedValue == ( ulSecondNotifiedValueConst + ulMaxLoops ) );
    28b8:	80 e0       	ldi	r24, 0x00	; 0
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	20 e0       	ldi	r18, 0x00	; 0
    28be:	30 e0       	ldi	r19, 0x00	; 0
    28c0:	40 e0       	ldi	r20, 0x00	; 0
    28c2:	50 e0       	ldi	r21, 0x00	; 0
    28c4:	8e 01       	movw	r16, r28
    28c6:	0f 5f       	subi	r16, 0xFF	; 255
    28c8:	1f 4f       	sbci	r17, 0xFF	; 255
    28ca:	ee 24       	eor	r14, r14
    28cc:	ff 24       	eor	r15, r15
    28ce:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    28d2:	88 23       	and	r24, r24
    28d4:	39 f0       	breq	.+14     	; 0x28e4 <prvNotifiedTask+0x400>
    28d6:	6f e0       	ldi	r22, 0x0F	; 15
    28d8:	71 e0       	ldi	r23, 0x01	; 1

	/* Should not be any notifications pending now. */
	xReturned = xTaskNotifyWait( 0, 0, &ulNotifiedValue, 0 );
    28da:	80 e0       	ldi	r24, 0x00	; 0
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	4c e8       	ldi	r20, 0x8C	; 140
    28e0:	52 e0       	ldi	r21, 0x02	; 2
    28e2:	ea d2       	rcall	.+1492   	; 0x2eb8 <vAssertCalled>
    28e4:	6f ef       	ldi	r22, 0xFF	; 255
    28e6:	7f ef       	ldi	r23, 0xFF	; 255
    28e8:	8f ef       	ldi	r24, 0xFF	; 255
    28ea:	9f ef       	ldi	r25, 0xFF	; 255
    28ec:	20 e0       	ldi	r18, 0x00	; 0
    28ee:	30 e0       	ldi	r19, 0x00	; 0
    28f0:	40 e0       	ldi	r20, 0x00	; 0
    28f2:	50 e0       	ldi	r21, 0x00	; 0
    28f4:	6e 01       	movw	r12, r28
    28f6:	08 94       	sec
	configASSERT( xReturned == pdFAIL );
    28f8:	c1 1c       	adc	r12, r1
    28fa:	d1 1c       	adc	r13, r1
    28fc:	86 01       	movw	r16, r12
    28fe:	ee 24       	eor	r14, r14
    2900:	ff 24       	eor	r15, r15
    2902:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2906:	a1 e0       	ldi	r26, 0x01	; 1
    2908:	4a 2e       	mov	r4, r26
    290a:	51 2c       	mov	r5, r1
	bits are found to be set. */
	ulNotifyingValue = 0x01;
	ulLoop = 0;

	/* Start with all bits clear. */
	xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, 0 );
    290c:	61 2c       	mov	r6, r1
    290e:	71 2c       	mov	r7, r1
    2910:	88 24       	eor	r8, r8
    2912:	99 24       	eor	r9, r9
    2914:	54 01       	movw	r10, r8
    2916:	3c 2c       	mov	r3, r12
    2918:	cd 2c       	mov	r12, r13
    291a:	80 91 fa 1e 	lds	r24, 0x1EFA
    291e:	90 91 fb 1e 	lds	r25, 0x1EFB
    2922:	b3 01       	movw	r22, r6
    2924:	a2 01       	movw	r20, r4
    2926:	21 e0       	ldi	r18, 0x01	; 1
    2928:	30 e0       	ldi	r19, 0x00	; 0
    292a:	00 e0       	ldi	r16, 0x00	; 0
    292c:	10 e0       	ldi	r17, 0x00	; 0
    292e:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2932:	60 e0       	ldi	r22, 0x00	; 0
    2934:	70 e0       	ldi	r23, 0x00	; 0
    2936:	80 e0       	ldi	r24, 0x00	; 0
    2938:	90 e0       	ldi	r25, 0x00	; 0
    293a:	20 e0       	ldi	r18, 0x00	; 0
    293c:	30 e0       	ldi	r19, 0x00	; 0
		xTaskNotify( xTaskToNotify, ulNotifyingValue, eSetBits );

		/* Wait for the notified value - which of course will already be
		available.  Don't clear the bits on entry or exit as this loop is exited
		when all the bits are set. */
		xReturned = xTaskNotifyWait( 0, 0, &ulNotifiedValue, 0 );
    293e:	40 e0       	ldi	r20, 0x00	; 0
    2940:	50 e0       	ldi	r21, 0x00	; 0
	xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, 0 );

	do
	{
		/* Set the next bit in the task's notified value. */
		xTaskNotify( xTaskToNotify, ulNotifyingValue, eSetBits );
    2942:	03 2d       	mov	r16, r3
    2944:	1c 2d       	mov	r17, r12
    2946:	ee 24       	eor	r14, r14
    2948:	ff 24       	eor	r15, r15
    294a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    294e:	81 30       	cpi	r24, 0x01	; 1
    2950:	39 f0       	breq	.+14     	; 0x2960 <prvNotifiedTask+0x47c>
    2952:	68 e2       	ldi	r22, 0x28	; 40
    2954:	71 e0       	ldi	r23, 0x01	; 1
    2956:	80 e0       	ldi	r24, 0x00	; 0
    2958:	90 e0       	ldi	r25, 0x00	; 0

		/* Wait for the notified value - which of course will already be
		available.  Don't clear the bits on entry or exit as this loop is exited
		when all the bits are set. */
		xReturned = xTaskNotifyWait( 0, 0, &ulNotifiedValue, 0 );
    295a:	4c e8       	ldi	r20, 0x8C	; 140
    295c:	52 e0       	ldi	r21, 0x02	; 2
    295e:	ac d2       	rcall	.+1368   	; 0x2eb8 <vAssertCalled>
    2960:	08 94       	sec
    2962:	81 1c       	adc	r8, r1
    2964:	91 1c       	adc	r9, r1
    2966:	a1 1c       	adc	r10, r1
    2968:	b1 1c       	adc	r11, r1
    296a:	89 81       	ldd	r24, Y+1	; 0x01
    296c:	9a 81       	ldd	r25, Y+2	; 0x02
    296e:	ab 81       	ldd	r26, Y+3	; 0x03
    2970:	bc 81       	ldd	r27, Y+4	; 0x04
    2972:	8f 5f       	subi	r24, 0xFF	; 255
    2974:	9f 4f       	sbci	r25, 0xFF	; 255
		configASSERT( xReturned == pdPASS );
    2976:	af 4f       	sbci	r26, 0xFF	; 255
    2978:	bf 4f       	sbci	r27, 0xFF	; 255
    297a:	29 f0       	breq	.+10     	; 0x2986 <prvNotifiedTask+0x4a2>
    297c:	44 0c       	add	r4, r4
    297e:	55 1c       	adc	r5, r5
    2980:	66 1c       	adc	r6, r6
    2982:	77 1c       	adc	r7, r7
    2984:	ca cf       	rjmp	.-108    	; 0x291a <prvNotifiedTask+0x436>
    2986:	80 e2       	ldi	r24, 0x20	; 32
    2988:	88 16       	cp	r8, r24

		ulLoop++;
    298a:	91 04       	cpc	r9, r1
    298c:	a1 04       	cpc	r10, r1
    298e:	b1 04       	cpc	r11, r1
    2990:	39 f0       	breq	.+14     	; 0x29a0 <prvNotifiedTask+0x4bc>
    2992:	63 e3       	ldi	r22, 0x33	; 51

		/* Use the next bit on the next iteration around this loop. */
		ulNotifyingValue <<= 1UL;

	} while ( ulNotifiedValue != notifyUINT32_MAX );
    2994:	71 e0       	ldi	r23, 0x01	; 1
    2996:	80 e0       	ldi	r24, 0x00	; 0
    2998:	90 e0       	ldi	r25, 0x00	; 0
    299a:	4c e8       	ldi	r20, 0x8C	; 140
    299c:	52 e0       	ldi	r21, 0x02	; 2
    299e:	8c d2       	rcall	.+1304   	; 0x2eb8 <vAssertCalled>
    29a0:	61 e0       	ldi	r22, 0x01	; 1
    29a2:	70 e0       	ldi	r23, 0x00	; 0
    29a4:	80 e0       	ldi	r24, 0x00	; 0
		configASSERT( xReturned == pdPASS );

		ulLoop++;

		/* Use the next bit on the next iteration around this loop. */
		ulNotifyingValue <<= 1UL;
    29a6:	90 e0       	ldi	r25, 0x00	; 0
    29a8:	22 e0       	ldi	r18, 0x02	; 2
    29aa:	30 e0       	ldi	r19, 0x00	; 0
    29ac:	40 e0       	ldi	r20, 0x00	; 0
    29ae:	50 e0       	ldi	r21, 0x00	; 0

	} while ( ulNotifiedValue != notifyUINT32_MAX );

	/* As a 32-bit value was used the loop should have executed 32 times before
	all the bits were set. */
	configASSERT( ulLoop == 32 );
    29b0:	8e 01       	movw	r16, r28
    29b2:	0f 5f       	subi	r16, 0xFF	; 255
    29b4:	1f 4f       	sbci	r17, 0xFF	; 255
    29b6:	e4 e6       	ldi	r30, 0x64	; 100
    29b8:	ee 2e       	mov	r14, r30
    29ba:	f1 2c       	mov	r15, r1
    29bc:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    29c0:	88 23       	and	r24, r24
    29c2:	39 f0       	breq	.+14     	; 0x29d2 <prvNotifiedTask+0x4ee>
    29c4:	60 e4       	ldi	r22, 0x40	; 64
    29c6:	71 e0       	ldi	r23, 0x01	; 1
    29c8:	80 e0       	ldi	r24, 0x00	; 0
    29ca:	90 e0       	ldi	r25, 0x00	; 0
	to arrive before timing out - both with and without a timeout value.  Wait
	for the notification again - but this time it is not given by anything and
	should return pdFAIL.  The parameters are set to clear bit zero on entry and
	bit one on exit.  As no notification was received only the bit cleared on
	entry should actually get cleared. */
	xReturned = xTaskNotifyWait( ulBit0, ulBit1, &ulNotifiedValue, xTicksToWait );
    29cc:	4c e8       	ldi	r20, 0x8C	; 140
    29ce:	52 e0       	ldi	r21, 0x02	; 2
    29d0:	73 d2       	rcall	.+1254   	; 0x2eb8 <vAssertCalled>
    29d2:	80 91 fa 1e 	lds	r24, 0x1EFA
    29d6:	90 91 fb 1e 	lds	r25, 0x1EFB
    29da:	4f ef       	ldi	r20, 0xFF	; 255
    29dc:	5f ef       	ldi	r21, 0xFF	; 255
    29de:	6f ef       	ldi	r22, 0xFF	; 255
    29e0:	7f ef       	ldi	r23, 0xFF	; 255
    29e2:	20 e0       	ldi	r18, 0x00	; 0
    29e4:	30 e0       	ldi	r19, 0x00	; 0
    29e6:	00 e0       	ldi	r16, 0x00	; 0
    29e8:	10 e0       	ldi	r17, 0x00	; 0
    29ea:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
	configASSERT( xReturned == pdFAIL );
    29ee:	60 e0       	ldi	r22, 0x00	; 0
    29f0:	70 e0       	ldi	r23, 0x00	; 0
    29f2:	80 e0       	ldi	r24, 0x00	; 0
    29f4:	90 e0       	ldi	r25, 0x00	; 0
    29f6:	20 e0       	ldi	r18, 0x00	; 0
    29f8:	30 e0       	ldi	r19, 0x00	; 0
    29fa:	40 e0       	ldi	r20, 0x00	; 0
    29fc:	50 e0       	ldi	r21, 0x00	; 0
    29fe:	8e 01       	movw	r16, r28

	/* Notify the task with no action so as not to update the bits even though
	notifyUINT32_MAX is used as the notification value. */
	xTaskNotify( xTaskToNotify, notifyUINT32_MAX, eNoAction );
    2a00:	0f 5f       	subi	r16, 0xFF	; 255
    2a02:	1f 4f       	sbci	r17, 0xFF	; 255
    2a04:	ee 24       	eor	r14, r14
    2a06:	ff 24       	eor	r15, r15
    2a08:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2a0c:	81 30       	cpi	r24, 0x01	; 1
    2a0e:	39 f0       	breq	.+14     	; 0x2a1e <prvNotifiedTask+0x53a>
    2a10:	6a e4       	ldi	r22, 0x4A	; 74
    2a12:	71 e0       	ldi	r23, 0x01	; 1
    2a14:	80 e0       	ldi	r24, 0x00	; 0
    2a16:	90 e0       	ldi	r25, 0x00	; 0
    2a18:	4c e8       	ldi	r20, 0x8C	; 140
    2a1a:	52 e0       	ldi	r21, 0x02	; 2

	/* Reading back the value should should find bit 0 is clear, as this was
	cleared on entry, but bit 1 is not clear as it will not have been cleared on
	exit as no notification was received. */
	xReturned = xTaskNotifyWait( 0x00UL, 0x00UL, &ulNotifiedValue, 0 );
    2a1c:	4d d2       	rcall	.+1178   	; 0x2eb8 <vAssertCalled>
    2a1e:	89 81       	ldd	r24, Y+1	; 0x01
    2a20:	9a 81       	ldd	r25, Y+2	; 0x02
    2a22:	ab 81       	ldd	r26, Y+3	; 0x03
    2a24:	bc 81       	ldd	r27, Y+4	; 0x04
    2a26:	8e 5f       	subi	r24, 0xFE	; 254
    2a28:	9f 4f       	sbci	r25, 0xFF	; 255
    2a2a:	af 4f       	sbci	r26, 0xFF	; 255
    2a2c:	bf 4f       	sbci	r27, 0xFF	; 255
    2a2e:	39 f0       	breq	.+14     	; 0x2a3e <prvNotifiedTask+0x55a>
    2a30:	6b e4       	ldi	r22, 0x4B	; 75
    2a32:	71 e0       	ldi	r23, 0x01	; 1
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	90 e0       	ldi	r25, 0x00	; 0
    2a38:	4c e8       	ldi	r20, 0x8C	; 140
	configASSERT( xReturned == pdPASS );
    2a3a:	52 e0       	ldi	r21, 0x02	; 2
    2a3c:	3d d2       	rcall	.+1146   	; 0x2eb8 <vAssertCalled>
    2a3e:	80 91 fa 1e 	lds	r24, 0x1EFA
    2a42:	90 91 fb 1e 	lds	r25, 0x1EFB
    2a46:	40 e0       	ldi	r20, 0x00	; 0
    2a48:	50 e0       	ldi	r21, 0x00	; 0
    2a4a:	60 e0       	ldi	r22, 0x00	; 0
    2a4c:	70 e0       	ldi	r23, 0x00	; 0
	configASSERT( ulNotifiedValue == ( notifyUINT32_MAX & ~ulBit0 ) );
    2a4e:	20 e0       	ldi	r18, 0x00	; 0
    2a50:	30 e0       	ldi	r19, 0x00	; 0
    2a52:	00 e0       	ldi	r16, 0x00	; 0
    2a54:	10 e0       	ldi	r17, 0x00	; 0
    2a56:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2a5a:	60 e0       	ldi	r22, 0x00	; 0
    2a5c:	70 e0       	ldi	r23, 0x00	; 0
    2a5e:	80 e0       	ldi	r24, 0x00	; 0
    2a60:	90 e0       	ldi	r25, 0x00	; 0
    2a62:	22 e0       	ldi	r18, 0x02	; 2
    2a64:	30 e0       	ldi	r19, 0x00	; 0
    2a66:	40 e0       	ldi	r20, 0x00	; 0
    2a68:	50 e0       	ldi	r21, 0x00	; 0
    2a6a:	8e 01       	movw	r16, r28
    2a6c:	0f 5f       	subi	r16, 0xFF	; 255
    2a6e:	1f 4f       	sbci	r17, 0xFF	; 255


	/*--------------------------------------------------------------------------
	Now try clearing the bit on exit.  For that to happen a notification must be
	received, so the task is notified first. */
	xTaskNotify( xTaskToNotify, 0, eNoAction );
    2a70:	ee 24       	eor	r14, r14
    2a72:	ff 24       	eor	r15, r15
    2a74:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2a78:	89 81       	ldd	r24, Y+1	; 0x01
    2a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7c:	ab 81       	ldd	r26, Y+3	; 0x03
    2a7e:	bc 81       	ldd	r27, Y+4	; 0x04
    2a80:	8e 5f       	subi	r24, 0xFE	; 254
    2a82:	9f 4f       	sbci	r25, 0xFF	; 255
    2a84:	af 4f       	sbci	r26, 0xFF	; 255
    2a86:	bf 4f       	sbci	r27, 0xFF	; 255
    2a88:	39 f0       	breq	.+14     	; 0x2a98 <prvNotifiedTask+0x5b4>
    2a8a:	6a e5       	ldi	r22, 0x5A	; 90
	xTaskNotifyWait( 0x00, ulBit1, &ulNotifiedValue, 0 );
    2a8c:	71 e0       	ldi	r23, 0x01	; 1
    2a8e:	80 e0       	ldi	r24, 0x00	; 0
    2a90:	90 e0       	ldi	r25, 0x00	; 0
    2a92:	4c e8       	ldi	r20, 0x8C	; 140
    2a94:	52 e0       	ldi	r21, 0x02	; 2
    2a96:	10 d2       	rcall	.+1056   	; 0x2eb8 <vAssertCalled>
    2a98:	60 e0       	ldi	r22, 0x00	; 0
    2a9a:	70 e0       	ldi	r23, 0x00	; 0
    2a9c:	80 e0       	ldi	r24, 0x00	; 0
    2a9e:	90 e0       	ldi	r25, 0x00	; 0
    2aa0:	20 e0       	ldi	r18, 0x00	; 0
    2aa2:	30 e0       	ldi	r19, 0x00	; 0
    2aa4:	40 e0       	ldi	r20, 0x00	; 0
    2aa6:	50 e0       	ldi	r21, 0x00	; 0
    2aa8:	8e 01       	movw	r16, r28

	/* However as the bit is cleared on exit, after the returned notification
	value is set, the returned notification value should not have the bit
	cleared... */
	configASSERT( ulNotifiedValue == ( notifyUINT32_MAX & ~ulBit0 ) );
    2aaa:	0f 5f       	subi	r16, 0xFF	; 255
    2aac:	1f 4f       	sbci	r17, 0xFF	; 255
    2aae:	ee 24       	eor	r14, r14
    2ab0:	ff 24       	eor	r15, r15
    2ab2:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2ab6:	88 23       	and	r24, r24
    2ab8:	39 f0       	breq	.+14     	; 0x2ac8 <prvNotifiedTask+0x5e4>
    2aba:	60 e6       	ldi	r22, 0x60	; 96
    2abc:	71 e0       	ldi	r23, 0x01	; 1
    2abe:	80 e0       	ldi	r24, 0x00	; 0
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	4c e8       	ldi	r20, 0x8C	; 140
    2ac4:	52 e0       	ldi	r21, 0x02	; 2
    2ac6:	f8 d1       	rcall	.+1008   	; 0x2eb8 <vAssertCalled>
    2ac8:	89 81       	ldd	r24, Y+1	; 0x01
    2aca:	9a 81       	ldd	r25, Y+2	; 0x02

	/* ...but reading the value back again should find that the bit was indeed
	cleared internally.  The returned value should be pdFAIL however as nothing
	has notified the task in the mean time. */
	xReturned = xTaskNotifyWait( 0x00, 0x00, &ulNotifiedValue, 0 );
    2acc:	ab 81       	ldd	r26, Y+3	; 0x03
    2ace:	bc 81       	ldd	r27, Y+4	; 0x04
    2ad0:	8c 5f       	subi	r24, 0xFC	; 252
    2ad2:	9f 4f       	sbci	r25, 0xFF	; 255
    2ad4:	af 4f       	sbci	r26, 0xFF	; 255
    2ad6:	bf 4f       	sbci	r27, 0xFF	; 255
    2ad8:	39 f0       	breq	.+14     	; 0x2ae8 <prvNotifiedTask+0x604>
    2ada:	61 e6       	ldi	r22, 0x61	; 97
    2adc:	71 e0       	ldi	r23, 0x01	; 1
    2ade:	80 e0       	ldi	r24, 0x00	; 0
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	4c e8       	ldi	r20, 0x8C	; 140
    2ae4:	52 e0       	ldi	r21, 0x02	; 2
    2ae6:	e8 d1       	rcall	.+976    	; 0x2eb8 <vAssertCalled>
    2ae8:	80 91 fa 1e 	lds	r24, 0x1EFA
	configASSERT( xReturned == pdFAIL );
    2aec:	90 91 fb 1e 	lds	r25, 0x1EFB
    2af0:	40 e0       	ldi	r20, 0x00	; 0
    2af2:	50 e0       	ldi	r21, 0x00	; 0
    2af4:	60 e0       	ldi	r22, 0x00	; 0
    2af6:	70 e0       	ldi	r23, 0x00	; 0
    2af8:	21 e0       	ldi	r18, 0x01	; 1
    2afa:	30 e0       	ldi	r19, 0x00	; 0
    2afc:	8e 01       	movw	r16, r28
	configASSERT( ulNotifiedValue == ( notifyUINT32_MAX & ~( ulBit0 | ulBit1 ) ) );
    2afe:	0b 5f       	subi	r16, 0xFB	; 251
    2b00:	1f 4f       	sbci	r17, 0xFF	; 255
    2b02:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2b06:	89 81       	ldd	r24, Y+1	; 0x01
    2b08:	9a 81       	ldd	r25, Y+2	; 0x02
    2b0a:	ab 81       	ldd	r26, Y+3	; 0x03
    2b0c:	bc 81       	ldd	r27, Y+4	; 0x04
    2b0e:	8c 5f       	subi	r24, 0xFC	; 252
    2b10:	9f 4f       	sbci	r25, 0xFF	; 255
    2b12:	af 4f       	sbci	r26, 0xFF	; 255
    2b14:	bf 4f       	sbci	r27, 0xFF	; 255
    2b16:	39 f0       	breq	.+14     	; 0x2b26 <prvNotifiedTask+0x642>
    2b18:	69 e6       	ldi	r22, 0x69	; 105
    2b1a:	71 e0       	ldi	r23, 0x01	; 1
    2b1c:	80 e0       	ldi	r24, 0x00	; 0
    2b1e:	90 e0       	ldi	r25, 0x00	; 0



	/*--------------------------------------------------------------------------
	Now try querying the previus value while notifying a task. */
	xTaskNotifyAndQuery( xTaskToNotify, 0x00, eSetBits, &ulPreviousValue );
    2b20:	4c e8       	ldi	r20, 0x8C	; 140
    2b22:	52 e0       	ldi	r21, 0x02	; 2
    2b24:	c9 d1       	rcall	.+914    	; 0x2eb8 <vAssertCalled>
    2b26:	60 e0       	ldi	r22, 0x00	; 0
    2b28:	70 e0       	ldi	r23, 0x00	; 0
    2b2a:	80 e0       	ldi	r24, 0x00	; 0
    2b2c:	90 e0       	ldi	r25, 0x00	; 0
    2b2e:	2f ef       	ldi	r18, 0xFF	; 255
    2b30:	3f ef       	ldi	r19, 0xFF	; 255
    2b32:	4f ef       	ldi	r20, 0xFF	; 255
    2b34:	5f ef       	ldi	r21, 0xFF	; 255
    2b36:	8e 01       	movw	r16, r28
    2b38:	0f 5f       	subi	r16, 0xFF	; 255
    2b3a:	1f 4f       	sbci	r17, 0xFF	; 255
    2b3c:	ee 24       	eor	r14, r14
	configASSERT( ulNotifiedValue == ( notifyUINT32_MAX & ~( ulBit0 | ulBit1 ) ) );
    2b3e:	ff 24       	eor	r15, r15
    2b40:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2b44:	80 91 fa 1e 	lds	r24, 0x1EFA
    2b48:	90 91 fb 1e 	lds	r25, 0x1EFB
    2b4c:	40 e0       	ldi	r20, 0x00	; 0
    2b4e:	50 e0       	ldi	r21, 0x00	; 0
    2b50:	60 e0       	ldi	r22, 0x00	; 0
    2b52:	70 e0       	ldi	r23, 0x00	; 0
    2b54:	21 e0       	ldi	r18, 0x01	; 1
    2b56:	30 e0       	ldi	r19, 0x00	; 0
    2b58:	8e 01       	movw	r16, r28
    2b5a:	0b 5f       	subi	r16, 0xFB	; 251
    2b5c:	1f 4f       	sbci	r17, 0xFF	; 255
    2b5e:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>

	/* Clear all bits. */
	xTaskNotifyWait( 0x00, notifyUINT32_MAX, &ulNotifiedValue, 0 );
    2b62:	8d 81       	ldd	r24, Y+5	; 0x05
    2b64:	9e 81       	ldd	r25, Y+6	; 0x06
    2b66:	af 81       	ldd	r26, Y+7	; 0x07
    2b68:	b8 85       	ldd	r27, Y+8	; 0x08
    2b6a:	00 97       	sbiw	r24, 0x00	; 0
    2b6c:	a1 05       	cpc	r26, r1
    2b6e:	b1 05       	cpc	r27, r1
    2b70:	39 f0       	breq	.+14     	; 0x2b80 <prvNotifiedTask+0x69c>
    2b72:	6e e6       	ldi	r22, 0x6E	; 110
    2b74:	71 e0       	ldi	r23, 0x01	; 1
    2b76:	80 e0       	ldi	r24, 0x00	; 0
    2b78:	90 e0       	ldi	r25, 0x00	; 0
    2b7a:	4c e8       	ldi	r20, 0x8C	; 140
    2b7c:	52 e0       	ldi	r21, 0x02	; 2
	xTaskNotifyAndQuery( xTaskToNotify, 0x00, eSetBits, &ulPreviousValue );
    2b7e:	9c d1       	rcall	.+824    	; 0x2eb8 <vAssertCalled>
    2b80:	81 e0       	ldi	r24, 0x01	; 1
    2b82:	c8 2e       	mov	r12, r24
    2b84:	d1 2c       	mov	r13, r1
    2b86:	e1 2c       	mov	r14, r1
    2b88:	f1 2c       	mov	r15, r1
    2b8a:	88 24       	eor	r8, r8
    2b8c:	99 24       	eor	r9, r9
    2b8e:	54 01       	movw	r10, r8
    2b90:	66 24       	eor	r6, r6
    2b92:	77 24       	eor	r7, r7
    2b94:	05 e0       	ldi	r16, 0x05	; 5
    2b96:	40 2e       	mov	r4, r16
    2b98:	51 2c       	mov	r5, r1
    2b9a:	4c 0e       	add	r4, r28
	configASSERT( ulPreviousValue == 0 );
    2b9c:	5d 1e       	adc	r5, r29
    2b9e:	80 91 fa 1e 	lds	r24, 0x1EFA
    2ba2:	90 91 fb 1e 	lds	r25, 0x1EFB
    2ba6:	b7 01       	movw	r22, r14
    2ba8:	a6 01       	movw	r20, r12
    2baa:	21 e0       	ldi	r18, 0x01	; 1
    2bac:	30 e0       	ldi	r19, 0x00	; 0
    2bae:	82 01       	movw	r16, r4
    2bb0:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2bb4:	8d 81       	ldd	r24, Y+5	; 0x05
    2bb6:	9e 81       	ldd	r25, Y+6	; 0x06
    2bb8:	af 81       	ldd	r26, Y+7	; 0x07
    2bba:	b8 85       	ldd	r27, Y+8	; 0x08
    2bbc:	88 16       	cp	r8, r24
    2bbe:	99 06       	cpc	r9, r25
    2bc0:	aa 06       	cpc	r10, r26
    2bc2:	bb 06       	cpc	r11, r27
    2bc4:	39 f0       	breq	.+14     	; 0x2bd4 <prvNotifiedTask+0x6f0>
    2bc6:	67 e7       	ldi	r22, 0x77	; 119
    2bc8:	71 e0       	ldi	r23, 0x01	; 1
    2bca:	80 e0       	ldi	r24, 0x00	; 0
    2bcc:	90 e0       	ldi	r25, 0x00	; 0
    2bce:	4c e8       	ldi	r20, 0x8C	; 140
	for( ulLoop = 0x01; ulLoop < 0x80UL; ulLoop <<= 1UL )
	{
		/* Set the next bit up, and expect to receive the last bits set (so
		the previous value will not yet have the bit being set this time
		around). */
		xTaskNotifyAndQuery( xTaskToNotify, ulLoop, eSetBits, &ulPreviousValue );
    2bd0:	52 e0       	ldi	r21, 0x02	; 2
    2bd2:	72 d1       	rcall	.+740    	; 0x2eb8 <vAssertCalled>
    2bd4:	d7 01       	movw	r26, r14
    2bd6:	c6 01       	movw	r24, r12
    2bd8:	88 0f       	add	r24, r24
    2bda:	99 1f       	adc	r25, r25
    2bdc:	aa 1f       	adc	r26, r26
    2bde:	bb 1f       	adc	r27, r27
    2be0:	08 94       	sec
    2be2:	61 1c       	adc	r6, r1
    2be4:	71 1c       	adc	r7, r1
    2be6:	27 e0       	ldi	r18, 0x07	; 7
    2be8:	62 16       	cp	r6, r18
    2bea:	71 04       	cpc	r7, r1
    2bec:	39 f0       	breq	.+14     	; 0x2bfc <prvNotifiedTask+0x718>
    2bee:	8c 28       	or	r8, r12
		configASSERT( ulExpectedValue == ulPreviousValue );
    2bf0:	9d 28       	or	r9, r13
    2bf2:	ae 28       	or	r10, r14
    2bf4:	bf 28       	or	r11, r15
    2bf6:	6c 01       	movw	r12, r24
    2bf8:	7d 01       	movw	r14, r26
    2bfa:	d1 cf       	rjmp	.-94     	; 0x2b9e <prvNotifiedTask+0x6ba>
    2bfc:	6f ef       	ldi	r22, 0xFF	; 255
    2bfe:	7f ef       	ldi	r23, 0xFF	; 255
    2c00:	8f ef       	ldi	r24, 0xFF	; 255
    2c02:	9f ef       	ldi	r25, 0xFF	; 255
    2c04:	20 e0       	ldi	r18, 0x00	; 0
    2c06:	30 e0       	ldi	r19, 0x00	; 0
    2c08:	40 e0       	ldi	r20, 0x00	; 0
    2c0a:	50 e0       	ldi	r21, 0x00	; 0
    2c0c:	8e 01       	movw	r16, r28
    2c0e:	0f 5f       	subi	r16, 0xFF	; 255
    2c10:	1f 4f       	sbci	r17, 0xFF	; 255
	xTaskNotifyWait( 0x00, notifyUINT32_MAX, &ulNotifiedValue, 0 );
	xTaskNotifyAndQuery( xTaskToNotify, 0x00, eSetBits, &ulPreviousValue );
	configASSERT( ulPreviousValue == 0 );

	ulExpectedValue = 0;
	for( ulLoop = 0x01; ulLoop < 0x80UL; ulLoop <<= 1UL )
    2c12:	ee 24       	eor	r14, r14
    2c14:	ff 24       	eor	r15, r15
    2c16:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2c1a:	80 e0       	ldi	r24, 0x00	; 0
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	0e 94 1f 07 	call	0xe3e	; 0xe3e <xTaskNotifyStateClear>
    2c22:	88 23       	and	r24, r24
    2c24:	39 f0       	breq	.+14     	; 0x2c34 <prvNotifiedTask+0x750>
    2c26:	63 e8       	ldi	r22, 0x83	; 131
    2c28:	71 e0       	ldi	r23, 0x01	; 1
    2c2a:	80 e0       	ldi	r24, 0x00	; 0
		/* Set the next bit up, and expect to receive the last bits set (so
		the previous value will not yet have the bit being set this time
		around). */
		xTaskNotifyAndQuery( xTaskToNotify, ulLoop, eSetBits, &ulPreviousValue );
		configASSERT( ulExpectedValue == ulPreviousValue );
		ulExpectedValue |= ulLoop;
    2c2c:	90 e0       	ldi	r25, 0x00	; 0
    2c2e:	4c e8       	ldi	r20, 0x8C	; 140
    2c30:	52 e0       	ldi	r21, 0x02	; 2
    2c32:	42 d1       	rcall	.+644    	; 0x2eb8 <vAssertCalled>
    2c34:	80 91 fa 1e 	lds	r24, 0x1EFA
    2c38:	90 91 fb 1e 	lds	r25, 0x1EFB



	/* -------------------------------------------------------------------------
	Clear the previous notifications. */
	xTaskNotifyWait( notifyUINT32_MAX, 0, &ulNotifiedValue, 0 );
    2c3c:	41 ea       	ldi	r20, 0xA1	; 161
    2c3e:	56 e8       	ldi	r21, 0x86	; 134
    2c40:	61 e0       	ldi	r22, 0x01	; 1
    2c42:	70 e0       	ldi	r23, 0x00	; 0
    2c44:	24 e0       	ldi	r18, 0x04	; 4
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	8e 01       	movw	r16, r28
    2c4a:	0b 5f       	subi	r16, 0xFB	; 251
    2c4c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c4e:	0e 94 34 09 	call	0x1268	; 0x1268 <xTaskGenericNotify>
    2c52:	80 e0       	ldi	r24, 0x00	; 0
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	0e 94 1f 07 	call	0xe3e	; 0xe3e <xTaskNotifyStateClear>

	/* The task should not have any notifications pending, so an attempt to clear
	the notification state should fail. */
	configASSERT( xTaskNotifyStateClear( NULL ) == pdFALSE );
    2c5a:	81 30       	cpi	r24, 0x01	; 1
    2c5c:	39 f0       	breq	.+14     	; 0x2c6c <prvNotifiedTask+0x788>
    2c5e:	6b e8       	ldi	r22, 0x8B	; 139
    2c60:	71 e0       	ldi	r23, 0x01	; 1
    2c62:	80 e0       	ldi	r24, 0x00	; 0
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	4c e8       	ldi	r20, 0x8C	; 140
    2c68:	52 e0       	ldi	r21, 0x02	; 2
    2c6a:	26 d1       	rcall	.+588    	; 0x2eb8 <vAssertCalled>
    2c6c:	80 e0       	ldi	r24, 0x00	; 0
    2c6e:	90 e0       	ldi	r25, 0x00	; 0
    2c70:	0e 94 1f 07 	call	0xe3e	; 0xe3e <xTaskNotifyStateClear>

	/* Get the task to notify itself.  This is not a normal thing to do, and is
	only done here for test purposes. */
	xTaskNotifyAndQuery( xTaskToNotify, ulFirstNotifiedConst, eSetValueWithoutOverwrite, &ulPreviousValue );
    2c74:	88 23       	and	r24, r24
    2c76:	39 f0       	breq	.+14     	; 0x2c86 <prvNotifiedTask+0x7a2>
    2c78:	6c e8       	ldi	r22, 0x8C	; 140
    2c7a:	71 e0       	ldi	r23, 0x01	; 1
    2c7c:	80 e0       	ldi	r24, 0x00	; 0
    2c7e:	90 e0       	ldi	r25, 0x00	; 0
    2c80:	4c e8       	ldi	r20, 0x8C	; 140
    2c82:	52 e0       	ldi	r21, 0x02	; 2
    2c84:	19 d1       	rcall	.+562    	; 0x2eb8 <vAssertCalled>
    2c86:	80 91 e8 1e 	lds	r24, 0x1EE8
    2c8a:	90 91 e9 1e 	lds	r25, 0x1EE9
    2c8e:	a0 91 ea 1e 	lds	r26, 0x1EEA

	/* Now the notification state should be eNotified, so it should now be
	possible to clear the notification state. */
	configASSERT( xTaskNotifyStateClear( NULL ) == pdTRUE );
    2c92:	b0 91 eb 1e 	lds	r27, 0x1EEB
    2c96:	01 96       	adiw	r24, 0x01	; 1
    2c98:	a1 1d       	adc	r26, r1
    2c9a:	b1 1d       	adc	r27, r1
    2c9c:	80 93 e8 1e 	sts	0x1EE8, r24
    2ca0:	90 93 e9 1e 	sts	0x1EE9, r25
    2ca4:	a0 93 ea 1e 	sts	0x1EEA, r26
    2ca8:	b0 93 eb 1e 	sts	0x1EEB, r27
    2cac:	6f ef       	ldi	r22, 0xFF	; 255
	configASSERT( xTaskNotifyStateClear( NULL ) == pdFALSE );
    2cae:	7f ef       	ldi	r23, 0xFF	; 255
    2cb0:	8f ef       	ldi	r24, 0xFF	; 255
    2cb2:	9f ef       	ldi	r25, 0xFF	; 255
    2cb4:	20 e0       	ldi	r18, 0x00	; 0
    2cb6:	30 e0       	ldi	r19, 0x00	; 0
    2cb8:	40 e0       	ldi	r20, 0x00	; 0
    2cba:	50 e0       	ldi	r21, 0x00	; 0
    2cbc:	00 e0       	ldi	r16, 0x00	; 0
    2cbe:	10 e0       	ldi	r17, 0x00	; 0
    2cc0:	ee 24       	eor	r14, r14
    2cc2:	ff 24       	eor	r15, r15
    2cc4:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <xTaskNotifyWait>
    2cc8:	82 ec       	ldi	r24, 0xC2	; 194




	/* Incremented to show the task is still running. */
	ulNotifyCycleCount++;
    2cca:	92 e0       	ldi	r25, 0x02	; 2
    2ccc:	6a e5       	ldi	r22, 0x5A	; 90
    2cce:	70 e0       	ldi	r23, 0x00	; 0
    2cd0:	40 e0       	ldi	r20, 0x00	; 0
    2cd2:	20 e0       	ldi	r18, 0x00	; 0
    2cd4:	30 e0       	ldi	r19, 0x00	; 0
    2cd6:	07 e4       	ldi	r16, 0x47	; 71
    2cd8:	12 e1       	ldi	r17, 0x12	; 18
    2cda:	be d8       	rcall	.-3716   	; 0x1e58 <xTimerCreate>
    2cdc:	90 93 f9 1e 	sts	0x1EF9, r25
    2ce0:	80 93 f8 1e 	sts	0x1EF8, r24
    2ce4:	a5 e3       	ldi	r26, 0x35	; 53
    2ce6:	8a 2e       	mov	r8, r26
    2ce8:	ae e4       	ldi	r26, 0x4E	; 78
    2cea:	9a 2e       	mov	r9, r26
    2cec:	80 91 fe 1e 	lds	r24, 0x1EFE

	/* Leave all bits cleared. */
	xTaskNotifyWait( notifyUINT32_MAX, 0, NULL, 0 );
    2cf0:	90 91 ff 1e 	lds	r25, 0x1EFF
    2cf4:	9c 01       	movw	r18, r24
    2cf6:	28 9d       	mul	r18, r8
    2cf8:	c0 01       	movw	r24, r0
    2cfa:	29 9d       	mul	r18, r9
    2cfc:	90 0d       	add	r25, r0
    2cfe:	38 9d       	mul	r19, r8
    2d00:	90 0d       	add	r25, r0
    2d02:	11 24       	eor	r1, r1
    2d04:	01 96       	adiw	r24, 0x01	; 1
    2d06:	90 93 ff 1e 	sts	0x1EFF, r25
    2d0a:	80 93 fe 1e 	sts	0x1EFE, r24
	main loop. */
	prvSingleTaskTests();

	/* Create the software timer that is used to send notifications to this
	task.  Notifications are also received from an interrupt. */
	xTimer = xTimerCreate( "Notifier", xMaxPeriod, pdFALSE, NULL, prvNotifyingTimer );
    2d0e:	80 91 f8 1e 	lds	r24, 0x1EF8
    2d12:	90 91 f9 1e 	lds	r25, 0x1EF9
    2d16:	64 e0       	ldi	r22, 0x04	; 4
    2d18:	4a e0       	ldi	r20, 0x0A	; 10
    2d1a:	50 e0       	ldi	r21, 0x00	; 0
    2d1c:	20 e0       	ldi	r18, 0x00	; 0
    2d1e:	30 e0       	ldi	r19, 0x00	; 0
    2d20:	0f ef       	ldi	r16, 0xFF	; 255
    2d22:	1f ef       	ldi	r17, 0xFF	; 255
    2d24:	0e d8       	rcall	.-4068   	; 0x1d42 <xTimerGenericCommand>
    2d26:	80 91 fe 1e 	lds	r24, 0x1EFE
static UBaseType_t prvRand( void )
{
const size_t uxMultiplier = ( size_t ) 0x015a4e35, uxIncrement = ( size_t ) 1;

	/* Utility function to generate a pseudo random number. */
	uxNextRand = ( uxMultiplier * uxNextRand ) + uxIncrement;
    2d2a:	90 91 ff 1e 	lds	r25, 0x1EFF
    2d2e:	9c 01       	movw	r18, r24
    2d30:	28 9d       	mul	r18, r8
    2d32:	c0 01       	movw	r24, r0
    2d34:	29 9d       	mul	r18, r9
    2d36:	90 0d       	add	r25, r0
    2d38:	38 9d       	mul	r19, r8
    2d3a:	90 0d       	add	r25, r0
    2d3c:	11 24       	eor	r1, r1
    2d3e:	01 96       	adiw	r24, 0x01	; 1
    2d40:	90 93 ff 1e 	sts	0x1EFF, r25
    2d44:	80 93 fe 1e 	sts	0x1EFE, r24
    2d48:	fa e0       	ldi	r31, 0x0A	; 10
    2d4a:	cf 2e       	mov	r12, r31
    2d4c:	d1 2c       	mov	r13, r1
    2d4e:	80 e0       	ldi	r24, 0x00	; 0
    2d50:	b6 01       	movw	r22, r12
    2d52:	0e 94 02 0b 	call	0x1604	; 0x1604 <ulTaskNotifyTake>
		{
			xPeriod = xMinPeriod;
		}

		/* Change the timer period and start the timer. */
		xTimerChangePeriod( xTimer, xPeriod, portMAX_DELAY );
    2d56:	61 15       	cp	r22, r1
    2d58:	71 05       	cpc	r23, r1
    2d5a:	81 05       	cpc	r24, r1
    2d5c:	91 05       	cpc	r25, r1
    2d5e:	99 f0       	breq	.+38     	; 0x2d86 <prvNotifiedTask+0x8a2>
    2d60:	80 91 f0 1e 	lds	r24, 0x1EF0
    2d64:	90 91 f1 1e 	lds	r25, 0x1EF1
    2d68:	a0 91 f2 1e 	lds	r26, 0x1EF2
    2d6c:	b0 91 f3 1e 	lds	r27, 0x1EF3
static UBaseType_t prvRand( void )
{
const size_t uxMultiplier = ( size_t ) 0x015a4e35, uxIncrement = ( size_t ) 1;

	/* Utility function to generate a pseudo random number. */
	uxNextRand = ( uxMultiplier * uxNextRand ) + uxIncrement;
    2d70:	01 96       	adiw	r24, 0x01	; 1
    2d72:	a1 1d       	adc	r26, r1
    2d74:	b1 1d       	adc	r27, r1
    2d76:	80 93 f0 1e 	sts	0x1EF0, r24
    2d7a:	90 93 f1 1e 	sts	0x1EF1, r25
    2d7e:	a0 93 f2 1e 	sts	0x1EF2, r26
    2d82:	b0 93 f3 1e 	sts	0x1EF3, r27
    2d86:	80 e0       	ldi	r24, 0x00	; 0
    2d88:	60 e0       	ldi	r22, 0x00	; 0
    2d8a:	70 e0       	ldi	r23, 0x00	; 0
    2d8c:	0e 94 02 0b 	call	0x1604	; 0x1604 <ulTaskNotifyTake>

		/* Block waiting for the notification again with a different period.
		Sometimes the period will be higher than the tasks block time, sometimes
		it will be lower than the tasks block time. */
		xPeriod = prvRand() % xMaxPeriod;
		if( xPeriod < xMinPeriod )
    2d90:	61 15       	cp	r22, r1
    2d92:	71 05       	cpc	r23, r1
    2d94:	81 05       	cpc	r24, r1
		}

		/* Block to wait for a notification but without clearing the
		notification count, so only add one to the count of received
		notifications as any other notifications will remain pending. */
		if( ulTaskNotifyTake( pdFALSE, xPeriod ) != 0 )
    2d96:	91 05       	cpc	r25, r1
    2d98:	99 f0       	breq	.+38     	; 0x2dc0 <prvNotifiedTask+0x8dc>
    2d9a:	80 91 f0 1e 	lds	r24, 0x1EF0
    2d9e:	90 91 f1 1e 	lds	r25, 0x1EF1
    2da2:	a0 91 f2 1e 	lds	r26, 0x1EF2
    2da6:	b0 91 f3 1e 	lds	r27, 0x1EF3
		{
			ulTimerNotificationsReceived++;
    2daa:	01 96       	adiw	r24, 0x01	; 1
    2dac:	a1 1d       	adc	r26, r1
    2dae:	b1 1d       	adc	r27, r1
    2db0:	80 93 f0 1e 	sts	0x1EF0, r24
    2db4:	90 93 f1 1e 	sts	0x1EF1, r25
    2db8:	a0 93 f2 1e 	sts	0x1EF2, r26
    2dbc:	b0 93 f3 1e 	sts	0x1EF3, r27
    2dc0:	e0 90 f0 1e 	lds	r14, 0x1EF0
    2dc4:	f0 90 f1 1e 	lds	r15, 0x1EF1
    2dc8:	00 91 f2 1e 	lds	r16, 0x1EF2
    2dcc:	10 91 f3 1e 	lds	r17, 0x1EF3
		}


		/* Take a notification without clearing again, but this time without a
		block time specified. */
		if( ulTaskNotifyTake( pdFALSE, xDontBlock ) != 0 )
    2dd0:	81 e0       	ldi	r24, 0x01	; 1
    2dd2:	b6 01       	movw	r22, r12
    2dd4:	0e 94 02 0b 	call	0x1604	; 0x1604 <ulTaskNotifyTake>
    2dd8:	5b 01       	movw	r10, r22
    2dda:	6c 01       	movw	r12, r24
    2ddc:	ae 0c       	add	r10, r14
    2dde:	bf 1c       	adc	r11, r15
    2de0:	c0 1e       	adc	r12, r16
		{
			ulTimerNotificationsReceived++;
    2de2:	d1 1e       	adc	r13, r17
    2de4:	a0 92 f0 1e 	sts	0x1EF0, r10
    2de8:	b0 92 f1 1e 	sts	0x1EF1, r11
    2dec:	c0 92 f2 1e 	sts	0x1EF2, r12
    2df0:	d0 92 f3 1e 	sts	0x1EF3, r13
    2df4:	60 91 e8 1e 	lds	r22, 0x1EE8
    2df8:	70 91 e9 1e 	lds	r23, 0x1EE9
    2dfc:	80 91 ea 1e 	lds	r24, 0x1EEA
    2e00:	90 91 eb 1e 	lds	r25, 0x1EEB
    2e04:	22 e3       	ldi	r18, 0x32	; 50
    2e06:	30 e0       	ldi	r19, 0x00	; 0

		/* Wait for the next notification from the timer, clearing all
		notifications if one is received, so this time adding the total number
		of notifications that were pending as none will be left pending after
		the function call. */
		ulTimerNotificationsReceived += ulTaskNotifyTake( pdTRUE, xPeriod );
    2e08:	40 e0       	ldi	r20, 0x00	; 0
    2e0a:	50 e0       	ldi	r21, 0x00	; 0
    2e0c:	a8 d0       	rcall	.+336    	; 0x2f5e <__udivmodsi4>
    2e0e:	61 15       	cp	r22, r1
    2e10:	71 05       	cpc	r23, r1
    2e12:	81 05       	cpc	r24, r1
    2e14:	91 05       	cpc	r25, r1
    2e16:	41 f5       	brne	.+80     	; 0x2e68 <prvNotifiedTask+0x984>
    2e18:	80 91 fa 1e 	lds	r24, 0x1EFA
    2e1c:	90 91 fb 1e 	lds	r25, 0x1EFB
    2e20:	63 e0       	ldi	r22, 0x03	; 3
    2e22:	0e 94 ca 09 	call	0x1394	; 0x1394 <vTaskPrioritySet>
    2e26:	e0 90 f0 1e 	lds	r14, 0x1EF0
    2e2a:	f0 90 f1 1e 	lds	r15, 0x1EF1
    2e2e:	00 91 f2 1e 	lds	r16, 0x1EF2
    2e32:	10 91 f3 1e 	lds	r17, 0x1EF3
    2e36:	81 e0       	ldi	r24, 0x01	; 1
    2e38:	6f ef       	ldi	r22, 0xFF	; 255
    2e3a:	7f ef       	ldi	r23, 0xFF	; 255
		/* Occasionally raise the priority of the task being notified to test
		the path where the task is notified from an ISR and becomes the highest
		priority ready state task, but the pxHigherPriorityTaskWoken parameter
		is NULL (which it is in the tick hook that sends notifications to this
		task). */
		if( ( ulNotifyCycleCount % ulCyclesToRaisePriority ) == 0 )
    2e3c:	0e 94 02 0b 	call	0x1604	; 0x1604 <ulTaskNotifyTake>
    2e40:	e6 0e       	add	r14, r22
    2e42:	f7 1e       	adc	r15, r23
    2e44:	08 1f       	adc	r16, r24
    2e46:	19 1f       	adc	r17, r25
    2e48:	e0 92 f0 1e 	sts	0x1EF0, r14
    2e4c:	f0 92 f1 1e 	sts	0x1EF1, r15
    2e50:	00 93 f2 1e 	sts	0x1EF2, r16
    2e54:	10 93 f3 1e 	sts	0x1EF3, r17
    2e58:	80 91 fa 1e 	lds	r24, 0x1EFA
    2e5c:	90 91 fb 1e 	lds	r25, 0x1EFB
    2e60:	60 e0       	ldi	r22, 0x00	; 0
		{
			vTaskPrioritySet( xTaskToNotify, configMAX_PRIORITIES - 1 );
    2e62:	0e 94 ca 09 	call	0x1394	; 0x1394 <vTaskPrioritySet>
    2e66:	11 c0       	rjmp	.+34     	; 0x2e8a <prvNotifiedTask+0x9a6>
    2e68:	81 e0       	ldi	r24, 0x01	; 1
    2e6a:	6f ef       	ldi	r22, 0xFF	; 255
    2e6c:	7f ef       	ldi	r23, 0xFF	; 255
    2e6e:	0e 94 02 0b 	call	0x1604	; 0x1604 <ulTaskNotifyTake>

			/* Wait for the next notification again, clearing all notifications if
			one is received, but this time blocking indefinitely. */
			ulTimerNotificationsReceived += ulTaskNotifyTake( pdTRUE, portMAX_DELAY );
    2e72:	a6 0e       	add	r10, r22
    2e74:	b7 1e       	adc	r11, r23
    2e76:	c8 1e       	adc	r12, r24
    2e78:	d9 1e       	adc	r13, r25
    2e7a:	a0 92 f0 1e 	sts	0x1EF0, r10
    2e7e:	b0 92 f1 1e 	sts	0x1EF1, r11
    2e82:	c0 92 f2 1e 	sts	0x1EF2, r12
    2e86:	d0 92 f3 1e 	sts	0x1EF3, r13
    2e8a:	80 91 e8 1e 	lds	r24, 0x1EE8
    2e8e:	90 91 e9 1e 	lds	r25, 0x1EE9
    2e92:	a0 91 ea 1e 	lds	r26, 0x1EEA
    2e96:	b0 91 eb 1e 	lds	r27, 0x1EEB
    2e9a:	01 96       	adiw	r24, 0x01	; 1
    2e9c:	a1 1d       	adc	r26, r1
    2e9e:	b1 1d       	adc	r27, r1
    2ea0:	80 93 e8 1e 	sts	0x1EE8, r24

			/* Reset the priority. */
			vTaskPrioritySet( xTaskToNotify, notifyTASK_PRIORITY );
    2ea4:	90 93 e9 1e 	sts	0x1EE9, r25
    2ea8:	a0 93 ea 1e 	sts	0x1EEA, r26
    2eac:	b0 93 eb 1e 	sts	0x1EEB, r27
    2eb0:	1d cf       	rjmp	.-454    	; 0x2cec <prvNotifiedTask+0x808>

00002eb2 <vApplicationIdleHook>:
void vApplicationIdleHook( void )
{
#if( mainDEMO_COROUTINE == 1 )
	vCoRoutineSchedule();
#endif
}
    2eb2:	08 95       	ret

00002eb4 <vApplicationTickHook>:
	vInterruptSemaphorePeriodicTest();
#endif

#if ( mainDEMOFULL_NOTIFYTASK == 1 )
	/* Exercise using task notifications from an interrupt. */
	xNotifyTaskFromISR();
    2eb4:	45 ca       	rjmp	.-2934   	; 0x2340 <xNotifyTaskFromISR>
    2eb6:	08 95       	ret

00002eb8 <vAssertCalled>:
{
	/* Parameters are not used. */
	( void ) ulLine;
	( void ) pcFileName;

	vParTestToggleLED(mainASSERTCALLED_LED);
    2eb8:	87 e0       	ldi	r24, 0x07	; 7
    2eba:	0c 94 34 01 	jmp	0x268	; 0x268 <vParTestToggleLED>

00002ebe <main>:
#endif

/*-----------------------------------------------------------*/

int main( void )
{
    2ebe:	ef 92       	push	r14
    2ec0:	ff 92       	push	r15
    2ec2:	0f 93       	push	r16
	/* Setup the LED's for output. */
	vParTestInitialise();
    2ec4:	0e 94 2a 01 	call	0x254	; 0x254 <vParTestInitialise>
	memcpy(pcStatusMessage,pcErrorOK,mainERRORSIZE);
    2ec8:	a0 e0       	ldi	r26, 0x00	; 0
    2eca:	bf e1       	ldi	r27, 0x1F	; 31
    2ecc:	80 91 14 03 	lds	r24, 0x0314
    2ed0:	90 91 15 03 	lds	r25, 0x0315
    2ed4:	9c 01       	movw	r18, r24
    2ed6:	f9 01       	movw	r30, r18
    2ed8:	80 e2       	ldi	r24, 0x20	; 32
    2eda:	01 90       	ld	r0, Z+
    2edc:	0d 92       	st	X+, r0
    2ede:	81 50       	subi	r24, 0x01	; 1
    2ee0:	e1 f7       	brne	.-8      	; 0x2eda <main+0x1c>
#endif
#endif //mainDEMOAVR323

#if ( mainDEMOFULL == 1 )
	/* Start the check task as described at the top of this file. */
	xTaskCreate( prvCheckTask, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
    2ee2:	87 e8       	ldi	r24, 0x87	; 135
    2ee4:	97 e1       	ldi	r25, 0x17	; 23
    2ee6:	6b ec       	ldi	r22, 0xCB	; 203
    2ee8:	72 e0       	ldi	r23, 0x02	; 2
    2eea:	45 e5       	ldi	r20, 0x55	; 85
    2eec:	50 e0       	ldi	r21, 0x00	; 0
    2eee:	20 e0       	ldi	r18, 0x00	; 0
    2ef0:	30 e0       	ldi	r19, 0x00	; 0
    2ef2:	03 e0       	ldi	r16, 0x03	; 3
    2ef4:	ee 24       	eor	r14, r14
    2ef6:	ff 24       	eor	r15, r15
    2ef8:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskCreate>
#if ( mainDEMOFULL_NOTIFYTASK == 1 )
	vStartTaskNotifyTask();
    2efc:	ad da       	rcall	.-2726   	; 0x2458 <vStartTaskNotifyTask>
    2efe:	0e 94 6c 0e 	call	0x1cd8	; 0x1cd8 <vTaskStartScheduler>
#endif

	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION
	as 1 in portmacro.h.  To use the cooperative scheduler define
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    2f02:	80 e0       	ldi	r24, 0x00	; 0

	return 0;
}
    2f04:	90 e0       	ldi	r25, 0x00	; 0
    2f06:	0f 91       	pop	r16
    2f08:	ff 90       	pop	r15
    2f0a:	ef 90       	pop	r14
    2f0c:	08 95       	ret

00002f0e <prvCheckTask>:
}

/*-----------------------------------------------------------*/

static void prvCheckTask( void *pvParameters )
{
    2f0e:	0f 93       	push	r16
    2f10:	1f 93       	push	r17
    2f12:	df 93       	push	r29
    2f14:	cf 93       	push	r28
    2f16:	0f 92       	push	r0
    2f18:	0f 92       	push	r0
    2f1a:	cd b7       	in	r28, 0x3d	; 61
    2f1c:	de b7       	in	r29, 0x3e	; 62

	/* Just to remove compiler warning. */
	( void ) pvParameters;

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
    2f1e:	0e 94 02 07 	call	0xe04	; 0xe04 <xTaskGetTickCount>
    2f22:	9a 83       	std	Y+2, r25	; 0x02
    2f24:	89 83       	std	Y+1, r24	; 0x01
#if ( mainDEMOFULL == 1 )
	for( ;; )
	{
		/* Place this task in the blocked state until it is time to run again. */
		vTaskDelayUntil( &xNextWakeTime, xCycleFrequency );
    2f26:	8e 01       	movw	r16, r28
    2f28:	0f 5f       	subi	r16, 0xFF	; 255
    2f2a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f2c:	c8 01       	movw	r24, r16
    2f2e:	64 ec       	ldi	r22, 0xC4	; 196
    2f30:	79 e0       	ldi	r23, 0x09	; 9
    2f32:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vTaskDelayUntil>
		}
		#endif
#endif

#if ( mainDEMOFULL_NOTIFYTASK == 1 )
		if( xAreTaskNotificationTasksStillRunning() != pdTRUE )
    2f36:	a5 d9       	rcall	.-3254   	; 0x2282 <xAreTaskNotificationTasksStillRunning>
    2f38:	81 30       	cpi	r24, 0x01	; 1
    2f3a:	c1 f3       	breq	.-16     	; 0x2f2c <prvCheckTask+0x1e>
    2f3c:	a0 e0       	ldi	r26, 0x00	; 0
		{
			memcpy(pcStatusMessage, pcErrorNotification, mainERRORSIZE);
    2f3e:	bf e1       	ldi	r27, 0x1F	; 31
    2f40:	80 91 16 03 	lds	r24, 0x0316
    2f44:	90 91 17 03 	lds	r25, 0x0317
    2f48:	9c 01       	movw	r18, r24
    2f4a:	f9 01       	movw	r30, r18
    2f4c:	80 e2       	ldi	r24, 0x20	; 32
    2f4e:	01 90       	ld	r0, Z+
    2f50:	0d 92       	st	X+, r0
    2f52:	81 50       	subi	r24, 0x01	; 1
    2f54:	e1 f7       	brne	.-8      	; 0x2f4e <prvCheckTask+0x40>
    2f56:	86 e0       	ldi	r24, 0x06	; 6
		}
#endif

		if ( xCheckResult == pdFAIL)
		{
			vParTestToggleLED(mainCHECK_TASK_LED);
    2f58:	0e 94 34 01 	call	0x268	; 0x268 <vParTestToggleLED>
    2f5c:	e7 cf       	rjmp	.-50     	; 0x2f2c <prvCheckTask+0x1e>

00002f5e <__udivmodsi4>:
    2f5e:	a1 e2       	ldi	r26, 0x21	; 33
    2f60:	1a 2e       	mov	r1, r26
    2f62:	aa 1b       	sub	r26, r26
    2f64:	bb 1b       	sub	r27, r27
    2f66:	fd 01       	movw	r30, r26
    2f68:	0d c0       	rjmp	.+26     	; 0x2f84 <__udivmodsi4_ep>

00002f6a <__udivmodsi4_loop>:
    2f6a:	aa 1f       	adc	r26, r26
    2f6c:	bb 1f       	adc	r27, r27
    2f6e:	ee 1f       	adc	r30, r30
    2f70:	ff 1f       	adc	r31, r31
    2f72:	a2 17       	cp	r26, r18
    2f74:	b3 07       	cpc	r27, r19
    2f76:	e4 07       	cpc	r30, r20
    2f78:	f5 07       	cpc	r31, r21
    2f7a:	20 f0       	brcs	.+8      	; 0x2f84 <__udivmodsi4_ep>
    2f7c:	a2 1b       	sub	r26, r18
    2f7e:	b3 0b       	sbc	r27, r19
    2f80:	e4 0b       	sbc	r30, r20
    2f82:	f5 0b       	sbc	r31, r21

00002f84 <__udivmodsi4_ep>:
    2f84:	66 1f       	adc	r22, r22
    2f86:	77 1f       	adc	r23, r23
    2f88:	88 1f       	adc	r24, r24
    2f8a:	99 1f       	adc	r25, r25
    2f8c:	1a 94       	dec	r1
    2f8e:	69 f7       	brne	.-38     	; 0x2f6a <__udivmodsi4_loop>
    2f90:	60 95       	com	r22
    2f92:	70 95       	com	r23
    2f94:	80 95       	com	r24
    2f96:	90 95       	com	r25
    2f98:	9b 01       	movw	r18, r22
    2f9a:	ac 01       	movw	r20, r24
    2f9c:	bd 01       	movw	r22, r26
    2f9e:	cf 01       	movw	r24, r30
    2fa0:	08 95       	ret

00002fa2 <memcpy>:
    2fa2:	fb 01       	movw	r30, r22
    2fa4:	dc 01       	movw	r26, r24
    2fa6:	02 c0       	rjmp	.+4      	; 0x2fac <memcpy+0xa>
    2fa8:	01 90       	ld	r0, Z+
    2faa:	0d 92       	st	X+, r0
    2fac:	41 50       	subi	r20, 0x01	; 1
    2fae:	50 40       	sbci	r21, 0x00	; 0
    2fb0:	d8 f7       	brcc	.-10     	; 0x2fa8 <memcpy+0x6>
    2fb2:	08 95       	ret

00002fb4 <_exit>:
    2fb4:	f8 94       	cli

00002fb6 <__stop_program>:
    2fb6:	ff cf       	rjmp	.-2      	; 0x2fb6 <__stop_program>
